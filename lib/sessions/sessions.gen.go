// sessions v0.0.1 ec713d7bd2b4bafe4ae496ef51914651a0c3dd83
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/golang
// Do not edit by hand. Update your webrpc schema and re-generate.
package proto

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// WebRPC description and code-gen version
func WebRPCVersion() string {
	return "v1"
}

// Schema version of your RIDL schema
func WebRPCSchemaVersion() string {
	return "v0.0.1"
}

// Schema hash generated from your RIDL schema
func WebRPCSchemaHash() string {
	return "ec713d7bd2b4bafe4ae496ef51914651a0c3dd83"
}

//
// Types
//

type Config struct {
	Threshold uint16    `json:"threshold" db:"threshold"`
	Signers   []*Signer `json:"signers" db:"signers"`
	ImageHash string    `json:"imageHash" db:"imagehash"`
}

type Wallet struct {
	Address   string   `json:"address"`
	ImageHash string   `json:"imageHash"`
	Context   *Context `json:"context"`
}

type Context struct {
	Factory    string `json:"factory"`
	MainModule string `json:"mainModule"`
}

type Signer struct {
	Address string `json:"address"`
	Weight  uint8  `json:"weight"`
}

type Witness struct {
	Wallet string `json:"wallet" db:"wallet"`
	Digest string `json:"digest" db:"digest"`
}

type ImageHashSigner struct {
	Address   string `json:"address" db:"address"`
	ImageHash string `json:"imageHash" db:"imagehash"`
	Position  int    `json:"position" db:"position"`
}

type TransactionBody struct {
	Wallet       string  `json:"wallet" db:"wallet"`
	Tx           string  `json:"tx" db:"tx"`
	NewImageHash string  `json:"newImageHash" db:"newimagehash"`
	GapNonce     int64   `json:"gapNonce" db:"gapnonce"`
	Nonce        string  `json:"nonce" db:"nonce"`
	Digest       string  `json:"digest" db:"digest"`
	Update       *string `json:"update" db:"update"`
}

type Signature struct {
	ChainId   string `json:"chainId"`
	Signature string `json:"signature"`
}

type StoredSignature struct {
	SubDigest   string                      `json:"subDigest"`
	ChainId     string                      `json:"chainId"`
	Signer      string                      `json:"signer"`
	Signature   string                      `json:"signature"`
	Type        uint8                       `json:"type"`
	Transaction *StoredSignatureTransaction `json:"transaction"`
}

type StoredSignatureTransaction struct {
	Digest    string `json:"digest"`
	Wallet    string `json:"wallet"`
	ImageHash string `json:"imageHash"`
	GapNonce  string `json:"gapNonce"`
}

type SignedTransaction struct {
	Tx        *TransactionBody `json:"tx"`
	Signature *Signature       `json:"signature"`
}

type Stats struct {
	Total                  uint64 `json:"total"`
	KnownConfigurations    uint64 `json:"knownConfigurations"`
	KnownWallets           uint64 `json:"knownWallets"`
	KnownSigners           uint64 `json:"knownSigners"`
	KnownTransactionBodies uint64 `json:"knownTransactionBodies"`
	KnownSignatures        uint64 `json:"knownSignatures"`
	KnownWitnesses         uint64 `json:"knownWitnesses"`
}

type WalletOfSigner struct {
	Address string       `json:"address"`
	Proof   *SignerProof `json:"proof"`
}

type SignerProof struct {
	Digest    string `json:"digest"`
	ChainId   string `json:"chainId"`
	Signature string `json:"signature"`
}

type Sessions interface {
	SaveWallets(ctx context.Context, wallets []*Wallet) (bool, error)
	SaveConfigurations(ctx context.Context, configs []*Config) (bool, error)
	SavePresignedTransactions(ctx context.Context, rtx *TransactionBody, newConfig *Config, signatures []*Signature) (bool, error)
	SaveWitness(ctx context.Context, witness *Witness, signatures []*Signature) (bool, error)
	KnownConfigurations(ctx context.Context, start uint64, count uint64) ([]*Config, error)
	KnownWallets(ctx context.Context, start uint64, count uint64) ([]*Wallet, error)
	KnownSigners(ctx context.Context, start uint64, count uint64) ([]*ImageHashSigner, error)
	KnownTransactionBodies(ctx context.Context, start uint64, count uint64) ([]*TransactionBody, error)
	KnownSignatures(ctx context.Context, start uint64, count uint64) ([]*StoredSignature, error)
	KnownSignaturesOfSigner(ctx context.Context, signer string, start uint64, count uint64) ([]*StoredSignature, error)
	KnownWitnesses(ctx context.Context, start uint64, count uint64) ([]*Witness, error)
	ConfigurationForImageHash(ctx context.Context, imageHash string) (*Config, error)
	ImageHashForWallet(ctx context.Context, address string) ([]*Wallet, error)
	ImageHashesForSigner(ctx context.Context, address string, start uint64, count uint64) ([]*ImageHashSigner, error)
	PresignedTransactionForImageHash(ctx context.Context, imageHash string, fromImageHash string, wallet string, chainId string) (*TransactionBody, *Signature, error)
	PresignedRouteForImageHash(ctx context.Context, imageHash string, fromImageHash string, wallet string, chainId string, prependUpdate []string, assumedConfigs map[string]*Config, longestPath bool, gapNonce string) ([]*SignedTransaction, error)
	PresignedRouteForWallet(ctx context.Context, fromImageHash string, wallet string, chainId string, prependUpdate []string, assumedConfigs map[string]*Config, longestPath bool, gapNonce string) ([]*SignedTransaction, error)
	WalletsOfSigner(ctx context.Context, address string, start uint64, count uint64) ([]*WalletOfSigner, error)
	SignaturesForImageHash(ctx context.Context, imageHash string, start uint64, count uint64) ([]*StoredSignature, error)
	Stats(ctx context.Context) (*Stats, error)
}

var WebRPCServices = map[string][]string{
	"Sessions": {
		"SaveWallets",
		"SaveConfigurations",
		"SavePresignedTransactions",
		"SaveWitness",
		"KnownConfigurations",
		"KnownWallets",
		"KnownSigners",
		"KnownTransactionBodies",
		"KnownSignatures",
		"KnownSignaturesOfSigner",
		"KnownWitnesses",
		"ConfigurationForImageHash",
		"ImageHashForWallet",
		"ImageHashesForSigner",
		"PresignedTransactionForImageHash",
		"PresignedRouteForImageHash",
		"PresignedRouteForWallet",
		"WalletsOfSigner",
		"SignaturesForImageHash",
		"Stats",
	},
}

//
// Server
//

type WebRPCServer interface {
	http.Handler
}

type sessionsServer struct {
	Sessions
}

func NewSessionsServer(svc Sessions) WebRPCServer {
	return &sessionsServer{
		Sessions: svc,
	}
}

func (s *sessionsServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	ctx = context.WithValue(ctx, HTTPResponseWriterCtxKey, w)
	ctx = context.WithValue(ctx, HTTPRequestCtxKey, r)
	ctx = context.WithValue(ctx, ServiceNameCtxKey, "Sessions")

	if r.Method != "POST" {
		err := Errorf(ErrBadRoute, "unsupported method %q (only POST is allowed)", r.Method)
		RespondWithError(w, err)
		return
	}

	switch r.URL.Path {
	case "/rpc/Sessions/SaveWallets":
		s.serveSaveWallets(ctx, w, r)
		return
	case "/rpc/Sessions/SaveConfigurations":
		s.serveSaveConfigurations(ctx, w, r)
		return
	case "/rpc/Sessions/SavePresignedTransactions":
		s.serveSavePresignedTransactions(ctx, w, r)
		return
	case "/rpc/Sessions/SaveWitness":
		s.serveSaveWitness(ctx, w, r)
		return
	case "/rpc/Sessions/KnownConfigurations":
		s.serveKnownConfigurations(ctx, w, r)
		return
	case "/rpc/Sessions/KnownWallets":
		s.serveKnownWallets(ctx, w, r)
		return
	case "/rpc/Sessions/KnownSigners":
		s.serveKnownSigners(ctx, w, r)
		return
	case "/rpc/Sessions/KnownTransactionBodies":
		s.serveKnownTransactionBodies(ctx, w, r)
		return
	case "/rpc/Sessions/KnownSignatures":
		s.serveKnownSignatures(ctx, w, r)
		return
	case "/rpc/Sessions/KnownSignaturesOfSigner":
		s.serveKnownSignaturesOfSigner(ctx, w, r)
		return
	case "/rpc/Sessions/KnownWitnesses":
		s.serveKnownWitnesses(ctx, w, r)
		return
	case "/rpc/Sessions/ConfigurationForImageHash":
		s.serveConfigurationForImageHash(ctx, w, r)
		return
	case "/rpc/Sessions/ImageHashForWallet":
		s.serveImageHashForWallet(ctx, w, r)
		return
	case "/rpc/Sessions/ImageHashesForSigner":
		s.serveImageHashesForSigner(ctx, w, r)
		return
	case "/rpc/Sessions/PresignedTransactionForImageHash":
		s.servePresignedTransactionForImageHash(ctx, w, r)
		return
	case "/rpc/Sessions/PresignedRouteForImageHash":
		s.servePresignedRouteForImageHash(ctx, w, r)
		return
	case "/rpc/Sessions/PresignedRouteForWallet":
		s.servePresignedRouteForWallet(ctx, w, r)
		return
	case "/rpc/Sessions/WalletsOfSigner":
		s.serveWalletsOfSigner(ctx, w, r)
		return
	case "/rpc/Sessions/SignaturesForImageHash":
		s.serveSignaturesForImageHash(ctx, w, r)
		return
	case "/rpc/Sessions/Stats":
		s.serveStats(ctx, w, r)
		return
	default:
		err := Errorf(ErrBadRoute, "no handler for path %q", r.URL.Path)
		RespondWithError(w, err)
		return
	}
}

func (s *sessionsServer) serveSaveWallets(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveSaveWalletsJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveSaveWalletsJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "SaveWallets")
	reqContent := struct {
		Arg0 []*Wallet `json:"wallets"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 bool
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.SaveWallets(ctx, reqContent.Arg0)
	}()
	respContent := struct {
		Ret0 bool `json:"ok"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) serveSaveConfigurations(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveSaveConfigurationsJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveSaveConfigurationsJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "SaveConfigurations")
	reqContent := struct {
		Arg0 []*Config `json:"configs"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 bool
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.SaveConfigurations(ctx, reqContent.Arg0)
	}()
	respContent := struct {
		Ret0 bool `json:"ok"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) serveSavePresignedTransactions(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveSavePresignedTransactionsJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveSavePresignedTransactionsJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "SavePresignedTransactions")
	reqContent := struct {
		Arg0 *TransactionBody `json:"rtx"`
		Arg1 *Config          `json:"newConfig"`
		Arg2 []*Signature     `json:"signatures"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 bool
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.SavePresignedTransactions(ctx, reqContent.Arg0, reqContent.Arg1, reqContent.Arg2)
	}()
	respContent := struct {
		Ret0 bool `json:"ok"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) serveSaveWitness(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveSaveWitnessJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveSaveWitnessJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "SaveWitness")
	reqContent := struct {
		Arg0 *Witness     `json:"witness"`
		Arg1 []*Signature `json:"signatures"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 bool
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.SaveWitness(ctx, reqContent.Arg0, reqContent.Arg1)
	}()
	respContent := struct {
		Ret0 bool `json:"ok"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) serveKnownConfigurations(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveKnownConfigurationsJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveKnownConfigurationsJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "KnownConfigurations")
	reqContent := struct {
		Arg0 uint64 `json:"start"`
		Arg1 uint64 `json:"count"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 []*Config
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.KnownConfigurations(ctx, reqContent.Arg0, reqContent.Arg1)
	}()
	respContent := struct {
		Ret0 []*Config `json:"configs"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) serveKnownWallets(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveKnownWalletsJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveKnownWalletsJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "KnownWallets")
	reqContent := struct {
		Arg0 uint64 `json:"start"`
		Arg1 uint64 `json:"count"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 []*Wallet
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.KnownWallets(ctx, reqContent.Arg0, reqContent.Arg1)
	}()
	respContent := struct {
		Ret0 []*Wallet `json:"wallets"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) serveKnownSigners(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveKnownSignersJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveKnownSignersJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "KnownSigners")
	reqContent := struct {
		Arg0 uint64 `json:"start"`
		Arg1 uint64 `json:"count"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 []*ImageHashSigner
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.KnownSigners(ctx, reqContent.Arg0, reqContent.Arg1)
	}()
	respContent := struct {
		Ret0 []*ImageHashSigner `json:"signers"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) serveKnownTransactionBodies(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveKnownTransactionBodiesJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveKnownTransactionBodiesJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "KnownTransactionBodies")
	reqContent := struct {
		Arg0 uint64 `json:"start"`
		Arg1 uint64 `json:"count"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 []*TransactionBody
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.KnownTransactionBodies(ctx, reqContent.Arg0, reqContent.Arg1)
	}()
	respContent := struct {
		Ret0 []*TransactionBody `json:"rtx"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) serveKnownSignatures(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveKnownSignaturesJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveKnownSignaturesJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "KnownSignatures")
	reqContent := struct {
		Arg0 uint64 `json:"start"`
		Arg1 uint64 `json:"count"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 []*StoredSignature
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.KnownSignatures(ctx, reqContent.Arg0, reqContent.Arg1)
	}()
	respContent := struct {
		Ret0 []*StoredSignature `json:"signatures"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) serveKnownSignaturesOfSigner(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveKnownSignaturesOfSignerJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveKnownSignaturesOfSignerJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "KnownSignaturesOfSigner")
	reqContent := struct {
		Arg0 string `json:"signer"`
		Arg1 uint64 `json:"start"`
		Arg2 uint64 `json:"count"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 []*StoredSignature
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.KnownSignaturesOfSigner(ctx, reqContent.Arg0, reqContent.Arg1, reqContent.Arg2)
	}()
	respContent := struct {
		Ret0 []*StoredSignature `json:"signatures"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) serveKnownWitnesses(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveKnownWitnessesJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveKnownWitnessesJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "KnownWitnesses")
	reqContent := struct {
		Arg0 uint64 `json:"start"`
		Arg1 uint64 `json:"count"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 []*Witness
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.KnownWitnesses(ctx, reqContent.Arg0, reqContent.Arg1)
	}()
	respContent := struct {
		Ret0 []*Witness `json:"witnesses"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) serveConfigurationForImageHash(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveConfigurationForImageHashJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveConfigurationForImageHashJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "ConfigurationForImageHash")
	reqContent := struct {
		Arg0 string `json:"imageHash"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 *Config
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.ConfigurationForImageHash(ctx, reqContent.Arg0)
	}()
	respContent := struct {
		Ret0 *Config `json:"config"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) serveImageHashForWallet(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveImageHashForWalletJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveImageHashForWalletJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "ImageHashForWallet")
	reqContent := struct {
		Arg0 string `json:"address"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 []*Wallet
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.ImageHashForWallet(ctx, reqContent.Arg0)
	}()
	respContent := struct {
		Ret0 []*Wallet `json:"wallets"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) serveImageHashesForSigner(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveImageHashesForSignerJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveImageHashesForSignerJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "ImageHashesForSigner")
	reqContent := struct {
		Arg0 string `json:"address"`
		Arg1 uint64 `json:"start"`
		Arg2 uint64 `json:"count"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 []*ImageHashSigner
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.ImageHashesForSigner(ctx, reqContent.Arg0, reqContent.Arg1, reqContent.Arg2)
	}()
	respContent := struct {
		Ret0 []*ImageHashSigner `json:"signers"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) servePresignedTransactionForImageHash(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.servePresignedTransactionForImageHashJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) servePresignedTransactionForImageHashJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "PresignedTransactionForImageHash")
	reqContent := struct {
		Arg0 string `json:"imageHash"`
		Arg1 string `json:"fromImageHash"`
		Arg2 string `json:"wallet"`
		Arg3 string `json:"chainId"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 *TransactionBody
	var ret1 *Signature
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, ret1, err = s.Sessions.PresignedTransactionForImageHash(ctx, reqContent.Arg0, reqContent.Arg1, reqContent.Arg2, reqContent.Arg3)
	}()
	respContent := struct {
		Ret0 *TransactionBody `json:"tx"`
		Ret1 *Signature       `json:"sig"`
	}{ret0, ret1}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) servePresignedRouteForImageHash(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.servePresignedRouteForImageHashJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) servePresignedRouteForImageHashJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "PresignedRouteForImageHash")
	reqContent := struct {
		Arg0 string             `json:"imageHash"`
		Arg1 string             `json:"fromImageHash"`
		Arg2 string             `json:"wallet"`
		Arg3 string             `json:"chainId"`
		Arg4 []string           `json:"prependUpdate"`
		Arg5 map[string]*Config `json:"assumedConfigs"`
		Arg6 bool               `json:"longestPath"`
		Arg7 string             `json:"gapNonce"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 []*SignedTransaction
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.PresignedRouteForImageHash(ctx, reqContent.Arg0, reqContent.Arg1, reqContent.Arg2, reqContent.Arg3, reqContent.Arg4, reqContent.Arg5, reqContent.Arg6, reqContent.Arg7)
	}()
	respContent := struct {
		Ret0 []*SignedTransaction `json:"txs"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) servePresignedRouteForWallet(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.servePresignedRouteForWalletJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) servePresignedRouteForWalletJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "PresignedRouteForWallet")
	reqContent := struct {
		Arg0 string             `json:"fromImageHash"`
		Arg1 string             `json:"wallet"`
		Arg2 string             `json:"chainId"`
		Arg3 []string           `json:"prependUpdate"`
		Arg4 map[string]*Config `json:"assumedConfigs"`
		Arg5 bool               `json:"longestPath"`
		Arg6 string             `json:"gapNonce"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 []*SignedTransaction
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.PresignedRouteForWallet(ctx, reqContent.Arg0, reqContent.Arg1, reqContent.Arg2, reqContent.Arg3, reqContent.Arg4, reqContent.Arg5, reqContent.Arg6)
	}()
	respContent := struct {
		Ret0 []*SignedTransaction `json:"txs"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) serveWalletsOfSigner(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveWalletsOfSignerJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveWalletsOfSignerJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "WalletsOfSigner")
	reqContent := struct {
		Arg0 string `json:"address"`
		Arg1 uint64 `json:"start"`
		Arg2 uint64 `json:"count"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 []*WalletOfSigner
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.WalletsOfSigner(ctx, reqContent.Arg0, reqContent.Arg1, reqContent.Arg2)
	}()
	respContent := struct {
		Ret0 []*WalletOfSigner `json:"wallets"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) serveSignaturesForImageHash(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveSignaturesForImageHashJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveSignaturesForImageHashJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "SignaturesForImageHash")
	reqContent := struct {
		Arg0 string `json:"imageHash"`
		Arg1 uint64 `json:"start"`
		Arg2 uint64 `json:"count"`
	}{}

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to read request data")
		RespondWithError(w, err)
		return
	}
	defer r.Body.Close()

	err = json.Unmarshal(reqBody, &reqContent)
	if err != nil {
		err = WrapError(ErrInvalidArgument, err, "failed to unmarshal request data")
		RespondWithError(w, err)
		return
	}

	// Call service method
	var ret0 []*StoredSignature
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.SignaturesForImageHash(ctx, reqContent.Arg0, reqContent.Arg1, reqContent.Arg2)
	}()
	respContent := struct {
		Ret0 []*StoredSignature `json:"signatures"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *sessionsServer) serveStats(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	header := r.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}

	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveStatsJSON(ctx, w, r)
	default:
		err := Errorf(ErrBadRoute, "unexpected Content-Type: %q", r.Header.Get("Content-Type"))
		RespondWithError(w, err)
	}
}

func (s *sessionsServer) serveStatsJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	var err error
	ctx = context.WithValue(ctx, MethodNameCtxKey, "Stats")

	// Call service method
	var ret0 *Stats
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if rr := recover(); rr != nil {
				RespondWithError(w, ErrorInternal("internal service panic"))
				panic(rr)
			}
		}()
		ret0, err = s.Sessions.Stats(ctx)
	}()
	respContent := struct {
		Ret0 *Stats `json:"stats"`
	}{ret0}

	if err != nil {
		RespondWithError(w, err)
		return
	}
	respBody, err := json.Marshal(respContent)
	if err != nil {
		err = WrapError(ErrInternal, err, "failed to marshal json response")
		RespondWithError(w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func RespondWithError(w http.ResponseWriter, err error) {
	rpcErr, ok := err.(Error)
	if !ok {
		rpcErr = WrapError(ErrInternal, err, "webrpc error")
	}

	statusCode := HTTPStatusFromErrorCode(rpcErr.Code())

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)

	respBody, _ := json.Marshal(rpcErr.Payload())
	w.Write(respBody)
}

//
// Client
//

const SessionsPathPrefix = "/rpc/Sessions/"

type sessionsClient struct {
	client HTTPClient
	urls   [20]string
}

func NewSessionsClient(addr string, client HTTPClient) Sessions {
	prefix := urlBase(addr) + SessionsPathPrefix
	urls := [20]string{
		prefix + "SaveWallets",
		prefix + "SaveConfigurations",
		prefix + "SavePresignedTransactions",
		prefix + "SaveWitness",
		prefix + "KnownConfigurations",
		prefix + "KnownWallets",
		prefix + "KnownSigners",
		prefix + "KnownTransactionBodies",
		prefix + "KnownSignatures",
		prefix + "KnownSignaturesOfSigner",
		prefix + "KnownWitnesses",
		prefix + "ConfigurationForImageHash",
		prefix + "ImageHashForWallet",
		prefix + "ImageHashesForSigner",
		prefix + "PresignedTransactionForImageHash",
		prefix + "PresignedRouteForImageHash",
		prefix + "PresignedRouteForWallet",
		prefix + "WalletsOfSigner",
		prefix + "SignaturesForImageHash",
		prefix + "Stats",
	}
	return &sessionsClient{
		client: client,
		urls:   urls,
	}
}

func (c *sessionsClient) SaveWallets(ctx context.Context, wallets []*Wallet) (bool, error) {
	in := struct {
		Arg0 []*Wallet `json:"wallets"`
	}{wallets}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[0], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) SaveConfigurations(ctx context.Context, configs []*Config) (bool, error) {
	in := struct {
		Arg0 []*Config `json:"configs"`
	}{configs}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[1], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) SavePresignedTransactions(ctx context.Context, rtx *TransactionBody, newConfig *Config, signatures []*Signature) (bool, error) {
	in := struct {
		Arg0 *TransactionBody `json:"rtx"`
		Arg1 *Config          `json:"newConfig"`
		Arg2 []*Signature     `json:"signatures"`
	}{rtx, newConfig, signatures}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[2], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) SaveWitness(ctx context.Context, witness *Witness, signatures []*Signature) (bool, error) {
	in := struct {
		Arg0 *Witness     `json:"witness"`
		Arg1 []*Signature `json:"signatures"`
	}{witness, signatures}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[3], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) KnownConfigurations(ctx context.Context, start uint64, count uint64) ([]*Config, error) {
	in := struct {
		Arg0 uint64 `json:"start"`
		Arg1 uint64 `json:"count"`
	}{start, count}
	out := struct {
		Ret0 []*Config `json:"configs"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[4], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) KnownWallets(ctx context.Context, start uint64, count uint64) ([]*Wallet, error) {
	in := struct {
		Arg0 uint64 `json:"start"`
		Arg1 uint64 `json:"count"`
	}{start, count}
	out := struct {
		Ret0 []*Wallet `json:"wallets"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[5], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) KnownSigners(ctx context.Context, start uint64, count uint64) ([]*ImageHashSigner, error) {
	in := struct {
		Arg0 uint64 `json:"start"`
		Arg1 uint64 `json:"count"`
	}{start, count}
	out := struct {
		Ret0 []*ImageHashSigner `json:"signers"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[6], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) KnownTransactionBodies(ctx context.Context, start uint64, count uint64) ([]*TransactionBody, error) {
	in := struct {
		Arg0 uint64 `json:"start"`
		Arg1 uint64 `json:"count"`
	}{start, count}
	out := struct {
		Ret0 []*TransactionBody `json:"rtx"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[7], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) KnownSignatures(ctx context.Context, start uint64, count uint64) ([]*StoredSignature, error) {
	in := struct {
		Arg0 uint64 `json:"start"`
		Arg1 uint64 `json:"count"`
	}{start, count}
	out := struct {
		Ret0 []*StoredSignature `json:"signatures"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[8], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) KnownSignaturesOfSigner(ctx context.Context, signer string, start uint64, count uint64) ([]*StoredSignature, error) {
	in := struct {
		Arg0 string `json:"signer"`
		Arg1 uint64 `json:"start"`
		Arg2 uint64 `json:"count"`
	}{signer, start, count}
	out := struct {
		Ret0 []*StoredSignature `json:"signatures"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[9], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) KnownWitnesses(ctx context.Context, start uint64, count uint64) ([]*Witness, error) {
	in := struct {
		Arg0 uint64 `json:"start"`
		Arg1 uint64 `json:"count"`
	}{start, count}
	out := struct {
		Ret0 []*Witness `json:"witnesses"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[10], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) ConfigurationForImageHash(ctx context.Context, imageHash string) (*Config, error) {
	in := struct {
		Arg0 string `json:"imageHash"`
	}{imageHash}
	out := struct {
		Ret0 *Config `json:"config"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[11], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) ImageHashForWallet(ctx context.Context, address string) ([]*Wallet, error) {
	in := struct {
		Arg0 string `json:"address"`
	}{address}
	out := struct {
		Ret0 []*Wallet `json:"wallets"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[12], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) ImageHashesForSigner(ctx context.Context, address string, start uint64, count uint64) ([]*ImageHashSigner, error) {
	in := struct {
		Arg0 string `json:"address"`
		Arg1 uint64 `json:"start"`
		Arg2 uint64 `json:"count"`
	}{address, start, count}
	out := struct {
		Ret0 []*ImageHashSigner `json:"signers"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[13], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) PresignedTransactionForImageHash(ctx context.Context, imageHash string, fromImageHash string, wallet string, chainId string) (*TransactionBody, *Signature, error) {
	in := struct {
		Arg0 string `json:"imageHash"`
		Arg1 string `json:"fromImageHash"`
		Arg2 string `json:"wallet"`
		Arg3 string `json:"chainId"`
	}{imageHash, fromImageHash, wallet, chainId}
	out := struct {
		Ret0 *TransactionBody `json:"tx"`
		Ret1 *Signature       `json:"sig"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[14], in, &out)
	return out.Ret0, out.Ret1, err
}

func (c *sessionsClient) PresignedRouteForImageHash(ctx context.Context, imageHash string, fromImageHash string, wallet string, chainId string, prependUpdate []string, assumedConfigs map[string]*Config, longestPath bool, gapNonce string) ([]*SignedTransaction, error) {
	in := struct {
		Arg0 string             `json:"imageHash"`
		Arg1 string             `json:"fromImageHash"`
		Arg2 string             `json:"wallet"`
		Arg3 string             `json:"chainId"`
		Arg4 []string           `json:"prependUpdate"`
		Arg5 map[string]*Config `json:"assumedConfigs"`
		Arg6 bool               `json:"longestPath"`
		Arg7 string             `json:"gapNonce"`
	}{imageHash, fromImageHash, wallet, chainId, prependUpdate, assumedConfigs, longestPath, gapNonce}
	out := struct {
		Ret0 []*SignedTransaction `json:"txs"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[15], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) PresignedRouteForWallet(ctx context.Context, fromImageHash string, wallet string, chainId string, prependUpdate []string, assumedConfigs map[string]*Config, longestPath bool, gapNonce string) ([]*SignedTransaction, error) {
	in := struct {
		Arg0 string             `json:"fromImageHash"`
		Arg1 string             `json:"wallet"`
		Arg2 string             `json:"chainId"`
		Arg3 []string           `json:"prependUpdate"`
		Arg4 map[string]*Config `json:"assumedConfigs"`
		Arg5 bool               `json:"longestPath"`
		Arg6 string             `json:"gapNonce"`
	}{fromImageHash, wallet, chainId, prependUpdate, assumedConfigs, longestPath, gapNonce}
	out := struct {
		Ret0 []*SignedTransaction `json:"txs"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[16], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) WalletsOfSigner(ctx context.Context, address string, start uint64, count uint64) ([]*WalletOfSigner, error) {
	in := struct {
		Arg0 string `json:"address"`
		Arg1 uint64 `json:"start"`
		Arg2 uint64 `json:"count"`
	}{address, start, count}
	out := struct {
		Ret0 []*WalletOfSigner `json:"wallets"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[17], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) SignaturesForImageHash(ctx context.Context, imageHash string, start uint64, count uint64) ([]*StoredSignature, error) {
	in := struct {
		Arg0 string `json:"imageHash"`
		Arg1 uint64 `json:"start"`
		Arg2 uint64 `json:"count"`
	}{imageHash, start, count}
	out := struct {
		Ret0 []*StoredSignature `json:"signatures"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[18], in, &out)
	return out.Ret0, err
}

func (c *sessionsClient) Stats(ctx context.Context) (*Stats, error) {
	out := struct {
		Ret0 *Stats `json:"stats"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[19], nil, &out)
	return out.Ret0, err
}

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// urlBase helps ensure that addr specifies a scheme. If it is unparsable
// as a URL, it returns addr unchanged.
func urlBase(addr string) string {
	// If the addr specifies a scheme, use it. If not, default to
	// http. If url.Parse fails on it, return it unchanged.
	url, err := url.Parse(addr)
	if err != nil {
		return addr
	}
	if url.Scheme == "" {
		url.Scheme = "http"
	}
	return url.String()
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) {
	req, err := http.NewRequest("POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", contentType)
	req.Header.Set("Content-Type", contentType)
	if headers, ok := HTTPRequestHeaders(ctx); ok {
		for k := range headers {
			for _, v := range headers[k] {
				req.Header.Add(k, v)
			}
		}
	}
	return req, nil
}

// doJSONRequest is common code to make a request to the remote service.
func doJSONRequest(ctx context.Context, client HTTPClient, url string, in, out interface{}) error {
	reqBody, err := json.Marshal(in)
	if err != nil {
		return clientError("failed to marshal json request", err)
	}
	if err = ctx.Err(); err != nil {
		return clientError("aborted because context was done", err)
	}

	req, err := newRequest(ctx, url, bytes.NewBuffer(reqBody), "application/json")
	if err != nil {
		return clientError("could not build request", err)
	}
	resp, err := client.Do(req)
	if err != nil {
		return clientError("request failed", err)
	}

	defer func() {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = clientError("failed to close response body", cerr)
		}
	}()

	if err = ctx.Err(); err != nil {
		return clientError("aborted because context was done", err)
	}

	if resp.StatusCode != 200 {
		return errorFromResponse(resp)
	}

	if out != nil {
		respBody, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			return clientError("failed to read response body", err)
		}

		err = json.Unmarshal(respBody, &out)
		if err != nil {
			return clientError("failed to unmarshal json response body", err)
		}
		if err = ctx.Err(); err != nil {
			return clientError("aborted because context was done", err)
		}
	}

	return nil
}

// errorFromResponse builds a webrpc Error from a non-200 HTTP response.
func errorFromResponse(resp *http.Response) Error {
	respBody, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return clientError("failed to read server error response body", err)
	}

	var respErr ErrorPayload
	if err := json.Unmarshal(respBody, &respErr); err != nil {
		return clientError("failed unmarshal error response", err)
	}

	errCode := ErrorCode(respErr.Code)

	if HTTPStatusFromErrorCode(errCode) == 0 {
		return ErrorInternal("invalid code returned from server error response: %s", respErr.Code)
	}

	return &rpcErr{
		code:  errCode,
		msg:   respErr.Msg,
		cause: errors.New(respErr.Cause),
	}
}

func clientError(desc string, err error) Error {
	return WrapError(ErrInternal, err, desc)
}

func WithHTTPRequestHeaders(ctx context.Context, h http.Header) (context.Context, error) {
	if _, ok := h["Accept"]; ok {
		return nil, errors.New("provided header cannot set Accept")
	}
	if _, ok := h["Content-Type"]; ok {
		return nil, errors.New("provided header cannot set Content-Type")
	}

	copied := make(http.Header, len(h))
	for k, vv := range h {
		if vv == nil {
			copied[k] = nil
			continue
		}
		copied[k] = make([]string, len(vv))
		copy(copied[k], vv)
	}

	return context.WithValue(ctx, HTTPClientRequestHeadersCtxKey, copied), nil
}

func HTTPRequestHeaders(ctx context.Context) (http.Header, bool) {
	h, ok := ctx.Value(HTTPClientRequestHeadersCtxKey).(http.Header)
	return h, ok
}

//
// Helpers
//

type ErrorPayload struct {
	Status int    `json:"status"`
	Code   string `json:"code"`
	Cause  string `json:"cause,omitempty"`
	Msg    string `json:"msg"`
	Error  string `json:"error"`
}

type Error interface {
	// Code is of the valid error codes
	Code() ErrorCode

	// Msg returns a human-readable, unstructured messages describing the error
	Msg() string

	// Cause is reason for the error
	Cause() error

	// Error returns a string of the form "webrpc error <Code>: <Msg>"
	Error() string

	// Error response payload
	Payload() ErrorPayload
}

func Errorf(code ErrorCode, msgf string, args ...interface{}) Error {
	msg := fmt.Sprintf(msgf, args...)
	if IsValidErrorCode(code) {
		return &rpcErr{code: code, msg: msg}
	}
	return &rpcErr{code: ErrInternal, msg: "invalid error type " + string(code)}
}

func WrapError(code ErrorCode, cause error, format string, args ...interface{}) Error {
	msg := fmt.Sprintf(format, args...)
	if IsValidErrorCode(code) {
		return &rpcErr{code: code, msg: msg, cause: cause}
	}
	return &rpcErr{code: ErrInternal, msg: "invalid error type " + string(code), cause: cause}
}

func Failf(format string, args ...interface{}) Error {
	return Errorf(ErrFail, format, args...)
}

func WrapFailf(cause error, format string, args ...interface{}) Error {
	return WrapError(ErrFail, cause, format, args...)
}

func ErrorNotFound(format string, args ...interface{}) Error {
	return Errorf(ErrNotFound, format, args...)
}

func ErrorInvalidArgument(argument string, validationMsg string) Error {
	return Errorf(ErrInvalidArgument, argument+" "+validationMsg)
}

func ErrorRequiredArgument(argument string) Error {
	return ErrorInvalidArgument(argument, "is required")
}

func ErrorInternal(format string, args ...interface{}) Error {
	return Errorf(ErrInternal, format, args...)
}

type ErrorCode string

const (
	// Unknown error. For example when handling errors raised by APIs that do not
	// return enough error information.
	ErrUnknown ErrorCode = "unknown"

	// Fail error. General failure error type.
	ErrFail ErrorCode = "fail"

	// Canceled indicates the operation was cancelled (typically by the caller).
	ErrCanceled ErrorCode = "canceled"

	// InvalidArgument indicates client specified an invalid argument. It
	// indicates arguments that are problematic regardless of the state of the
	// system (i.e. a malformed file name, required argument, number out of range,
	// etc.).
	ErrInvalidArgument ErrorCode = "invalid argument"

	// DeadlineExceeded means operation expired before completion. For operations
	// that change the state of the system, this error may be returned even if the
	// operation has completed successfully (timeout).
	ErrDeadlineExceeded ErrorCode = "deadline exceeded"

	// NotFound means some requested entity was not found.
	ErrNotFound ErrorCode = "not found"

	// BadRoute means that the requested URL path wasn't routable to a webrpc
	// service and method. This is returned by the generated server, and usually
	// shouldn't be returned by applications. Instead, applications should use
	// NotFound or Unimplemented.
	ErrBadRoute ErrorCode = "bad route"

	// AlreadyExists means an attempt to create an entity failed because one
	// already exists.
	ErrAlreadyExists ErrorCode = "already exists"

	// PermissionDenied indicates the caller does not have permission to execute
	// the specified operation. It must not be used if the caller cannot be
	// identified (Unauthenticated).
	ErrPermissionDenied ErrorCode = "permission denied"

	// Unauthenticated indicates the request does not have valid authentication
	// credentials for the operation.
	ErrUnauthenticated ErrorCode = "unauthenticated"

	// ResourceExhausted indicates some resource has been exhausted, perhaps a
	// per-user quota, or perhaps the entire file system is out of space.
	ErrResourceExhausted ErrorCode = "resource exhausted"

	// FailedPrecondition indicates operation was rejected because the system is
	// not in a state required for the operation's execution. For example, doing
	// an rmdir operation on a directory that is non-empty, or on a non-directory
	// object, or when having conflicting read-modify-write on the same resource.
	ErrFailedPrecondition ErrorCode = "failed precondition"

	// Aborted indicates the operation was aborted, typically due to a concurrency
	// issue like sequencer check failures, transaction aborts, etc.
	ErrAborted ErrorCode = "aborted"

	// OutOfRange means operation was attempted past the valid range. For example,
	// seeking or reading past end of a paginated collection.
	//
	// Unlike InvalidArgument, this error indicates a problem that may be fixed if
	// the system state changes (i.e. adding more items to the collection).
	//
	// There is a fair bit of overlap between FailedPrecondition and OutOfRange.
	// We recommend using OutOfRange (the more specific error) when it applies so
	// that callers who are iterating through a space can easily look for an
	// OutOfRange error to detect when they are done.
	ErrOutOfRange ErrorCode = "out of range"

	// Unimplemented indicates operation is not implemented or not
	// supported/enabled in this service.
	ErrUnimplemented ErrorCode = "unimplemented"

	// Internal errors. When some invariants expected by the underlying system
	// have been broken. In other words, something bad happened in the library or
	// backend service. Do not confuse with HTTP Internal Server Error; an
	// Internal error could also happen on the client code, i.e. when parsing a
	// server response.
	ErrInternal ErrorCode = "internal"

	// Unavailable indicates the service is currently unavailable. This is a most
	// likely a transient condition and may be corrected by retrying with a
	// backoff.
	ErrUnavailable ErrorCode = "unavailable"

	// DataLoss indicates unrecoverable data loss or corruption.
	ErrDataLoss ErrorCode = "data loss"

	// ErrNone is the zero-value, is considered an empty error and should not be
	// used.
	ErrNone ErrorCode = ""
)

func HTTPStatusFromErrorCode(code ErrorCode) int {
	switch code {
	case ErrCanceled:
		return 408 // RequestTimeout
	case ErrUnknown:
		return 400 // Bad Request
	case ErrFail:
		return 422 // Unprocessable Entity
	case ErrInvalidArgument:
		return 400 // BadRequest
	case ErrDeadlineExceeded:
		return 408 // RequestTimeout
	case ErrNotFound:
		return 404 // Not Found
	case ErrBadRoute:
		return 404 // Not Found
	case ErrAlreadyExists:
		return 409 // Conflict
	case ErrPermissionDenied:
		return 403 // Forbidden
	case ErrUnauthenticated:
		return 401 // Unauthorized
	case ErrResourceExhausted:
		return 403 // Forbidden
	case ErrFailedPrecondition:
		return 412 // Precondition Failed
	case ErrAborted:
		return 409 // Conflict
	case ErrOutOfRange:
		return 400 // Bad Request
	case ErrUnimplemented:
		return 501 // Not Implemented
	case ErrInternal:
		return 500 // Internal Server Error
	case ErrUnavailable:
		return 503 // Service Unavailable
	case ErrDataLoss:
		return 500 // Internal Server Error
	case ErrNone:
		return 200 // OK
	default:
		return 0 // Invalid!
	}
}

func IsErrorCode(err error, code ErrorCode) bool {
	if rpcErr, ok := err.(Error); ok {
		if rpcErr.Code() == code {
			return true
		}
	}
	return false
}

func IsValidErrorCode(code ErrorCode) bool {
	return HTTPStatusFromErrorCode(code) != 0
}

type rpcErr struct {
	code  ErrorCode
	msg   string
	cause error
}

func (e *rpcErr) Code() ErrorCode {
	return e.code
}

func (e *rpcErr) Msg() string {
	return e.msg
}

func (e *rpcErr) Cause() error {
	return e.cause
}

func (e *rpcErr) Error() string {
	if e.cause != nil && e.cause.Error() != "" {
		if e.msg != "" {
			return fmt.Sprintf("webrpc %s error: %s -- %s", e.code, e.cause.Error(), e.msg)
		} else {
			return fmt.Sprintf("webrpc %s error: %s", e.code, e.cause.Error())
		}
	} else {
		return fmt.Sprintf("webrpc %s error: %s", e.code, e.msg)
	}
}

func (e *rpcErr) Payload() ErrorPayload {
	statusCode := HTTPStatusFromErrorCode(e.Code())
	errPayload := ErrorPayload{
		Status: statusCode,
		Code:   string(e.Code()),
		Msg:    e.Msg(),
		Error:  e.Error(),
	}
	if e.Cause() != nil {
		errPayload.Cause = e.Cause().Error()
	}
	return errPayload
}

type contextKey struct {
	name string
}

func (k *contextKey) String() string {
	return "webrpc context value " + k.name
}

var (
	// For Client
	HTTPClientRequestHeadersCtxKey = &contextKey{"HTTPClientRequestHeaders"}

	// For Server
	HTTPResponseWriterCtxKey = &contextKey{"HTTPResponseWriter"}

	HTTPRequestCtxKey = &contextKey{"HTTPRequest"}

	ServiceNameCtxKey = &contextKey{"ServiceName"}

	MethodNameCtxKey = &contextKey{"MethodName"}
)
