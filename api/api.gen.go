// sequence-api v0.4.0 3c1782dee5a602d773450bdb42c84515771d30d1
// --
// Code generated by webrpc-gen@v0.18.6 with golang generator. DO NOT EDIT.
//
// webrpc-gen -schema=api.ridl -target=golang -pkg=api -client -out=./clients/api.gen.go
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"

	"github.com/0xsequence/go-sequence/lib/prototyp"
)

// WebRPC description and code-gen version
func WebRPCVersion() string {
	return "v1"
}

// Schema version of your RIDL schema
func WebRPCSchemaVersion() string {
	return "v0.4.0"
}

// Schema hash generated from your RIDL schema
func WebRPCSchemaHash() string {
	return "3c1782dee5a602d773450bdb42c84515771d30d1"
}

//
// Common types
//

type SortOrder uint32

const (
	SortOrder_DESC SortOrder = 0
	SortOrder_ASC  SortOrder = 1
)

var SortOrder_name = map[uint32]string{
	0: "DESC",
	1: "ASC",
}

var SortOrder_value = map[string]uint32{
	"DESC": 0,
	"ASC":  1,
}

func (x SortOrder) String() string {
	return SortOrder_name[uint32(x)]
}

func (x SortOrder) MarshalText() ([]byte, error) {
	return []byte(SortOrder_name[uint32(x)]), nil
}

func (x *SortOrder) UnmarshalText(b []byte) error {
	*x = SortOrder(SortOrder_value[string(b)])
	return nil
}

func (x *SortOrder) Is(values ...SortOrder) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type Version struct {
	WebrpcVersion string `json:"webrpcVersion"`
	SchemaVersion string `json:"schemaVersion"`
	SchemaHash    string `json:"schemaHash"`
	AppVersion    string `json:"appVersion"`
}

type RuntimeStatus struct {
	// overall status, true/false
	HealthOK       bool                       `json:"healthOK"`
	StartTime      time.Time                  `json:"startTime"`
	Uptime         uint64                     `json:"uptime"`
	Ver            string                     `json:"ver"`
	Branch         string                     `json:"branch"`
	CommitHash     string                     `json:"commitHash"`
	Checks         *RuntimeChecks             `json:"checks"`
	NumTxnsRelayed map[string]*NumTxnsRelayed `json:"numTxnsRelayed"`
}

type NumTxnsRelayed struct {
	ChainID uint64 `json:"chainID"`
	Prev    uint64 `json:"prev"`
	Current uint64 `json:"current"`
	Period  uint64 `json:"period"`
}

type RuntimeChecks struct {
}

type SequenceContext struct {
	Factory              string `json:"factory"`
	MainModule           string `json:"mainModule"`
	MainModuleUpgradable string `json:"mainModuleUpgradable"`
	GuestModule          string `json:"guestModule"`
	Utils                string `json:"utils"`
}

// Users
type User struct {
	Address            prototyp.Hash `json:"address" db:"address"`
	Username           string        `json:"username" db:"username"`
	NormalizedUsername string        `json:"-" db:"normalized_username"`
	Avatar             string        `json:"avatar" db:"avatar"`
	Bio                string        `json:"bio" db:"bio"`
	Location           string        `json:"location" db:"location"`
	Locale             string        `json:"locale" db:"locale"`
	Backup             *bool         `json:"backup,omitempty" db:"-"`
	BackupConfirmed    *bool         `json:"backupConfirmed,omitempty" db:"-"`
	MaxInvites         *uint32       `json:"maxInvites" db:"max_invites"`
	UpdatedAt          *time.Time    `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt          *time.Time    `json:"createdAt,omitempty" db:"created_at,omitempty"`
	SysAdmin           bool          `json:"-" db:"sys_admin"`
}

// Wallet Backup
type WalletBackup struct {
	AccountAddress  prototyp.Hash `json:"accountAddress" db:"account_address"`
	SecretHash      string        `json:"secretHash" db:"secret_hash"`
	EncryptedWallet string        `json:"encryptedWallet" db:"encrypted_wallet"`
	// userConfirmed is a flag that the user tells us they've backed up
	// their wallet mnemonic for future recovery. It's just a user-experience field
	// so we can nag them if they haven't confirmed yet.
	UserConfirmed bool       `json:"userConfirmed" db:"user_confirmed"`
	UpdatedAt     *time.Time `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt     *time.Time `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// Friends
type Friend struct {
	ID            uint64        `json:"id" db:"id,omitempty"`
	UserAddress   prototyp.Hash `json:"userAddress" db:"user_address"`
	FriendAddress prototyp.Hash `json:"friendAddress" db:"friend_address"`
	// Nickname allows the user to assign a friend a label, useful for the case
	// when that friend doesn't have an arcadeum user account
	Nickname  string     `json:"nickname" db:"nickname"`
	User      *User      `json:"user" db:"-"`
	CreatedAt *time.Time `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// InviteCode
type InviteCode struct {
	Code         string             `json:"-" db:"code"`
	Source       string             `json:"-" db:"source"`
	UsesLeft     uint32             `json:"usesLeft" db:"uses_left"`
	OwnerAccount prototyp.HashMaybe `json:"ownerAccount" db:"owner_account"`
	Email        *string            `json:"email" db:"email"`
	Url          string             `json:"url"`
	CreatedAt    *time.Time         `json:"createdAt,omitempty" db:"created_at,omitempty"`
	ExpiresAt    *time.Time         `json:"expiresAt,omitempty" db:"expires_at,omitempty"`
}

// InviteCode Account
type InviteCodeAccount struct {
	Code                 string        `json:"-" db:"code"`
	ClaimedByUserAddress prototyp.Hash `json:"claimedByUserAddress" db:"claimed_by_user_address"`
	ClaimedAt            *time.Time    `json:"claimedAt,omitempty" db:"claimed_at,omitempty"`
}

// Invite info
type InviteInfo struct {
	ExpiryInHours uint32        `json:"expiryInHours"`
	Max           uint32        `json:"max"`
	Invites       []*InviteCode `json:"invites"`
}

type ContractCall struct {
	Signature string            `json:"signature"`
	Function  string            `json:"function"`
	Args      []*TupleComponent `json:"args"`
}

type TupleComponent struct {
	Name  *string     `json:"name"`
	Type  string      `json:"type"`
	Value interface{} `json:"value"`
}

type Transaction struct {
	DelegateCall  bool            `json:"delegateCall"`
	RevertOnError bool            `json:"revertOnError"`
	GasLimit      prototyp.BigInt `json:"gasLimit"`
	Target        string          `json:"target"`
	Value         prototyp.BigInt `json:"value"`
	Data          string          `json:"data"`
	Call          *ContractCall   `json:"call"`
}

type UserStorage struct {
	UserAddress prototyp.Hash       `json:"userAddress" db:"user_address"`
	Key         string              `json:"key"`
	Value       prototyp.JSONString `json:"value"`
}

type Token struct {
	ChainId         uint64        `json:"chainId"`
	ContractAddress prototyp.Hash `json:"contractAddress"`
	TokenId         *string       `json:"tokenId"`
}

type Price struct {
	Value    float64 `json:"value"`
	Currency string  `json:"currency"`
}

type TokenPrice struct {
	Token          *Token     `json:"token"`
	Price          *Price     `json:"price"`
	Price24hChange *Price     `json:"price24hChange"`
	FloorPrice     *Price     `json:"floorPrice,omitempty"`
	BuyPrice       *Price     `json:"buyPrice,omitempty"`
	SellPrice      *Price     `json:"sellPrice,omitempty"`
	UpdatedAt      *time.Time `json:"updatedAt"`
}

type ExchangeRate struct {
	Name         string  `json:"name"`
	Symbol       string  `json:"symbol"`
	Value        float64 `json:"value"`
	VsCurrency   string  `json:"vsCurrency"`
	CurrencyType string  `json:"currencyType"`
}

type LinkedWallet struct {
	ID                  uint64        `json:"id" db:"id,omitempty"`
	WalletAddress       prototyp.Hash `json:"walletAddress" db:"wallet_address"`
	LinkedWalletAddress prototyp.Hash `json:"linkedWalletAddress" db:"linked_wallet_address"`
	CreatedAt           *time.Time    `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// TOOD: refactor, we should be returning a cursor always..
// see indexer/indexer.ridl Page object..
//
// ---
//
// Page represents a results page. This can be used both to request a page and
// to store the state of a page.
type Page struct {
	// Common for both numbered pages and cursor: Number of items per page
	// TODO: REMOVE..
	PageSize *uint32 `json:"pageSize"`
	// Numbered pages: Page number, this is multiplied by the value of the <pageSize> parameter.
	// TODO: REMOVE..
	Page *uint32 `json:"page"`
	// Number of total items on this query.
	// TODO: REMOVE..
	TotalRecords *uint64 `json:"totalRecords"`
	// Cursor: column to compare before/after to
	Column *string `json:"column"`
	// Cursor: return column < before - include to get previous page
	Before *interface{} `json:"before"`
	// Cursor: return column > after - include to get next page
	After *interface{} `json:"after"`
	// Sorting filter
	Sort []*SortBy `json:"sort"`
	// Indicates if there are more results available
	More *bool `json:"more,omitempty"`
}

type SortBy struct {
	Column string    `json:"column"`
	Order  SortOrder `json:"order"`
}

type NftCheckoutParams struct {
	Name             string `json:"name"`
	ImageUrl         string `json:"imageUrl"`
	Network          string `json:"network"`
	RecipientAddress string `json:"recipientAddress"`
	BlockchainNftId  string `json:"blockchainNftId"`
	ContractAddress  string `json:"contractAddress"`
	Quantity         int    `json:"quantity"`
	Decimals         *int   `json:"decimals"`
}

type NftCheckout struct {
	Token     string `json:"token"`
	ExpiresAt string `json:"expiresAt"`
	OrderId   string `json:"orderId"`
}

type SardineOrder struct {
	Id                  string     `json:"id"`
	CreatedAt           *time.Time `json:"createdAt"`
	ReferenceId         string     `json:"referenceId"`
	Status              string     `json:"status"`
	FiatCurrency        string     `json:"fiatCurrency"`
	FiatExchangeRateUSD float64    `json:"fiatExchangeRateUSD"`
	TransactionId       string     `json:"transactionId"`
	ExpiresAt           *time.Time `json:"expiresAt"`
	Total               float64    `json:"total"`
	SubTotal            float64    `json:"subTotal"`
	TransactionFee      float64    `json:"transactionFee"`
	NetworkFee          float64    `json:"networkFee"`
	PaymentCurrency     *string    `json:"paymentCurrency"`
	PaymentMethodType   *string    `json:"paymentMethodType"`
	TransactionType     string     `json:"transactionType"`
	Name                string     `json:"name"`
	Price               int        `json:"price"`
	ImageUrl            string     `json:"imageUrl"`
	ContractAddress     *string    `json:"contractAddress"`
}

var WebRPCServices = map[string][]string{
	"API": {
		"Ping",
		"Version",
		"RuntimeStatus",
		"Clock",
		"GetSequenceContext",
		"GetAuthToken",
		"GetAuthToken2",
		"SendPasswordlessLink",
		"FriendList",
		"GetFriendByAddress",
		"SearchFriends",
		"AddFriend",
		"UpdateFriendNickname",
		"RemoveFriend",
		"ContractCall",
		"DecodeContractCall",
		"LookupContractCallSelectors",
		"UserStorageFetch",
		"UserStorageSave",
		"UserStorageDelete",
		"UserStorageFetchAll",
		"GetMoonpayLink",
		"GetSardineClientToken",
		"GetSardineNFTCheckoutToken",
		"GetSardineNFTCheckoutOrderStatus",
		"ResolveENSAddress",
		"IsValidSignature",
		"IsValidMessageSignature",
		"IsValidTypedDataSignature",
		"IsValidETHAuthProof",
		"GetCoinPrices",
		"GetCollectiblePrices",
		"GetExchangeRate",
		"MemoryStore",
		"MemoryLoad",
		"GetInviteInfo",
		"IsValidAccessCode",
		"InternalClaimAccessCode",
		"BlockNumberAtTime",
		"PaperSessionSecret",
		"PaperSessionSecret2",
		"LinkWallet",
		"GetLinkedWallets",
	},
}

//
// Server types
//

type API interface {
	//
	// Runtime
	//
	Ping(ctx context.Context) (bool, error)
	Version(ctx context.Context) (*Version, error)
	RuntimeStatus(ctx context.Context) (*RuntimeStatus, error)
	Clock(ctx context.Context) (time.Time, error)
	GetSequenceContext(ctx context.Context) (*SequenceContext, error)
	//
	// Auth
	//
	// TODO: rename 'ewtString' arg to 'ethauthProof'
	GetAuthToken(ctx context.Context, ewtString string, testnetMode *bool) (bool, string, string, *User, error)
	GetAuthToken2(ctx context.Context, ewtString string, chainID string) (bool, string, string, *User, error)
	SendPasswordlessLink(ctx context.Context, email string, redirectUri string, intent string) (bool, error)
	//
	// Contacts / Friends
	//
	FriendList(ctx context.Context, nickname *string, page *Page) (*Page, []*Friend, error)
	GetFriendByAddress(ctx context.Context, friendAddress string) (bool, *Friend, error)
	SearchFriends(ctx context.Context, filterUsername string, page *Page) ([]*Friend, error)
	AddFriend(ctx context.Context, friendAddress string, optionalNickname *string) (bool, *Friend, error)
	UpdateFriendNickname(ctx context.Context, friendAddress string, nickname string) (bool, *Friend, error)
	RemoveFriend(ctx context.Context, friendAddress string) (bool, error)
	//
	// Chain-Utils
	//
	ContractCall(ctx context.Context, chainID string, contract string, inputExpr string, outputExpr string, args []string) ([]string, error)
	DecodeContractCall(ctx context.Context, callData string) (*ContractCall, error)
	LookupContractCallSelectors(ctx context.Context, selectors []string) ([][]string, error)
	//
	// User Storage
	//
	UserStorageFetch(ctx context.Context, key string) (interface{}, error)
	UserStorageSave(ctx context.Context, key string, object interface{}) (bool, error)
	UserStorageDelete(ctx context.Context, key string) (bool, error)
	UserStorageFetchAll(ctx context.Context, keys []string) (map[string]interface{}, error)
	//
	// Wallet utils
	//
	GetMoonpayLink(ctx context.Context, url string) (string, error)
	GetSardineClientToken(ctx context.Context) (string, error)
	GetSardineNFTCheckoutToken(ctx context.Context, params *NftCheckoutParams) (*NftCheckout, error)
	GetSardineNFTCheckoutOrderStatus(ctx context.Context, orderId string) (*SardineOrder, error)
	// - IsUsingGoogleMail(domain: string) => (yes: bool)
	ResolveENSAddress(ctx context.Context, ens string) (string, bool, error)
	// TODO: we can add walletContext optional in the future when we need it
	// NOTE: chainId can be either a number or canonical name
	IsValidSignature(ctx context.Context, chainId string, walletAddress string, digest string, signature string) (bool, error)
	IsValidMessageSignature(ctx context.Context, chainId string, walletAddress string, message string, signature string) (bool, error)
	IsValidTypedDataSignature(ctx context.Context, chainId string, walletAddress string, typedData interface{}, signature string) (bool, error)
	IsValidETHAuthProof(ctx context.Context, chainId string, walletAddress string, ethAuthProofString string) (bool, error)
	//
	// Price Feed
	//
	GetCoinPrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
	GetCollectiblePrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
	//
	// Price Feed utils
	//
	GetExchangeRate(ctx context.Context, toCurrency string) (*ExchangeRate, error)
	//
	// Util / misc
	//
	MemoryStore(ctx context.Context, key string, value string) (bool, error)
	MemoryLoad(ctx context.Context, key string) (string, error)
	//
	// Legacy
	//
	GetInviteInfo(ctx context.Context) (*InviteInfo, error)
	// NOTE: we're still using this from SW-API to Sequence-API to claim invite code
	IsValidAccessCode(ctx context.Context, accessCode string) (bool, error)
	InternalClaimAccessCode(ctx context.Context, address string, accessCode string) (bool, error)
	// Utils
	BlockNumberAtTime(ctx context.Context, chainId uint64, timestamps []uint64) ([]uint64, error)
	//
	// Paper
	// TODO: deprecate in the future
	//
	PaperSessionSecret(ctx context.Context, chainName string, contractAddress string, paramsJson string, contractType string) (string, error)
	PaperSessionSecret2(ctx context.Context, chainName string, contractAddress string, paramsJson string, abi string) (string, error)
	//
	// Linked wallets (v0 -- simple support)
	//
	LinkWallet(ctx context.Context, chainId string, walletAddress string, ethAuthProofString string, linkedWalletMessage string, linkedWalletSignature string) (bool, string, error)
	GetLinkedWallets(ctx context.Context, walletAddress string) ([]string, error)
}

//
// Client types
//

type APIClient interface {
	//
	// Runtime
	//
	Ping(ctx context.Context) (bool, error)
	Version(ctx context.Context) (*Version, error)
	RuntimeStatus(ctx context.Context) (*RuntimeStatus, error)
	Clock(ctx context.Context) (time.Time, error)
	GetSequenceContext(ctx context.Context) (*SequenceContext, error)
	//
	// Auth
	//
	// TODO: rename 'ewtString' arg to 'ethauthProof'
	GetAuthToken(ctx context.Context, ewtString string, testnetMode *bool) (bool, string, string, *User, error)
	GetAuthToken2(ctx context.Context, ewtString string, chainID string) (bool, string, string, *User, error)
	SendPasswordlessLink(ctx context.Context, email string, redirectUri string, intent string) (bool, error)
	//
	// Contacts / Friends
	//
	FriendList(ctx context.Context, nickname *string, page *Page) (*Page, []*Friend, error)
	GetFriendByAddress(ctx context.Context, friendAddress string) (bool, *Friend, error)
	SearchFriends(ctx context.Context, filterUsername string, page *Page) ([]*Friend, error)
	AddFriend(ctx context.Context, friendAddress string, optionalNickname *string) (bool, *Friend, error)
	UpdateFriendNickname(ctx context.Context, friendAddress string, nickname string) (bool, *Friend, error)
	RemoveFriend(ctx context.Context, friendAddress string) (bool, error)
	//
	// Chain-Utils
	//
	ContractCall(ctx context.Context, chainID string, contract string, inputExpr string, outputExpr string, args []string) ([]string, error)
	DecodeContractCall(ctx context.Context, callData string) (*ContractCall, error)
	LookupContractCallSelectors(ctx context.Context, selectors []string) ([][]string, error)
	//
	// User Storage
	//
	UserStorageFetch(ctx context.Context, key string) (interface{}, error)
	UserStorageSave(ctx context.Context, key string, object interface{}) (bool, error)
	UserStorageDelete(ctx context.Context, key string) (bool, error)
	UserStorageFetchAll(ctx context.Context, keys []string) (map[string]interface{}, error)
	//
	// Wallet utils
	//
	GetMoonpayLink(ctx context.Context, url string) (string, error)
	GetSardineClientToken(ctx context.Context) (string, error)
	GetSardineNFTCheckoutToken(ctx context.Context, params *NftCheckoutParams) (*NftCheckout, error)
	GetSardineNFTCheckoutOrderStatus(ctx context.Context, orderId string) (*SardineOrder, error)
	// - IsUsingGoogleMail(domain: string) => (yes: bool)
	ResolveENSAddress(ctx context.Context, ens string) (string, bool, error)
	// TODO: we can add walletContext optional in the future when we need it
	// NOTE: chainId can be either a number or canonical name
	IsValidSignature(ctx context.Context, chainId string, walletAddress string, digest string, signature string) (bool, error)
	IsValidMessageSignature(ctx context.Context, chainId string, walletAddress string, message string, signature string) (bool, error)
	IsValidTypedDataSignature(ctx context.Context, chainId string, walletAddress string, typedData interface{}, signature string) (bool, error)
	IsValidETHAuthProof(ctx context.Context, chainId string, walletAddress string, ethAuthProofString string) (bool, error)
	//
	// Price Feed
	//
	GetCoinPrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
	GetCollectiblePrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
	//
	// Price Feed utils
	//
	GetExchangeRate(ctx context.Context, toCurrency string) (*ExchangeRate, error)
	//
	// Util / misc
	//
	MemoryStore(ctx context.Context, key string, value string) (bool, error)
	MemoryLoad(ctx context.Context, key string) (string, error)
	//
	// Legacy
	//
	GetInviteInfo(ctx context.Context) (*InviteInfo, error)
	// NOTE: we're still using this from SW-API to Sequence-API to claim invite code
	IsValidAccessCode(ctx context.Context, accessCode string) (bool, error)
	InternalClaimAccessCode(ctx context.Context, address string, accessCode string) (bool, error)
	// Utils
	BlockNumberAtTime(ctx context.Context, chainId uint64, timestamps []uint64) ([]uint64, error)
	//
	// Paper
	// TODO: deprecate in the future
	//
	PaperSessionSecret(ctx context.Context, chainName string, contractAddress string, paramsJson string, contractType string) (string, error)
	PaperSessionSecret2(ctx context.Context, chainName string, contractAddress string, paramsJson string, abi string) (string, error)
	//
	// Linked wallets (v0 -- simple support)
	//
	LinkWallet(ctx context.Context, chainId string, walletAddress string, ethAuthProofString string, linkedWalletMessage string, linkedWalletSignature string) (bool, string, error)
	GetLinkedWallets(ctx context.Context, walletAddress string) ([]string, error)
}

//
// Client
//

const APIPathPrefix = "/rpc/API/"

type aPIClient struct {
	client HTTPClient
	urls   [43]string
}

func NewAPIClient(addr string, client HTTPClient) APIClient {
	prefix := urlBase(addr) + APIPathPrefix
	urls := [43]string{
		prefix + "Ping",
		prefix + "Version",
		prefix + "RuntimeStatus",
		prefix + "Clock",
		prefix + "GetSequenceContext",
		prefix + "GetAuthToken",
		prefix + "GetAuthToken2",
		prefix + "SendPasswordlessLink",
		prefix + "FriendList",
		prefix + "GetFriendByAddress",
		prefix + "SearchFriends",
		prefix + "AddFriend",
		prefix + "UpdateFriendNickname",
		prefix + "RemoveFriend",
		prefix + "ContractCall",
		prefix + "DecodeContractCall",
		prefix + "LookupContractCallSelectors",
		prefix + "UserStorageFetch",
		prefix + "UserStorageSave",
		prefix + "UserStorageDelete",
		prefix + "UserStorageFetchAll",
		prefix + "GetMoonpayLink",
		prefix + "GetSardineClientToken",
		prefix + "GetSardineNFTCheckoutToken",
		prefix + "GetSardineNFTCheckoutOrderStatus",
		prefix + "ResolveENSAddress",
		prefix + "IsValidSignature",
		prefix + "IsValidMessageSignature",
		prefix + "IsValidTypedDataSignature",
		prefix + "IsValidETHAuthProof",
		prefix + "GetCoinPrices",
		prefix + "GetCollectiblePrices",
		prefix + "GetExchangeRate",
		prefix + "MemoryStore",
		prefix + "MemoryLoad",
		prefix + "GetInviteInfo",
		prefix + "IsValidAccessCode",
		prefix + "InternalClaimAccessCode",
		prefix + "BlockNumberAtTime",
		prefix + "PaperSessionSecret",
		prefix + "PaperSessionSecret2",
		prefix + "LinkWallet",
		prefix + "GetLinkedWallets",
	}
	return &aPIClient{
		client: client,
		urls:   urls,
	}
}

func (c *aPIClient) Ping(ctx context.Context) (bool, error) {
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) Version(ctx context.Context) (*Version, error) {
	out := struct {
		Ret0 *Version `json:"version"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) RuntimeStatus(ctx context.Context) (*RuntimeStatus, error) {
	out := struct {
		Ret0 *RuntimeStatus `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) Clock(ctx context.Context) (time.Time, error) {
	out := struct {
		Ret0 time.Time `json:"serverTime"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSequenceContext(ctx context.Context) (*SequenceContext, error) {
	out := struct {
		Ret0 *SequenceContext `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetAuthToken(ctx context.Context, ewtString string, testnetMode *bool) (bool, string, string, *User, error) {
	in := struct {
		Arg0 string `json:"ewtString"`
		Arg1 *bool  `json:"testnetMode"`
	}{ewtString, testnetMode}
	out := struct {
		Ret0 bool   `json:"status"`
		Ret1 string `json:"jwtToken"`
		Ret2 string `json:"address"`
		Ret3 *User  `json:"user"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[5], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, out.Ret1, out.Ret2, out.Ret3, err
}

func (c *aPIClient) GetAuthToken2(ctx context.Context, ewtString string, chainID string) (bool, string, string, *User, error) {
	in := struct {
		Arg0 string `json:"ewtString"`
		Arg1 string `json:"chainID"`
	}{ewtString, chainID}
	out := struct {
		Ret0 bool   `json:"status"`
		Ret1 string `json:"jwtToken"`
		Ret2 string `json:"address"`
		Ret3 *User  `json:"user"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[6], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, out.Ret1, out.Ret2, out.Ret3, err
}

func (c *aPIClient) SendPasswordlessLink(ctx context.Context, email string, redirectUri string, intent string) (bool, error) {
	in := struct {
		Arg0 string `json:"email"`
		Arg1 string `json:"redirectUri"`
		Arg2 string `json:"intent"`
	}{email, redirectUri, intent}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[7], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) FriendList(ctx context.Context, nickname *string, page *Page) (*Page, []*Friend, error) {
	in := struct {
		Arg0 *string `json:"nickname"`
		Arg1 *Page   `json:"page"`
	}{nickname, page}
	out := struct {
		Ret0 *Page     `json:"page"`
		Ret1 []*Friend `json:"friends"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[8], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) GetFriendByAddress(ctx context.Context, friendAddress string) (bool, *Friend, error) {
	in := struct {
		Arg0 string `json:"friendAddress"`
	}{friendAddress}
	out := struct {
		Ret0 bool    `json:"status"`
		Ret1 *Friend `json:"friend"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[9], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) SearchFriends(ctx context.Context, filterUsername string, page *Page) ([]*Friend, error) {
	in := struct {
		Arg0 string `json:"filterUsername"`
		Arg1 *Page  `json:"page"`
	}{filterUsername, page}
	out := struct {
		Ret0 []*Friend `json:"friends"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[10], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) AddFriend(ctx context.Context, friendAddress string, optionalNickname *string) (bool, *Friend, error) {
	in := struct {
		Arg0 string  `json:"friendAddress"`
		Arg1 *string `json:"optionalNickname"`
	}{friendAddress, optionalNickname}
	out := struct {
		Ret0 bool    `json:"status"`
		Ret1 *Friend `json:"friend"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[11], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) UpdateFriendNickname(ctx context.Context, friendAddress string, nickname string) (bool, *Friend, error) {
	in := struct {
		Arg0 string `json:"friendAddress"`
		Arg1 string `json:"nickname"`
	}{friendAddress, nickname}
	out := struct {
		Ret0 bool    `json:"status"`
		Ret1 *Friend `json:"friend"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[12], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) RemoveFriend(ctx context.Context, friendAddress string) (bool, error) {
	in := struct {
		Arg0 string `json:"friendAddress"`
	}{friendAddress}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[13], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) ContractCall(ctx context.Context, chainID string, contract string, inputExpr string, outputExpr string, args []string) ([]string, error) {
	in := struct {
		Arg0 string   `json:"chainID"`
		Arg1 string   `json:"contract"`
		Arg2 string   `json:"inputExpr"`
		Arg3 string   `json:"outputExpr"`
		Arg4 []string `json:"args"`
	}{chainID, contract, inputExpr, outputExpr, args}
	out := struct {
		Ret0 []string `json:"returns"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[14], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) DecodeContractCall(ctx context.Context, callData string) (*ContractCall, error) {
	in := struct {
		Arg0 string `json:"callData"`
	}{callData}
	out := struct {
		Ret0 *ContractCall `json:"call"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[15], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) LookupContractCallSelectors(ctx context.Context, selectors []string) ([][]string, error) {
	in := struct {
		Arg0 []string `json:"selectors"`
	}{selectors}
	out := struct {
		Ret0 [][]string `json:"signatures"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[16], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) UserStorageFetch(ctx context.Context, key string) (interface{}, error) {
	in := struct {
		Arg0 string `json:"key"`
	}{key}
	out := struct {
		Ret0 interface{} `json:"object"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[17], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) UserStorageSave(ctx context.Context, key string, object interface{}) (bool, error) {
	in := struct {
		Arg0 string      `json:"key"`
		Arg1 interface{} `json:"object"`
	}{key, object}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[18], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) UserStorageDelete(ctx context.Context, key string) (bool, error) {
	in := struct {
		Arg0 string `json:"key"`
	}{key}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[19], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) UserStorageFetchAll(ctx context.Context, keys []string) (map[string]interface{}, error) {
	in := struct {
		Arg0 []string `json:"keys"`
	}{keys}
	out := struct {
		Ret0 map[string]interface{} `json:"objects"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[20], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetMoonpayLink(ctx context.Context, url string) (string, error) {
	in := struct {
		Arg0 string `json:"url"`
	}{url}
	out := struct {
		Ret0 string `json:"signedUrl"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[21], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSardineClientToken(ctx context.Context) (string, error) {
	out := struct {
		Ret0 string `json:"token"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[22], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSardineNFTCheckoutToken(ctx context.Context, params *NftCheckoutParams) (*NftCheckout, error) {
	in := struct {
		Arg0 *NftCheckoutParams `json:"params"`
	}{params}
	out := struct {
		Ret0 *NftCheckout `json:"resp"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[23], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSardineNFTCheckoutOrderStatus(ctx context.Context, orderId string) (*SardineOrder, error) {
	in := struct {
		Arg0 string `json:"orderId"`
	}{orderId}
	out := struct {
		Ret0 *SardineOrder `json:"resp"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[24], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) ResolveENSAddress(ctx context.Context, ens string) (string, bool, error) {
	in := struct {
		Arg0 string `json:"ens"`
	}{ens}
	out := struct {
		Ret0 string `json:"address"`
		Ret1 bool   `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[25], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) IsValidSignature(ctx context.Context, chainId string, walletAddress string, digest string, signature string) (bool, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"walletAddress"`
		Arg2 string `json:"digest"`
		Arg3 string `json:"signature"`
	}{chainId, walletAddress, digest, signature}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[26], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) IsValidMessageSignature(ctx context.Context, chainId string, walletAddress string, message string, signature string) (bool, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"walletAddress"`
		Arg2 string `json:"message"`
		Arg3 string `json:"signature"`
	}{chainId, walletAddress, message, signature}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[27], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) IsValidTypedDataSignature(ctx context.Context, chainId string, walletAddress string, typedData interface{}, signature string) (bool, error) {
	in := struct {
		Arg0 string      `json:"chainId"`
		Arg1 string      `json:"walletAddress"`
		Arg2 interface{} `json:"typedData"`
		Arg3 string      `json:"signature"`
	}{chainId, walletAddress, typedData, signature}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[28], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) IsValidETHAuthProof(ctx context.Context, chainId string, walletAddress string, ethAuthProofString string) (bool, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"walletAddress"`
		Arg2 string `json:"ethAuthProofString"`
	}{chainId, walletAddress, ethAuthProofString}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[29], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetCoinPrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error) {
	in := struct {
		Arg0 []*Token `json:"tokens"`
	}{tokens}
	out := struct {
		Ret0 []*TokenPrice `json:"tokenPrices"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[30], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetCollectiblePrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error) {
	in := struct {
		Arg0 []*Token `json:"tokens"`
	}{tokens}
	out := struct {
		Ret0 []*TokenPrice `json:"tokenPrices"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[31], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetExchangeRate(ctx context.Context, toCurrency string) (*ExchangeRate, error) {
	in := struct {
		Arg0 string `json:"toCurrency"`
	}{toCurrency}
	out := struct {
		Ret0 *ExchangeRate `json:"exchangeRate"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[32], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) MemoryStore(ctx context.Context, key string, value string) (bool, error) {
	in := struct {
		Arg0 string `json:"key"`
		Arg1 string `json:"value"`
	}{key, value}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[33], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) MemoryLoad(ctx context.Context, key string) (string, error) {
	in := struct {
		Arg0 string `json:"key"`
	}{key}
	out := struct {
		Ret0 string `json:"value"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[34], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetInviteInfo(ctx context.Context) (*InviteInfo, error) {
	out := struct {
		Ret0 *InviteInfo `json:"inviteInfo"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[35], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) IsValidAccessCode(ctx context.Context, accessCode string) (bool, error) {
	in := struct {
		Arg0 string `json:"accessCode"`
	}{accessCode}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[36], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) InternalClaimAccessCode(ctx context.Context, address string, accessCode string) (bool, error) {
	in := struct {
		Arg0 string `json:"address"`
		Arg1 string `json:"accessCode"`
	}{address, accessCode}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[37], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) BlockNumberAtTime(ctx context.Context, chainId uint64, timestamps []uint64) ([]uint64, error) {
	in := struct {
		Arg0 uint64   `json:"chainId"`
		Arg1 []uint64 `json:"timestamps"`
	}{chainId, timestamps}
	out := struct {
		Ret0 []uint64 `json:"blocks"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[38], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) PaperSessionSecret(ctx context.Context, chainName string, contractAddress string, paramsJson string, contractType string) (string, error) {
	in := struct {
		Arg0 string `json:"chainName"`
		Arg1 string `json:"contractAddress"`
		Arg2 string `json:"paramsJson"`
		Arg3 string `json:"contractType"`
	}{chainName, contractAddress, paramsJson, contractType}
	out := struct {
		Ret0 string `json:"secret"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[39], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) PaperSessionSecret2(ctx context.Context, chainName string, contractAddress string, paramsJson string, abi string) (string, error) {
	in := struct {
		Arg0 string `json:"chainName"`
		Arg1 string `json:"contractAddress"`
		Arg2 string `json:"paramsJson"`
		Arg3 string `json:"abi"`
	}{chainName, contractAddress, paramsJson, abi}
	out := struct {
		Ret0 string `json:"secret"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[40], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) LinkWallet(ctx context.Context, chainId string, walletAddress string, ethAuthProofString string, linkedWalletMessage string, linkedWalletSignature string) (bool, string, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"walletAddress"`
		Arg2 string `json:"ethAuthProofString"`
		Arg3 string `json:"linkedWalletMessage"`
		Arg4 string `json:"linkedWalletSignature"`
	}{chainId, walletAddress, ethAuthProofString, linkedWalletMessage, linkedWalletSignature}
	out := struct {
		Ret0 bool   `json:"status"`
		Ret1 string `json:"linkedWalletAddress"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[41], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) GetLinkedWallets(ctx context.Context, walletAddress string) ([]string, error) {
	in := struct {
		Arg0 string `json:"walletAddress"`
	}{walletAddress}
	out := struct {
		Ret0 []string `json:"linkedWallets"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[42], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// urlBase helps ensure that addr specifies a scheme. If it is unparsable
// as a URL, it returns addr unchanged.
func urlBase(addr string) string {
	// If the addr specifies a scheme, use it. If not, default to
	// http. If url.Parse fails on it, return it unchanged.
	url, err := url.Parse(addr)
	if err != nil {
		return addr
	}
	if url.Scheme == "" {
		url.Scheme = "http"
	}
	return url.String()
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) {
	req, err := http.NewRequestWithContext(ctx, "POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", contentType)
	req.Header.Set("Content-Type", contentType)
	if headers, ok := HTTPRequestHeaders(ctx); ok {
		for k := range headers {
			for _, v := range headers[k] {
				req.Header.Add(k, v)
			}
		}
	}
	return req, nil
}

// doHTTPRequest is common code to make a request to the remote service.
func doHTTPRequest(ctx context.Context, client HTTPClient, url string, in, out interface{}) (*http.Response, error) {
	reqBody, err := json.Marshal(in)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to marshal JSON body: %w", err))
	}
	if err = ctx.Err(); err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(fmt.Errorf("aborted because context was done: %w", err))
	}

	req, err := newRequest(ctx, url, bytes.NewBuffer(reqBody), "application/json")
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(fmt.Errorf("could not build request: %w", err))
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(err)
	}

	if resp.StatusCode != 200 {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to read server error response body: %w", err))
		}

		var rpcErr WebRPCError
		if err := json.Unmarshal(respBody, &rpcErr); err != nil {
			return nil, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to unmarshal server error: %w", err))
		}
		if rpcErr.Cause != "" {
			rpcErr.cause = errors.New(rpcErr.Cause)
		}
		return nil, rpcErr
	}

	if out != nil {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to read response body: %w", err))
		}

		err = json.Unmarshal(respBody, &out)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to unmarshal JSON response body: %w", err))
		}
	}

	return resp, nil
}

func WithHTTPRequestHeaders(ctx context.Context, h http.Header) (context.Context, error) {
	if _, ok := h["Accept"]; ok {
		return nil, errors.New("provided header cannot set Accept")
	}
	if _, ok := h["Content-Type"]; ok {
		return nil, errors.New("provided header cannot set Content-Type")
	}

	copied := make(http.Header, len(h))
	for k, vv := range h {
		if vv == nil {
			copied[k] = nil
			continue
		}
		copied[k] = make([]string, len(vv))
		copy(copied[k], vv)
	}

	return context.WithValue(ctx, HTTPClientRequestHeadersCtxKey, copied), nil
}

func HTTPRequestHeaders(ctx context.Context) (http.Header, bool) {
	h, ok := ctx.Value(HTTPClientRequestHeadersCtxKey).(http.Header)
	return h, ok
}

//
// Helpers
//

type contextKey struct {
	name string
}

func (k *contextKey) String() string {
	return "webrpc context value " + k.name
}

var (
	HTTPClientRequestHeadersCtxKey = &contextKey{"HTTPClientRequestHeaders"}
	HTTPRequestCtxKey              = &contextKey{"HTTPRequest"}

	ServiceNameCtxKey = &contextKey{"ServiceName"}

	MethodNameCtxKey = &contextKey{"MethodName"}
)

func ServiceNameFromContext(ctx context.Context) string {
	service, _ := ctx.Value(ServiceNameCtxKey).(string)
	return service
}

func MethodNameFromContext(ctx context.Context) string {
	method, _ := ctx.Value(MethodNameCtxKey).(string)
	return method
}

func RequestFromContext(ctx context.Context) *http.Request {
	r, _ := ctx.Value(HTTPRequestCtxKey).(*http.Request)
	return r
}

//
// Errors
//

type WebRPCError struct {
	Name       string `json:"error"`
	Code       int    `json:"code"`
	Message    string `json:"msg"`
	Cause      string `json:"cause,omitempty"`
	HTTPStatus int    `json:"status"`
	cause      error
}

var _ error = WebRPCError{}

func (e WebRPCError) Error() string {
	if e.cause != nil {
		return fmt.Sprintf("%s %d: %s: %v", e.Name, e.Code, e.Message, e.cause)
	}
	return fmt.Sprintf("%s %d: %s", e.Name, e.Code, e.Message)
}

func (e WebRPCError) Is(target error) bool {
	if target == nil {
		return false
	}
	if rpcErr, ok := target.(WebRPCError); ok {
		return rpcErr.Code == e.Code
	}
	return errors.Is(e.cause, target)
}

func (e WebRPCError) Unwrap() error {
	return e.cause
}

func (e WebRPCError) WithCause(cause error) WebRPCError {
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

func (e WebRPCError) WithCausef(format string, args ...interface{}) WebRPCError {
	cause := fmt.Errorf(format, args...)
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

// Deprecated: Use .WithCause() method on WebRPCError.
func ErrorWithCause(rpcErr WebRPCError, cause error) WebRPCError {
	return rpcErr.WithCause(cause)
}

// Webrpc errors
var (
	ErrWebrpcEndpoint           = WebRPCError{Code: 0, Name: "WebrpcEndpoint", Message: "endpoint error", HTTPStatus: 400}
	ErrWebrpcRequestFailed      = WebRPCError{Code: -1, Name: "WebrpcRequestFailed", Message: "request failed", HTTPStatus: 400}
	ErrWebrpcBadRoute           = WebRPCError{Code: -2, Name: "WebrpcBadRoute", Message: "bad route", HTTPStatus: 404}
	ErrWebrpcBadMethod          = WebRPCError{Code: -3, Name: "WebrpcBadMethod", Message: "bad method", HTTPStatus: 405}
	ErrWebrpcBadRequest         = WebRPCError{Code: -4, Name: "WebrpcBadRequest", Message: "bad request", HTTPStatus: 400}
	ErrWebrpcBadResponse        = WebRPCError{Code: -5, Name: "WebrpcBadResponse", Message: "bad response", HTTPStatus: 500}
	ErrWebrpcServerPanic        = WebRPCError{Code: -6, Name: "WebrpcServerPanic", Message: "server panic", HTTPStatus: 500}
	ErrWebrpcInternalError      = WebRPCError{Code: -7, Name: "WebrpcInternalError", Message: "internal error", HTTPStatus: 500}
	ErrWebrpcClientDisconnected = WebRPCError{Code: -8, Name: "WebrpcClientDisconnected", Message: "client disconnected", HTTPStatus: 400}
	ErrWebrpcStreamLost         = WebRPCError{Code: -9, Name: "WebrpcStreamLost", Message: "stream lost", HTTPStatus: 400}
	ErrWebrpcStreamFinished     = WebRPCError{Code: -10, Name: "WebrpcStreamFinished", Message: "stream finished", HTTPStatus: 200}
)

// Schema errors
var (
	ErrUnauthorized     = WebRPCError{Code: 1000, Name: "Unauthorized", Message: "Unauthorized access", HTTPStatus: 401}
	ErrPermissionDenied = WebRPCError{Code: 1001, Name: "PermissionDenied", Message: "Permission denied", HTTPStatus: 403}
	ErrSessionExpired   = WebRPCError{Code: 1002, Name: "SessionExpired", Message: "Session expired", HTTPStatus: 403}
	ErrAborted          = WebRPCError{Code: 1005, Name: "Aborted", Message: "Request aborted", HTTPStatus: 400}
	ErrInvalidArgument  = WebRPCError{Code: 2000, Name: "InvalidArgument", Message: "Invalid argument", HTTPStatus: 400}
	ErrUnavailable      = WebRPCError{Code: 2002, Name: "Unavailable", Message: "Unavailable resource", HTTPStatus: 400}
	ErrQueryFailed      = WebRPCError{Code: 2003, Name: "QueryFailed", Message: "Query failed", HTTPStatus: 400}
	ErrNotFound         = WebRPCError{Code: 3000, Name: "NotFound", Message: "Resource not found", HTTPStatus: 400}
)
