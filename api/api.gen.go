// sequence-api v0.4.0 d0c7f1ab893283e358baff52cecf6a8cbabd641f
// --
// Code generated by webrpc-gen@v0.22.0 with golang generator. DO NOT EDIT.
//
// webrpc-gen -schema=api.ridl -target=golang -pkg=api -client -out=./clients/api.gen.go
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/0xsequence/go-sequence/lib/prototyp"
)

const WebrpcHeader = "Webrpc"

const WebrpcHeaderValue = "webrpc@v0.22.0;gen-golang@v0.17.0;sequence-api@v0.4.0"

// WebRPC description and code-gen version
func WebRPCVersion() string {
	return "v1"
}

// Schema version of your RIDL schema
func WebRPCSchemaVersion() string {
	return "v0.4.0"
}

// Schema hash generated from your RIDL schema
func WebRPCSchemaHash() string {
	return "d0c7f1ab893283e358baff52cecf6a8cbabd641f"
}

type WebrpcGenVersions struct {
	WebrpcGenVersion string
	CodeGenName      string
	CodeGenVersion   string
	SchemaName       string
	SchemaVersion    string
}

func VersionFromHeader(h http.Header) (*WebrpcGenVersions, error) {
	if h.Get(WebrpcHeader) == "" {
		return nil, fmt.Errorf("header is empty or missing")
	}

	versions, err := parseWebrpcGenVersions(h.Get(WebrpcHeader))
	if err != nil {
		return nil, fmt.Errorf("webrpc header is invalid: %w", err)
	}

	return versions, nil
}

func parseWebrpcGenVersions(header string) (*WebrpcGenVersions, error) {
	versions := strings.Split(header, ";")
	if len(versions) < 3 {
		return nil, fmt.Errorf("expected at least 3 parts while parsing webrpc header: %v", header)
	}

	_, webrpcGenVersion, ok := strings.Cut(versions[0], "@")
	if !ok {
		return nil, fmt.Errorf("webrpc gen version could not be parsed from: %s", versions[0])
	}

	tmplTarget, tmplVersion, ok := strings.Cut(versions[1], "@")
	if !ok {
		return nil, fmt.Errorf("tmplTarget and tmplVersion could not be parsed from: %s", versions[1])
	}

	schemaName, schemaVersion, ok := strings.Cut(versions[2], "@")
	if !ok {
		return nil, fmt.Errorf("schema name and schema version could not be parsed from: %s", versions[2])
	}

	return &WebrpcGenVersions{
		WebrpcGenVersion: webrpcGenVersion,
		CodeGenName:      tmplTarget,
		CodeGenVersion:   tmplVersion,
		SchemaName:       schemaName,
		SchemaVersion:    schemaVersion,
	}, nil
}

//
// Common types
//

type SortOrder uint32

const (
	SortOrder_DESC SortOrder = 0
	SortOrder_ASC  SortOrder = 1
)

var SortOrder_name = map[uint32]string{
	0: "DESC",
	1: "ASC",
}

var SortOrder_value = map[string]uint32{
	"DESC": 0,
	"ASC":  1,
}

func (x SortOrder) String() string {
	return SortOrder_name[uint32(x)]
}

func (x SortOrder) MarshalText() ([]byte, error) {
	return []byte(SortOrder_name[uint32(x)]), nil
}

func (x *SortOrder) UnmarshalText(b []byte) error {
	*x = SortOrder(SortOrder_value[string(b)])
	return nil
}

func (x *SortOrder) Is(values ...SortOrder) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type SardinePaymentType uint32

const (
	SardinePaymentType_ach                  SardinePaymentType = 0
	SardinePaymentType_debit                SardinePaymentType = 1
	SardinePaymentType_credit               SardinePaymentType = 2
	SardinePaymentType_us_debit             SardinePaymentType = 3
	SardinePaymentType_international_debit  SardinePaymentType = 4
	SardinePaymentType_international_credit SardinePaymentType = 5
)

var SardinePaymentType_name = map[uint32]string{
	0: "ach",
	1: "debit",
	2: "credit",
	3: "us_debit",
	4: "international_debit",
	5: "international_credit",
}

var SardinePaymentType_value = map[string]uint32{
	"ach":                  0,
	"debit":                1,
	"credit":               2,
	"us_debit":             3,
	"international_debit":  4,
	"international_credit": 5,
}

func (x SardinePaymentType) String() string {
	return SardinePaymentType_name[uint32(x)]
}

func (x SardinePaymentType) MarshalText() ([]byte, error) {
	return []byte(SardinePaymentType_name[uint32(x)]), nil
}

func (x *SardinePaymentType) UnmarshalText(b []byte) error {
	*x = SardinePaymentType(SardinePaymentType_value[string(b)])
	return nil
}

func (x *SardinePaymentType) Is(values ...SardinePaymentType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type SardineQuoteType uint32

const (
	SardineQuoteType_buy  SardineQuoteType = 0
	SardineQuoteType_sell SardineQuoteType = 1
)

var SardineQuoteType_name = map[uint32]string{
	0: "buy",
	1: "sell",
}

var SardineQuoteType_value = map[string]uint32{
	"buy":  0,
	"sell": 1,
}

func (x SardineQuoteType) String() string {
	return SardineQuoteType_name[uint32(x)]
}

func (x SardineQuoteType) MarshalText() ([]byte, error) {
	return []byte(SardineQuoteType_name[uint32(x)]), nil
}

func (x *SardineQuoteType) UnmarshalText(b []byte) error {
	*x = SardineQuoteType(SardineQuoteType_value[string(b)])
	return nil
}

func (x *SardineQuoteType) Is(values ...SardineQuoteType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TokenType uint8

const (
	TokenType_ERC20   TokenType = 0
	TokenType_ERC721  TokenType = 1
	TokenType_ERC1155 TokenType = 2
)

var TokenType_name = map[uint8]string{
	0: "ERC20",
	1: "ERC721",
	2: "ERC1155",
}

var TokenType_value = map[string]uint8{
	"ERC20":   0,
	"ERC721":  1,
	"ERC1155": 2,
}

func (x TokenType) String() string {
	return TokenType_name[uint8(x)]
}

func (x TokenType) MarshalText() ([]byte, error) {
	return []byte(TokenType_name[uint8(x)]), nil
}

func (x *TokenType) UnmarshalText(b []byte) error {
	*x = TokenType(TokenType_value[string(b)])
	return nil
}

func (x *TokenType) Is(values ...TokenType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type Version struct {
	WebrpcVersion string `json:"webrpcVersion"`
	SchemaVersion string `json:"schemaVersion"`
	SchemaHash    string `json:"schemaHash"`
	AppVersion    string `json:"appVersion"`
}

type RuntimeStatus struct {
	// overall status, true/false
	HealthOK       bool                       `json:"healthOK"`
	StartTime      time.Time                  `json:"startTime"`
	Uptime         uint64                     `json:"uptime"`
	Ver            string                     `json:"ver"`
	Branch         string                     `json:"branch"`
	CommitHash     string                     `json:"commitHash"`
	Checks         *RuntimeChecks             `json:"checks"`
	NumTxnsRelayed map[string]*NumTxnsRelayed `json:"numTxnsRelayed"`
}

type NumTxnsRelayed struct {
	ChainID uint64 `json:"chainID"`
	Prev    uint64 `json:"prev"`
	Current uint64 `json:"current"`
	Period  uint64 `json:"period"`
}

type RuntimeChecks struct {
}

type SequenceContext struct {
	Factory              string `json:"factory"`
	MainModule           string `json:"mainModule"`
	MainModuleUpgradable string `json:"mainModuleUpgradable"`
	GuestModule          string `json:"guestModule"`
	Utils                string `json:"utils"`
}

type PublicKey struct {
	ID string `json:"id" db:"id"`
	X  string `json:"x" db:"x"`
	Y  string `json:"y" db:"y"`
}

// Users
type User struct {
	Address            prototyp.Hash `json:"address" db:"address"`
	Username           string        `json:"username" db:"username"`
	NormalizedUsername string        `json:"-" db:"normalized_username"`
	Avatar             string        `json:"avatar" db:"avatar"`
	Bio                string        `json:"bio" db:"bio"`
	Location           string        `json:"location" db:"location"`
	Locale             string        `json:"locale" db:"locale"`
	Backup             *bool         `json:"backup,omitempty" db:"-"`
	BackupConfirmed    *bool         `json:"backupConfirmed,omitempty" db:"-"`
	MaxInvites         *uint32       `json:"maxInvites" db:"max_invites"`
	UpdatedAt          *time.Time    `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt          *time.Time    `json:"createdAt,omitempty" db:"created_at,omitempty"`
	SysAdmin           bool          `json:"-" db:"sys_admin"`
}

// Wallet Backup
type WalletBackup struct {
	AccountAddress  prototyp.Hash `json:"accountAddress" db:"account_address"`
	SecretHash      string        `json:"secretHash" db:"secret_hash"`
	EncryptedWallet string        `json:"encryptedWallet" db:"encrypted_wallet"`
	// userConfirmed is a flag that the user tells us they've backed up
	// their wallet mnemonic for future recovery. It's just a user-experience field
	// so we can nag them if they haven't confirmed yet.
	UserConfirmed bool       `json:"userConfirmed" db:"user_confirmed"`
	UpdatedAt     *time.Time `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt     *time.Time `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// Friends
type Friend struct {
	ID            uint64        `json:"id" db:"id,omitempty"`
	UserAddress   prototyp.Hash `json:"userAddress" db:"user_address"`
	FriendAddress prototyp.Hash `json:"friendAddress" db:"friend_address"`
	// Nickname allows the user to assign a friend a label, useful for the case
	// when that friend doesn't have an arcadeum user account
	Nickname  string     `json:"nickname" db:"nickname"`
	User      *User      `json:"user" db:"-"`
	CreatedAt *time.Time `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// InviteCode
type InviteCode struct {
	Code         string             `json:"-" db:"code"`
	Source       string             `json:"-" db:"source"`
	UsesLeft     uint32             `json:"usesLeft" db:"uses_left"`
	OwnerAccount prototyp.HashMaybe `json:"ownerAccount" db:"owner_account"`
	Email        *string            `json:"email" db:"email"`
	Url          string             `json:"url"`
	CreatedAt    *time.Time         `json:"createdAt,omitempty" db:"created_at,omitempty"`
	ExpiresAt    *time.Time         `json:"expiresAt,omitempty" db:"expires_at,omitempty"`
}

// InviteCode Account
type InviteCodeAccount struct {
	Code                 string        `json:"-" db:"code"`
	ClaimedByUserAddress prototyp.Hash `json:"claimedByUserAddress" db:"claimed_by_user_address"`
	ClaimedAt            *time.Time    `json:"claimedAt,omitempty" db:"claimed_at,omitempty"`
}

// Invite info
type InviteInfo struct {
	ExpiryInHours uint32        `json:"expiryInHours"`
	Max           uint32        `json:"max"`
	Invites       []*InviteCode `json:"invites"`
}

type ContractCall struct {
	Signature string            `json:"signature"`
	Function  string            `json:"function"`
	Args      []*TupleComponent `json:"args"`
}

type TupleComponent struct {
	Name  *string     `json:"name"`
	Type  string      `json:"type"`
	Value interface{} `json:"value"`
}

type IntentPrecondition struct {
	Type    string          `json:"type"`
	ChainID prototyp.BigInt `json:"chainId"`
	Data    interface{}     `json:"data"`
}

type IntentSolution struct {
	Transactions []*Transactions `json:"transactions"`
}

type Transactions struct {
	ChainID       prototyp.BigInt       `json:"chainId"`
	Transactions  []*Transaction        `json:"transactions"`
	Preconditions []*IntentPrecondition `json:"preconditions,omitempty"`
}

type Transaction struct {
	DelegateCall  bool            `json:"delegateCall"`
	RevertOnError bool            `json:"revertOnError"`
	GasLimit      prototyp.BigInt `json:"gasLimit"`
	Target        prototyp.Hash   `json:"target"`
	Value         prototyp.BigInt `json:"value"`
	Data          prototyp.Hash   `json:"data"`
}

type UserStorage struct {
	UserAddress prototyp.Hash       `json:"userAddress" db:"user_address"`
	Key         string              `json:"key"`
	Value       prototyp.JSONString `json:"value"`
}

type Token struct {
	ChainId         uint64        `json:"chainId"`
	ContractAddress prototyp.Hash `json:"contractAddress"`
	TokenId         *string       `json:"tokenId"`
}

type Price struct {
	Value    float64 `json:"value"`
	Currency string  `json:"currency"`
}

type TokenPrice struct {
	Token          *Token     `json:"token"`
	Price          *Price     `json:"price"`
	Price24hChange *Price     `json:"price24hChange"`
	FloorPrice     *Price     `json:"floorPrice,omitempty"`
	BuyPrice       *Price     `json:"buyPrice,omitempty"`
	SellPrice      *Price     `json:"sellPrice,omitempty"`
	UpdatedAt      *time.Time `json:"updatedAt"`
}

type ExchangeRate struct {
	Name         string  `json:"name"`
	Symbol       string  `json:"symbol"`
	Value        float64 `json:"value"`
	VsCurrency   string  `json:"vsCurrency"`
	CurrencyType string  `json:"currencyType"`
}

type LinkedWallet struct {
	ID                  uint64        `json:"id" db:"id,omitempty"`
	WalletType          *string       `json:"walletType" db:"wallet_type"`
	WalletAddress       prototyp.Hash `json:"walletAddress" db:"wallet_address"`
	LinkedWalletAddress prototyp.Hash `json:"linkedWalletAddress" db:"linked_wallet_address"`
	CreatedAt           *time.Time    `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// TOOD: refactor, we should be returning a cursor always..
// see indexer/indexer.ridl Page object..
//
// ---
//
// Page represents a results page. This can be used both to request a page and
// to store the state of a page.
type Page struct {
	// Common for both numbered pages and cursor: Number of items per page
	// TODO: REMOVE..
	PageSize *uint32 `json:"pageSize"`
	// Numbered pages: Page number, this is multiplied by the value of the <pageSize> parameter.
	// TODO: REMOVE..
	Page *uint32 `json:"page"`
	// Number of total items on this query.
	// TODO: REMOVE..
	TotalRecords *uint64 `json:"totalRecords"`
	// Cursor: column to compare before/after to
	Column *string `json:"column"`
	// Cursor: return column < before - include to get previous page
	Before *interface{} `json:"before"`
	// Cursor: return column > after - include to get next page
	After *interface{} `json:"after"`
	// Sorting filter
	Sort []*SortBy `json:"sort"`
	// Indicates if there are more results available
	More *bool `json:"more,omitempty"`
}

type SortBy struct {
	Column string    `json:"column"`
	Order  SortOrder `json:"order"`
}

type SardineNFTCheckoutParams struct {
	Name                   string  `json:"name"`
	ImageURL               string  `json:"imageUrl"`
	Network                string  `json:"network"`
	RecipientAddress       string  `json:"recipientAddress"`
	BlockchainNFTID        string  `json:"blockchainNftId"`
	ContractAddress        string  `json:"contractAddress"`
	Quantity               int     `json:"quantity"`
	Decimals               *int    `json:"decimals"`
	TokenAmount            string  `json:"tokenAmount"`
	TokenAddress           string  `json:"tokenAddress"`
	TokenSymbol            string  `json:"tokenSymbol"`
	TokenDecimals          *int    `json:"tokenDecimals"`
	Calldata               string  `json:"calldata"`
	Platform               string  `json:"platform"`
	ApprovedSpenderAddress *string `json:"approvedSpenderAddress"`
}

type SardineNFTCheckout struct {
	Token     string `json:"token"`
	ExpiresAt string `json:"expiresAt"`
	OrderID   string `json:"orderId"`
}

type SardineOrder struct {
	ID                  string     `json:"id"`
	CreatedAt           *time.Time `json:"createdAt"`
	ReferenceID         string     `json:"referenceId"`
	Status              string     `json:"status"`
	FiatCurrency        string     `json:"fiatCurrency"`
	FiatExchangeRateUSD float64    `json:"fiatExchangeRateUSD"`
	TransactionID       string     `json:"transactionId"`
	ExpiresAt           *time.Time `json:"expiresAt"`
	Total               float64    `json:"total"`
	SubTotal            float64    `json:"subTotal"`
	TransactionFee      float64    `json:"transactionFee"`
	NetworkFee          float64    `json:"networkFee"`
	PaymentCurrency     *string    `json:"paymentCurrency"`
	PaymentMethodType   *string    `json:"paymentMethodType"`
	TransactionType     string     `json:"transactionType"`
	Name                string     `json:"name"`
	Price               int        `json:"price"`
	ImageURL            string     `json:"imageUrl"`
	ContractAddress     *string    `json:"contractAddress"`
	TransactionHash     *string    `json:"transactionHash"`
	RecipientAddress    string     `json:"recipientAddress"`
}

type SardineRegion struct {
	CountryCode        string                        `json:"countryCode"`
	IsAllowedOnRamp    bool                          `json:"isAllowedOnRamp"`
	IsAllowedOnNFT     bool                          `json:"isAllowedOnNFT"`
	IsBasicKycRequired []string                      `json:"isBasicKycRequired"`
	IsSsnRequired      []string                      `json:"isSsnRequired"`
	Name               string                        `json:"name"`
	CurrencyCode       string                        `json:"currencyCode"`
	IsPayrollSupported bool                          `json:"isPayrollSupported"`
	SupportedDocuments []string                      `json:"supportedDocuments"`
	PaymentMethods     []*SardineRegionPaymentMethod `json:"paymentMethods"`
	States             []*SardineRegionState         `json:"states"`
}

type SardineRegionPaymentMethod struct {
	Name            string   `json:"name"`
	IsAllowedOnRamp bool     `json:"isAllowedOnRamp"`
	IsAllowedOnNFT  bool     `json:"isAllowedOnNFT"`
	SubTypes        []string `json:"subTypes"`
	Type            string   `json:"type"`
	SubType         string   `json:"subType"`
}

type SardineRegionState struct {
	Code            string `json:"code"`
	Name            string `json:"name"`
	IsAllowedOnRamp bool   `json:"isAllowedOnRamp"`
	IsAllowedOnNFT  bool   `json:"isAllowedOnNFT"`
}

type SardineSupportedToken struct {
	Network      string `json:"network,omitempty"`
	AssetSymbol  string `json:"assetSymbol,omitempty"`
	AssetName    string `json:"assetName,omitempty"`
	ChainID      string `json:"chainId,omitempty"`
	TokenName    string `json:"tokenName,omitempty"`
	Token        string `json:"token,omitempty"`
	TokenAddress string `json:"tokenAddress,omitempty"`
}

type SardineSupportedTokenForSwap struct {
	IsSupported               bool   `json:"isSupported"`
	IsSupportedForAbstraction bool   `json:"isSupportedForAbstraction"`
	CurrentBalance            string `json:"currentBalance"`
}

type SardineEnabledToken struct {
	Network      string `json:"network,omitempty"`
	AssetSymbol  string `json:"assetSymbol,omitempty"`
	AssetName    string `json:"assetName,omitempty"`
	ChainID      string `json:"chainId,omitempty"`
	TokenName    string `json:"tokenName,omitempty"`
	Token        string `json:"token,omitempty"`
	TokenAddress string `json:"tokenAddress,omitempty"`
}

type SardineGetQuoteParams struct {
	// Cryptocurrency asset user wants to purchase
	AssetType string `json:"assetType"`
	// Blockchain on which the asset_type is present
	Network string `json:"network"`
	// Amount the user wants to buy or sell.
	Total uint64 `json:"total"`
	// The currency type in which the quote is supplied. Default 'USD'
	Currency *string `json:"currency"`
	// The payment method that the user will use for the transaction
	PaymentType *SardinePaymentType `json:"paymentType"`
	// Select for the required activity buy for on ramp and sell for off ramp. Default 'buy'
	QuoteType *SardineQuoteType `json:"quoteType"`
	// Wallet address of User. This is used to calculate if User has previously used Sardine, and provide them with a more accurate quote.
	WalletAddress *string `json:"walletAddress"`
}

type SardineQuote struct {
	Quantity            float64 `json:"quantity"`
	Network             string  `json:"network"`
	AssetType           string  `json:"assetType"`
	Total               float64 `json:"total"`
	Currency            string  `json:"currency"`
	ExpiresAt           string  `json:"expiresAt"`
	PaymentType         string  `json:"paymentType"`
	Price               float64 `json:"price"`
	Subtotal            float64 `json:"subtotal"`
	TransactionFee      float64 `json:"transactionFee"`
	NetworkFee          float64 `json:"networkFee"`
	HighNetworkFee      bool    `json:"highNetworkFee"`
	MinTransactionValue float64 `json:"minTransactionValue"`
	MaxTransactionValue float64 `json:"maxTransactionValue"`
	LiquidityProvider   string  `json:"liquidityProvider"`
}

type SardineFiatCurrency struct {
	CurrencyCode        string                  `json:"currencyCode"`
	Name                string                  `json:"name"`
	CurrencySymbol      string                  `json:"currencySymbol"`
	PaymentOptions      []*SardinePaymentOption `json:"paymentOptions"`
	SupportingCountries []string                `json:"supportingCountries"`
}

type SardinePaymentOption struct {
	Name           string   `json:"name"`
	DailyLimit     float64  `json:"dailyLimit"`
	WeeklyLimit    float64  `json:"weeklyLimit"`
	MonthlyLimit   float64  `json:"monthlyLimit"`
	MaxAmount      float64  `json:"maxAmount"`
	MinAmount      float64  `json:"minAmount"`
	SubTypes       []string `json:"subTypes"`
	Type           string   `json:"type"`
	SubType        string   `json:"subType"`
	ProcessingTime string   `json:"processingTime"`
}

type SwapPermit2Price struct {
	CurrencyAddress string          `json:"currencyAddress"`
	CurrencyBalance prototyp.BigInt `json:"currencyBalance"`
	Price           prototyp.BigInt `json:"price"`
	// Guaranteed price for the swap (incl slippage).
	MaxPrice         prototyp.BigInt `json:"maxPrice"`
	TransactionValue prototyp.BigInt `json:"transactionValue"`
}

type SwapPermit2Quote struct {
	CurrencyAddress string          `json:"currencyAddress"`
	CurrencyBalance prototyp.BigInt `json:"currencyBalance"`
	Price           prototyp.BigInt `json:"price"`
	// Guaranteed price for the swap (incl slippage).
	MaxPrice prototyp.BigInt `json:"maxPrice"`
	// to must be approved to access maxPrice of currencyAddress for the sender
	To               string          `json:"to"`
	TransactionData  string          `json:"transactionData"`
	TransactionValue prototyp.BigInt `json:"transactionValue"`
	// Supplied when includeApprove is true
	ApproveData string `json:"approveData"`
}

type SwapPrice struct {
	CurrencyAddress string          `json:"currencyAddress"`
	CurrencyBalance prototyp.BigInt `json:"currencyBalance"`
	Price           prototyp.BigInt `json:"price"`
	// Guaranteed price for the swap (incl slippage).
	MaxPrice         prototyp.BigInt `json:"maxPrice"`
	TransactionValue prototyp.BigInt `json:"transactionValue"`
}

type SwapQuote struct {
	CurrencyAddress string          `json:"currencyAddress"`
	CurrencyBalance prototyp.BigInt `json:"currencyBalance"`
	Price           prototyp.BigInt `json:"price"`
	// Guaranteed price for the swap (incl slippage).
	MaxPrice prototyp.BigInt `json:"maxPrice"`
	// to must be approved to access maxPrice of currencyAddress for the sender
	To               string          `json:"to"`
	TransactionData  string          `json:"transactionData"`
	TransactionValue prototyp.BigInt `json:"transactionValue"`
	// Supplied when includeApprove is true
	ApproveData string `json:"approveData"`
}

// Cross chain matching tokens
type CurrencyGroup struct {
	Name   string                `json:"name" db:"name"`
	Tokens []*CurrencyGroupToken `json:"tokens"`
}

type CurrencyGroupToken struct {
	ChainID      uint64        `json:"chainId" db:"chain_id"`
	TokenAddress prototyp.Hash `json:"tokenAddress" db:"token_address"`
}

type OffchainInventory struct {
	ID                  uint64        `json:"id" db:"id,omitempty"`
	ProjectID           uint64        `json:"projectId" db:"project_id"`
	ChainID             uint64        `json:"chainId" db:"chain_id"`
	ExternalProductID   string        `json:"externalProductId" db:"external_product_id"`
	PaymentTokenAddress prototyp.Hash `json:"paymentTokenAddress" db:"payment_token_address"`
	PaymentTokenType    TokenType     `json:"paymentTokenType" db:"payment_token_type"`
	PaymentTokenID      uint64        `json:"paymentTokenId" db:"payment_token_id"`
	PaymentAmount       uint64        `json:"paymentAmount" db:"payment_amount"`
	PaymentRecipient    prototyp.Hash `json:"paymentRecipient" db:"payment_recipient"`
	ChainedCallAddress  prototyp.Hash `json:"chainedCallAddress" db:"chained_call_address"`
	// product recipient address is added as the first argument (after selector)
	ChainedCallData         *string    `json:"chainedCallData" db:"chained_call_data"`
	AllowCrossChainPayments *bool      `json:"allowCrossChainPayments" db:"allow_cross_chain_payments"`
	CallbackURL             *string    `json:"callbackURL" db:"callback_url,omitempty"`
	CreatedAt               *time.Time `json:"createdAt" db:"created_at,omitempty"`
	DeletedAt               *time.Time `json:"-" db:"deleted_at,omitempty"`
}

type OffchainPayment struct {
	ID                  uint64        `json:"id" db:"id,omitempty"`
	OffchainInventoryID uint64        `json:"offchainInventoryId" db:"offchain_inventory_id"`
	ProductRecipient    prototyp.Hash `json:"productRecipient" db:"product_recipient"`
	PaymentChainID      uint64        `json:"paymentChainId" db:"payment_chain_id"`
	PaymentTokenAddress prototyp.Hash `json:"paymentTokenAddress" db:"payment_token_address"`
	Expiration          *time.Time    `json:"expiration" db:"expiration"`
	CreatedAt           *time.Time    `json:"createdAt" db:"created_at"`
	CompletedAt         *time.Time    `json:"completedAt" db:"completed_at"`
	ProcessedAt         *time.Time    `json:"processedAt" db:"processed_at"`
}

type PaymentResponse struct {
	PaymentID           uint64        `json:"paymentId"`
	OffchainInventoryID uint64        `json:"offchainInventoryId"`
	ChainID             uint64        `json:"chainId"`
	ExternalProductID   string        `json:"externalProductId"`
	PaymentTokenAddress prototyp.Hash `json:"paymentTokenAddress"`
	PaymentTokenType    TokenType     `json:"paymentTokenType"`
	PaymentTokenID      uint64        `json:"paymentTokenId"`
	PaymentTotal        uint64        `json:"paymentTotal"`
	Expiration          *time.Time    `json:"expiration"`
	Signature           string        `json:"signature"`
	TxTo                prototyp.Hash `json:"txTo"`
	TxData              string        `json:"txData"`
}

type AdoptedChildWallet struct {
	Address string `json:"address"`
}

type Lootbox struct {
	ChainID         uint64            `json:"chainId" db:"chain_id"`
	ProjectID       uint64            `json:"projectId,omitempty" db:"project_id"`
	ContractAddress prototyp.Hash     `json:"contractAddress" db:"contract_address"`
	ContentBytes    []byte            `json:"-,omitempty" db:"content"`
	Content         []*LootboxContent `json:"content"`
	CreatedAt       *time.Time        `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

type LootboxContent struct {
	TokenAddresses []string   `json:"tokenAddresses"`
	TokenIds       [][]string `json:"tokenIds"`
	Amounts        [][]string `json:"amounts"`
}

var methods = map[string]method{
	"/rpc/API/Ping": {
		Name:        "Ping",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/Version": {
		Name:        "Version",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/RuntimeStatus": {
		Name:        "RuntimeStatus",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/Clock": {
		Name:        "Clock",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/GetSequenceContext": {
		Name:        "GetSequenceContext",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/GetAuthToken": {
		Name:        "GetAuthToken",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/GetAuthToken2": {
		Name:        "GetAuthToken2",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/SendPasswordlessLink": {
		Name:        "SendPasswordlessLink",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/RegisterPublicKey": {
		Name:        "RegisterPublicKey",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/GetPublicKey": {
		Name:        "GetPublicKey",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/FriendList": {
		Name:        "FriendList",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/GetFriendByAddress": {
		Name:        "GetFriendByAddress",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/SearchFriends": {
		Name:        "SearchFriends",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/AddFriend": {
		Name:        "AddFriend",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/UpdateFriendNickname": {
		Name:        "UpdateFriendNickname",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/RemoveFriend": {
		Name:        "RemoveFriend",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/ContractCall": {
		Name:        "ContractCall",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/DecodeContractCall": {
		Name:        "DecodeContractCall",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/LookupContractCallSelectors": {
		Name:        "LookupContractCallSelectors",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/UserStorageFetch": {
		Name:        "UserStorageFetch",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/UserStorageSave": {
		Name:        "UserStorageSave",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/UserStorageDelete": {
		Name:        "UserStorageDelete",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/UserStorageFetchAll": {
		Name:        "UserStorageFetchAll",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/GetMoonpayLink": {
		Name:        "GetMoonpayLink",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/ResolveENSAddress": {
		Name:        "ResolveENSAddress",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/IsValidSignature": {
		Name:        "IsValidSignature",
		Service:     "API",
		Annotations: map[string]string{"public": ""},
	},
	"/rpc/API/IsValidMessageSignature": {
		Name:        "IsValidMessageSignature",
		Service:     "API",
		Annotations: map[string]string{"public": ""},
	},
	"/rpc/API/IsValidTypedDataSignature": {
		Name:        "IsValidTypedDataSignature",
		Service:     "API",
		Annotations: map[string]string{"public": ""},
	},
	"/rpc/API/IsValidETHAuthProof": {
		Name:        "IsValidETHAuthProof",
		Service:     "API",
		Annotations: map[string]string{"public": ""},
	},
	"/rpc/API/SardineGetClientToken": {
		Name:        "SardineGetClientToken",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/SardineGetNFTCheckoutToken": {
		Name:        "SardineGetNFTCheckoutToken",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/SardineGetNFTCheckoutOrderStatus": {
		Name:        "SardineGetNFTCheckoutOrderStatus",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/SardineGetSupportedRegions": {
		Name:        "SardineGetSupportedRegions",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/SardineGetSupportedFiatCurrencies": {
		Name:        "SardineGetSupportedFiatCurrencies",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/SardineGetSupportedTokens": {
		Name:        "SardineGetSupportedTokens",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/SardineGetSupportedTokenForSwap": {
		Name:        "SardineGetSupportedTokenForSwap",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/SardineGetEnabledTokens": {
		Name:        "SardineGetEnabledTokens",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/SardineGetQuote": {
		Name:        "SardineGetQuote",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/GetSardineClientToken": {
		Name:        "GetSardineClientToken",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/GetSardineNFTCheckoutToken": {
		Name:        "GetSardineNFTCheckoutToken",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/GetSardineNFTCheckoutOrderStatus": {
		Name:        "GetSardineNFTCheckoutOrderStatus",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/GetCoinPrices": {
		Name:        "GetCoinPrices",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/GetCollectiblePrices": {
		Name:        "GetCollectiblePrices",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/GetExchangeRate": {
		Name:        "GetExchangeRate",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/MemoryStore": {
		Name:        "MemoryStore",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/MemoryLoad": {
		Name:        "MemoryLoad",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/GetInviteInfo": {
		Name:        "GetInviteInfo",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/IsValidAccessCode": {
		Name:        "IsValidAccessCode",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/InternalClaimAccessCode": {
		Name:        "InternalClaimAccessCode",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/BlockNumberAtTime": {
		Name:        "BlockNumberAtTime",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/PaperSessionSecret": {
		Name:        "PaperSessionSecret",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/PaperSessionSecret2": {
		Name:        "PaperSessionSecret2",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/LinkWallet": {
		Name:        "LinkWallet",
		Service:     "API",
		Annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GetLinkedWallets": {
		Name:        "GetLinkedWallets",
		Service:     "API",
		Annotations: map[string]string{"public": ""},
	},
	"/rpc/API/RemoveLinkedWallet": {
		Name:        "RemoveLinkedWallet",
		Service:     "API",
		Annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GenerateWaaSVerificationURL": {
		Name:        "GenerateWaaSVerificationURL",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/ValidateWaaSVerificationNonce": {
		Name:        "ValidateWaaSVerificationNonce",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/ListAdoptedWallets": {
		Name:        "ListAdoptedWallets",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/GetSwapPermit2Price": {
		Name:        "GetSwapPermit2Price",
		Service:     "API",
		Annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GetSwapPermit2Prices": {
		Name:        "GetSwapPermit2Prices",
		Service:     "API",
		Annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GetSwapPermit2Quote": {
		Name:        "GetSwapPermit2Quote",
		Service:     "API",
		Annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GetSwapPrice": {
		Name:        "GetSwapPrice",
		Service:     "API",
		Annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GetSwapPrices": {
		Name:        "GetSwapPrices",
		Service:     "API",
		Annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GetSwapQuote": {
		Name:        "GetSwapQuote",
		Service:     "API",
		Annotations: map[string]string{"public": ""},
	},
	"/rpc/API/IntentQuery": {
		Name:        "IntentQuery",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/ListCurrencyGroups": {
		Name:        "ListCurrencyGroups",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/AddOffchainInventory": {
		Name:        "AddOffchainInventory",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/GetOffchainInventory": {
		Name:        "GetOffchainInventory",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/ListOffchainInventories": {
		Name:        "ListOffchainInventories",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/UpdateOffchainInventory": {
		Name:        "UpdateOffchainInventory",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/DeleteOffchainInventory": {
		Name:        "DeleteOffchainInventory",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/RequestOffchainPayment": {
		Name:        "RequestOffchainPayment",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/ListOffchainPayments": {
		Name:        "ListOffchainPayments",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/SaveLootbox": {
		Name:        "SaveLootbox",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/GetLootbox": {
		Name:        "GetLootbox",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/DeleteLootbox": {
		Name:        "DeleteLootbox",
		Service:     "API",
		Annotations: map[string]string{},
	},
	"/rpc/API/UpdateLootboxContent": {
		Name:        "UpdateLootboxContent",
		Service:     "API",
		Annotations: map[string]string{},
	},
}

func WebrpcMethods() map[string]method {
	res := make(map[string]method, len(methods))
	for k, v := range methods {
		res[k] = v
	}

	return res
}

var WebRPCServices = map[string][]string{
	"API": {
		"Ping",
		"Version",
		"RuntimeStatus",
		"Clock",
		"GetSequenceContext",
		"GetAuthToken",
		"GetAuthToken2",
		"SendPasswordlessLink",
		"RegisterPublicKey",
		"GetPublicKey",
		"FriendList",
		"GetFriendByAddress",
		"SearchFriends",
		"AddFriend",
		"UpdateFriendNickname",
		"RemoveFriend",
		"ContractCall",
		"DecodeContractCall",
		"LookupContractCallSelectors",
		"UserStorageFetch",
		"UserStorageSave",
		"UserStorageDelete",
		"UserStorageFetchAll",
		"GetMoonpayLink",
		"ResolveENSAddress",
		"IsValidSignature",
		"IsValidMessageSignature",
		"IsValidTypedDataSignature",
		"IsValidETHAuthProof",
		"SardineGetClientToken",
		"SardineGetNFTCheckoutToken",
		"SardineGetNFTCheckoutOrderStatus",
		"SardineGetSupportedRegions",
		"SardineGetSupportedFiatCurrencies",
		"SardineGetSupportedTokens",
		"SardineGetSupportedTokenForSwap",
		"SardineGetEnabledTokens",
		"SardineGetQuote",
		"GetSardineClientToken",
		"GetSardineNFTCheckoutToken",
		"GetSardineNFTCheckoutOrderStatus",
		"GetCoinPrices",
		"GetCollectiblePrices",
		"GetExchangeRate",
		"MemoryStore",
		"MemoryLoad",
		"GetInviteInfo",
		"IsValidAccessCode",
		"InternalClaimAccessCode",
		"BlockNumberAtTime",
		"PaperSessionSecret",
		"PaperSessionSecret2",
		"LinkWallet",
		"GetLinkedWallets",
		"RemoveLinkedWallet",
		"GenerateWaaSVerificationURL",
		"ValidateWaaSVerificationNonce",
		"ListAdoptedWallets",
		"GetSwapPermit2Price",
		"GetSwapPermit2Prices",
		"GetSwapPermit2Quote",
		"GetSwapPrice",
		"GetSwapPrices",
		"GetSwapQuote",
		"IntentQuery",
		"ListCurrencyGroups",
		"AddOffchainInventory",
		"GetOffchainInventory",
		"ListOffchainInventories",
		"UpdateOffchainInventory",
		"DeleteOffchainInventory",
		"RequestOffchainPayment",
		"ListOffchainPayments",
		"SaveLootbox",
		"GetLootbox",
		"DeleteLootbox",
		"UpdateLootboxContent",
	},
}

//
// Server types
//

type API interface {
	//
	// Runtime
	//
	Ping(ctx context.Context) (bool, error)
	Version(ctx context.Context) (*Version, error)
	RuntimeStatus(ctx context.Context) (*RuntimeStatus, error)
	Clock(ctx context.Context) (time.Time, error)
	GetSequenceContext(ctx context.Context) (*SequenceContext, error)
	//
	// Auth
	//
	// TODO: rename 'ewtString' arg to 'ethauthProof'
	GetAuthToken(ctx context.Context, ewtString string, testnetMode *bool) (bool, string, string, *User, error)
	GetAuthToken2(ctx context.Context, ewtString string, chainID string) (bool, string, string, *User, error)
	SendPasswordlessLink(ctx context.Context, email string, redirectUri string, intent string) (bool, error)
	RegisterPublicKey(ctx context.Context, publicKey *PublicKey) (bool, error)
	GetPublicKey(ctx context.Context, id string) (*PublicKey, error)
	//
	// Contacts / Friends
	//
	FriendList(ctx context.Context, nickname *string, page *Page) (*Page, []*Friend, error)
	GetFriendByAddress(ctx context.Context, friendAddress string) (bool, *Friend, error)
	SearchFriends(ctx context.Context, filterUsername string, page *Page) ([]*Friend, error)
	AddFriend(ctx context.Context, friendAddress string, optionalNickname *string) (bool, *Friend, error)
	UpdateFriendNickname(ctx context.Context, friendAddress string, nickname string) (bool, *Friend, error)
	RemoveFriend(ctx context.Context, friendAddress string) (bool, error)
	//
	// Chain-Utils
	//
	ContractCall(ctx context.Context, chainID string, contract string, inputExpr string, outputExpr string, args []string) ([]string, error)
	DecodeContractCall(ctx context.Context, callData string) (*ContractCall, error)
	LookupContractCallSelectors(ctx context.Context, selectors []string) ([][]string, error)
	//
	// User Storage
	//
	UserStorageFetch(ctx context.Context, key string) (interface{}, error)
	UserStorageSave(ctx context.Context, key string, object interface{}) (bool, error)
	UserStorageDelete(ctx context.Context, key string) (bool, error)
	UserStorageFetchAll(ctx context.Context, keys []string) (map[string]interface{}, error)
	//
	// Wallet utils
	//
	GetMoonpayLink(ctx context.Context, url string) (string, error)
	// - IsUsingGoogleMail(domain: string) => (yes: bool)
	ResolveENSAddress(ctx context.Context, ens string) (string, bool, error)
	// TODO: we can add walletContext optional in the future when we need it
	// NOTE: chainId can be either a number or canonical name
	IsValidSignature(ctx context.Context, chainId string, walletAddress string, digest string, signature string) (bool, error)
	IsValidMessageSignature(ctx context.Context, chainId string, walletAddress string, message string, signature string) (bool, error)
	IsValidTypedDataSignature(ctx context.Context, chainId string, walletAddress string, typedData interface{}, signature string) (bool, error)
	IsValidETHAuthProof(ctx context.Context, chainId string, walletAddress string, ethAuthProofString string) (bool, error)
	SardineGetClientToken(ctx context.Context) (string, error)
	SardineGetNFTCheckoutToken(ctx context.Context, params *SardineNFTCheckoutParams) (*SardineNFTCheckout, error)
	SardineGetNFTCheckoutOrderStatus(ctx context.Context, orderId string) (*SardineOrder, error)
	SardineGetSupportedRegions(ctx context.Context) ([]*SardineRegion, error)
	SardineGetSupportedFiatCurrencies(ctx context.Context) ([]*SardineFiatCurrency, error)
	SardineGetSupportedTokens(ctx context.Context) ([]*SardineSupportedToken, error)
	SardineGetSupportedTokenForSwap(ctx context.Context, network string, tokenAddress string) (*SardineSupportedTokenForSwap, error)
	SardineGetEnabledTokens(ctx context.Context) ([]*SardineEnabledToken, error)
	SardineGetQuote(ctx context.Context, params *SardineGetQuoteParams) (*SardineQuote, error)
	// Deprecated. Use SardineGetClientToken() instead.
	GetSardineClientToken(ctx context.Context) (string, error)
	// Deprecated. Use SardineGetNFTCheckoutToken() instead.
	GetSardineNFTCheckoutToken(ctx context.Context, params *SardineNFTCheckoutParams) (*SardineNFTCheckout, error)
	// Deprecated. Use SardineGetNFTCheckoutOrderStatus() instead.
	GetSardineNFTCheckoutOrderStatus(ctx context.Context, orderId string) (*SardineOrder, error)
	//
	// Price Feed
	//
	GetCoinPrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
	GetCollectiblePrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
	//
	// Price Feed utils
	//
	GetExchangeRate(ctx context.Context, toCurrency string) (*ExchangeRate, error)
	//
	// Util / misc
	//
	MemoryStore(ctx context.Context, key string, value string) (bool, error)
	MemoryLoad(ctx context.Context, key string) (string, error)
	//
	// Legacy
	//
	GetInviteInfo(ctx context.Context) (*InviteInfo, error)
	// NOTE: we're still using this from SW-API to Sequence-API to claim invite code
	IsValidAccessCode(ctx context.Context, accessCode string) (bool, error)
	InternalClaimAccessCode(ctx context.Context, address string, accessCode string) (bool, error)
	// Utils
	BlockNumberAtTime(ctx context.Context, chainId uint64, timestamps []uint64) ([]uint64, error)
	//
	// Paper
	// TODO: deprecate in the future
	//
	PaperSessionSecret(ctx context.Context, chainName string, contractAddress string, paramsJson string, contractType string) (string, error)
	PaperSessionSecret2(ctx context.Context, chainName string, contractAddress string, paramsJson string, abi string) (string, error)
	//
	// Linked wallets (v0 -- simple support)
	//
	LinkWallet(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, linkedWalletAddress string, linkedWalletMessage string, linkedWalletSignature string, signatureChainId string, linkedWalletType *string) (bool, error)
	GetLinkedWallets(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, signatureChainId string) ([]*LinkedWallet, error)
	RemoveLinkedWallet(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, linkedWalletAddress string, signatureChainId string) (bool, error)
	// NOTE: these methods are deprecated, please do not use them. We may resurface them in the future, but just wanted
	// to be clear, they are not necessary for our linked wallets.
	GenerateWaaSVerificationURL(ctx context.Context, walletAddress string) (string, string, error)
	ValidateWaaSVerificationNonce(ctx context.Context, nonce string, signature string, sessionId string, chainId string) (string, error)
	//
	//
	// WaaS child wallet adoption
	//
	ListAdoptedWallets(ctx context.Context, page *Page) (*Page, []*AdoptedChildWallet, error)
	//
	// Currency abstraction
	//
	GetSwapPermit2Price(ctx context.Context, buyCurrencyAddress string, sellCurrencyAddress string, buyAmount string, chainId uint64, slippagePercentage *uint64) (*SwapPermit2Price, error)
	GetSwapPermit2Prices(ctx context.Context, userAddress string, buyCurrencyAddress string, buyAmount string, chainId uint64, slippagePercentage *uint64) ([]*SwapPermit2Price, error)
	GetSwapPermit2Quote(ctx context.Context, userAddress string, buyCurrencyAddress string, sellCurrencyAddress string, buyAmount string, chainId uint64, includeApprove bool, slippagePercentage *uint64) (*SwapPermit2Quote, error)
	GetSwapPrice(ctx context.Context, buyCurrencyAddress string, sellCurrencyAddress string, buyAmount string, chainId uint64, slippagePercentage *uint64) (*SwapPrice, error)
	GetSwapPrices(ctx context.Context, userAddress string, buyCurrencyAddress string, buyAmount string, chainId uint64, slippagePercentage *uint64) ([]*SwapPrice, error)
	GetSwapQuote(ctx context.Context, userAddress string, buyCurrencyAddress string, sellCurrencyAddress string, buyAmount string, chainId uint64, includeApprove bool, slippagePercentage *uint64) (*SwapQuote, error)
	//
	// Chain abstraction
	//
	IntentQuery(ctx context.Context, wallet string, preconditions []*IntentPrecondition) ([]*IntentSolution, error)
	//
	// Inventory, payments and management
	//
	ListCurrencyGroups(ctx context.Context) ([]*CurrencyGroup, error)
	AddOffchainInventory(ctx context.Context, inventory *OffchainInventory) (uint64, error)
	GetOffchainInventory(ctx context.Context, inventoryId uint64) (*OffchainInventory, error)
	ListOffchainInventories(ctx context.Context, projectId uint64) ([]*OffchainInventory, error)
	UpdateOffchainInventory(ctx context.Context, inventory *OffchainInventory) error
	DeleteOffchainInventory(ctx context.Context, inventoryId uint64) (bool, error)
	RequestOffchainPayment(ctx context.Context, inventoryId uint64, recipient string, chainId *uint64, tokenAddress *string) (*PaymentResponse, error)
	ListOffchainPayments(ctx context.Context, inventoryId uint64, page *Page) (*Page, []*OffchainPayment, error)
	SaveLootbox(ctx context.Context, lootbox *Lootbox) (string, error)
	GetLootbox(ctx context.Context, contractAddress string, chainId uint64) (*Lootbox, error)
	DeleteLootbox(ctx context.Context, contractAddress string, chainId uint64) (bool, error)
	UpdateLootboxContent(ctx context.Context, lootbox *Lootbox) (string, error)
}

//
// Client types
//

type APIClient interface {
	//
	// Runtime
	//
	Ping(ctx context.Context) (bool, error)
	Version(ctx context.Context) (*Version, error)
	RuntimeStatus(ctx context.Context) (*RuntimeStatus, error)
	Clock(ctx context.Context) (time.Time, error)
	GetSequenceContext(ctx context.Context) (*SequenceContext, error)
	//
	// Auth
	//
	// TODO: rename 'ewtString' arg to 'ethauthProof'
	GetAuthToken(ctx context.Context, ewtString string, testnetMode *bool) (bool, string, string, *User, error)
	GetAuthToken2(ctx context.Context, ewtString string, chainID string) (bool, string, string, *User, error)
	SendPasswordlessLink(ctx context.Context, email string, redirectUri string, intent string) (bool, error)
	RegisterPublicKey(ctx context.Context, publicKey *PublicKey) (bool, error)
	GetPublicKey(ctx context.Context, id string) (*PublicKey, error)
	//
	// Contacts / Friends
	//
	FriendList(ctx context.Context, nickname *string, page *Page) (*Page, []*Friend, error)
	GetFriendByAddress(ctx context.Context, friendAddress string) (bool, *Friend, error)
	SearchFriends(ctx context.Context, filterUsername string, page *Page) ([]*Friend, error)
	AddFriend(ctx context.Context, friendAddress string, optionalNickname *string) (bool, *Friend, error)
	UpdateFriendNickname(ctx context.Context, friendAddress string, nickname string) (bool, *Friend, error)
	RemoveFriend(ctx context.Context, friendAddress string) (bool, error)
	//
	// Chain-Utils
	//
	ContractCall(ctx context.Context, chainID string, contract string, inputExpr string, outputExpr string, args []string) ([]string, error)
	DecodeContractCall(ctx context.Context, callData string) (*ContractCall, error)
	LookupContractCallSelectors(ctx context.Context, selectors []string) ([][]string, error)
	//
	// User Storage
	//
	UserStorageFetch(ctx context.Context, key string) (interface{}, error)
	UserStorageSave(ctx context.Context, key string, object interface{}) (bool, error)
	UserStorageDelete(ctx context.Context, key string) (bool, error)
	UserStorageFetchAll(ctx context.Context, keys []string) (map[string]interface{}, error)
	//
	// Wallet utils
	//
	GetMoonpayLink(ctx context.Context, url string) (string, error)
	// - IsUsingGoogleMail(domain: string) => (yes: bool)
	ResolveENSAddress(ctx context.Context, ens string) (string, bool, error)
	// TODO: we can add walletContext optional in the future when we need it
	// NOTE: chainId can be either a number or canonical name
	IsValidSignature(ctx context.Context, chainId string, walletAddress string, digest string, signature string) (bool, error)
	IsValidMessageSignature(ctx context.Context, chainId string, walletAddress string, message string, signature string) (bool, error)
	IsValidTypedDataSignature(ctx context.Context, chainId string, walletAddress string, typedData interface{}, signature string) (bool, error)
	IsValidETHAuthProof(ctx context.Context, chainId string, walletAddress string, ethAuthProofString string) (bool, error)
	SardineGetClientToken(ctx context.Context) (string, error)
	SardineGetNFTCheckoutToken(ctx context.Context, params *SardineNFTCheckoutParams) (*SardineNFTCheckout, error)
	SardineGetNFTCheckoutOrderStatus(ctx context.Context, orderId string) (*SardineOrder, error)
	SardineGetSupportedRegions(ctx context.Context) ([]*SardineRegion, error)
	SardineGetSupportedFiatCurrencies(ctx context.Context) ([]*SardineFiatCurrency, error)
	SardineGetSupportedTokens(ctx context.Context) ([]*SardineSupportedToken, error)
	SardineGetSupportedTokenForSwap(ctx context.Context, network string, tokenAddress string) (*SardineSupportedTokenForSwap, error)
	SardineGetEnabledTokens(ctx context.Context) ([]*SardineEnabledToken, error)
	SardineGetQuote(ctx context.Context, params *SardineGetQuoteParams) (*SardineQuote, error)
	// Deprecated. Use SardineGetClientToken() instead.
	GetSardineClientToken(ctx context.Context) (string, error)
	// Deprecated. Use SardineGetNFTCheckoutToken() instead.
	GetSardineNFTCheckoutToken(ctx context.Context, params *SardineNFTCheckoutParams) (*SardineNFTCheckout, error)
	// Deprecated. Use SardineGetNFTCheckoutOrderStatus() instead.
	GetSardineNFTCheckoutOrderStatus(ctx context.Context, orderId string) (*SardineOrder, error)
	//
	// Price Feed
	//
	GetCoinPrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
	GetCollectiblePrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
	//
	// Price Feed utils
	//
	GetExchangeRate(ctx context.Context, toCurrency string) (*ExchangeRate, error)
	//
	// Util / misc
	//
	MemoryStore(ctx context.Context, key string, value string) (bool, error)
	MemoryLoad(ctx context.Context, key string) (string, error)
	//
	// Legacy
	//
	GetInviteInfo(ctx context.Context) (*InviteInfo, error)
	// NOTE: we're still using this from SW-API to Sequence-API to claim invite code
	IsValidAccessCode(ctx context.Context, accessCode string) (bool, error)
	InternalClaimAccessCode(ctx context.Context, address string, accessCode string) (bool, error)
	// Utils
	BlockNumberAtTime(ctx context.Context, chainId uint64, timestamps []uint64) ([]uint64, error)
	//
	// Paper
	// TODO: deprecate in the future
	//
	PaperSessionSecret(ctx context.Context, chainName string, contractAddress string, paramsJson string, contractType string) (string, error)
	PaperSessionSecret2(ctx context.Context, chainName string, contractAddress string, paramsJson string, abi string) (string, error)
	//
	// Linked wallets (v0 -- simple support)
	//
	LinkWallet(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, linkedWalletAddress string, linkedWalletMessage string, linkedWalletSignature string, signatureChainId string, linkedWalletType *string) (bool, error)
	GetLinkedWallets(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, signatureChainId string) ([]*LinkedWallet, error)
	RemoveLinkedWallet(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, linkedWalletAddress string, signatureChainId string) (bool, error)
	// NOTE: these methods are deprecated, please do not use them. We may resurface them in the future, but just wanted
	// to be clear, they are not necessary for our linked wallets.
	GenerateWaaSVerificationURL(ctx context.Context, walletAddress string) (string, string, error)
	ValidateWaaSVerificationNonce(ctx context.Context, nonce string, signature string, sessionId string, chainId string) (string, error)
	//
	//
	// WaaS child wallet adoption
	//
	ListAdoptedWallets(ctx context.Context, page *Page) (*Page, []*AdoptedChildWallet, error)
	//
	// Currency abstraction
	//
	GetSwapPermit2Price(ctx context.Context, buyCurrencyAddress string, sellCurrencyAddress string, buyAmount string, chainId uint64, slippagePercentage *uint64) (*SwapPermit2Price, error)
	GetSwapPermit2Prices(ctx context.Context, userAddress string, buyCurrencyAddress string, buyAmount string, chainId uint64, slippagePercentage *uint64) ([]*SwapPermit2Price, error)
	GetSwapPermit2Quote(ctx context.Context, userAddress string, buyCurrencyAddress string, sellCurrencyAddress string, buyAmount string, chainId uint64, includeApprove bool, slippagePercentage *uint64) (*SwapPermit2Quote, error)
	GetSwapPrice(ctx context.Context, buyCurrencyAddress string, sellCurrencyAddress string, buyAmount string, chainId uint64, slippagePercentage *uint64) (*SwapPrice, error)
	GetSwapPrices(ctx context.Context, userAddress string, buyCurrencyAddress string, buyAmount string, chainId uint64, slippagePercentage *uint64) ([]*SwapPrice, error)
	GetSwapQuote(ctx context.Context, userAddress string, buyCurrencyAddress string, sellCurrencyAddress string, buyAmount string, chainId uint64, includeApprove bool, slippagePercentage *uint64) (*SwapQuote, error)
	//
	// Chain abstraction
	//
	IntentQuery(ctx context.Context, wallet string, preconditions []*IntentPrecondition) ([]*IntentSolution, error)
	//
	// Inventory, payments and management
	//
	ListCurrencyGroups(ctx context.Context) ([]*CurrencyGroup, error)
	AddOffchainInventory(ctx context.Context, inventory *OffchainInventory) (uint64, error)
	GetOffchainInventory(ctx context.Context, inventoryId uint64) (*OffchainInventory, error)
	ListOffchainInventories(ctx context.Context, projectId uint64) ([]*OffchainInventory, error)
	UpdateOffchainInventory(ctx context.Context, inventory *OffchainInventory) error
	DeleteOffchainInventory(ctx context.Context, inventoryId uint64) (bool, error)
	RequestOffchainPayment(ctx context.Context, inventoryId uint64, recipient string, chainId *uint64, tokenAddress *string) (*PaymentResponse, error)
	ListOffchainPayments(ctx context.Context, inventoryId uint64, page *Page) (*Page, []*OffchainPayment, error)
	SaveLootbox(ctx context.Context, lootbox *Lootbox) (string, error)
	GetLootbox(ctx context.Context, contractAddress string, chainId uint64) (*Lootbox, error)
	DeleteLootbox(ctx context.Context, contractAddress string, chainId uint64) (bool, error)
	UpdateLootboxContent(ctx context.Context, lootbox *Lootbox) (string, error)
}

//
// Client
//

const APIPathPrefix = "/rpc/API/"

type aPIClient struct {
	client HTTPClient
	urls   [77]string
}

func NewAPIClient(addr string, client HTTPClient) APIClient {
	prefix := urlBase(addr) + APIPathPrefix
	urls := [77]string{
		prefix + "Ping",
		prefix + "Version",
		prefix + "RuntimeStatus",
		prefix + "Clock",
		prefix + "GetSequenceContext",
		prefix + "GetAuthToken",
		prefix + "GetAuthToken2",
		prefix + "SendPasswordlessLink",
		prefix + "RegisterPublicKey",
		prefix + "GetPublicKey",
		prefix + "FriendList",
		prefix + "GetFriendByAddress",
		prefix + "SearchFriends",
		prefix + "AddFriend",
		prefix + "UpdateFriendNickname",
		prefix + "RemoveFriend",
		prefix + "ContractCall",
		prefix + "DecodeContractCall",
		prefix + "LookupContractCallSelectors",
		prefix + "UserStorageFetch",
		prefix + "UserStorageSave",
		prefix + "UserStorageDelete",
		prefix + "UserStorageFetchAll",
		prefix + "GetMoonpayLink",
		prefix + "ResolveENSAddress",
		prefix + "IsValidSignature",
		prefix + "IsValidMessageSignature",
		prefix + "IsValidTypedDataSignature",
		prefix + "IsValidETHAuthProof",
		prefix + "SardineGetClientToken",
		prefix + "SardineGetNFTCheckoutToken",
		prefix + "SardineGetNFTCheckoutOrderStatus",
		prefix + "SardineGetSupportedRegions",
		prefix + "SardineGetSupportedFiatCurrencies",
		prefix + "SardineGetSupportedTokens",
		prefix + "SardineGetSupportedTokenForSwap",
		prefix + "SardineGetEnabledTokens",
		prefix + "SardineGetQuote",
		prefix + "GetSardineClientToken",
		prefix + "GetSardineNFTCheckoutToken",
		prefix + "GetSardineNFTCheckoutOrderStatus",
		prefix + "GetCoinPrices",
		prefix + "GetCollectiblePrices",
		prefix + "GetExchangeRate",
		prefix + "MemoryStore",
		prefix + "MemoryLoad",
		prefix + "GetInviteInfo",
		prefix + "IsValidAccessCode",
		prefix + "InternalClaimAccessCode",
		prefix + "BlockNumberAtTime",
		prefix + "PaperSessionSecret",
		prefix + "PaperSessionSecret2",
		prefix + "LinkWallet",
		prefix + "GetLinkedWallets",
		prefix + "RemoveLinkedWallet",
		prefix + "GenerateWaaSVerificationURL",
		prefix + "ValidateWaaSVerificationNonce",
		prefix + "ListAdoptedWallets",
		prefix + "GetSwapPermit2Price",
		prefix + "GetSwapPermit2Prices",
		prefix + "GetSwapPermit2Quote",
		prefix + "GetSwapPrice",
		prefix + "GetSwapPrices",
		prefix + "GetSwapQuote",
		prefix + "IntentQuery",
		prefix + "ListCurrencyGroups",
		prefix + "AddOffchainInventory",
		prefix + "GetOffchainInventory",
		prefix + "ListOffchainInventories",
		prefix + "UpdateOffchainInventory",
		prefix + "DeleteOffchainInventory",
		prefix + "RequestOffchainPayment",
		prefix + "ListOffchainPayments",
		prefix + "SaveLootbox",
		prefix + "GetLootbox",
		prefix + "DeleteLootbox",
		prefix + "UpdateLootboxContent",
	}
	return &aPIClient{
		client: client,
		urls:   urls,
	}
}

func (c *aPIClient) Ping(ctx context.Context) (bool, error) {
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) Version(ctx context.Context) (*Version, error) {
	out := struct {
		Ret0 *Version `json:"version"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) RuntimeStatus(ctx context.Context) (*RuntimeStatus, error) {
	out := struct {
		Ret0 *RuntimeStatus `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) Clock(ctx context.Context) (time.Time, error) {
	out := struct {
		Ret0 time.Time `json:"serverTime"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSequenceContext(ctx context.Context) (*SequenceContext, error) {
	out := struct {
		Ret0 *SequenceContext `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetAuthToken(ctx context.Context, ewtString string, testnetMode *bool) (bool, string, string, *User, error) {
	in := struct {
		Arg0 string `json:"ewtString"`
		Arg1 *bool  `json:"testnetMode"`
	}{ewtString, testnetMode}
	out := struct {
		Ret0 bool   `json:"status"`
		Ret1 string `json:"jwtToken"`
		Ret2 string `json:"address"`
		Ret3 *User  `json:"user"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[5], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, out.Ret2, out.Ret3, err
}

func (c *aPIClient) GetAuthToken2(ctx context.Context, ewtString string, chainID string) (bool, string, string, *User, error) {
	in := struct {
		Arg0 string `json:"ewtString"`
		Arg1 string `json:"chainID"`
	}{ewtString, chainID}
	out := struct {
		Ret0 bool   `json:"status"`
		Ret1 string `json:"jwtToken"`
		Ret2 string `json:"address"`
		Ret3 *User  `json:"user"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[6], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, out.Ret2, out.Ret3, err
}

func (c *aPIClient) SendPasswordlessLink(ctx context.Context, email string, redirectUri string, intent string) (bool, error) {
	in := struct {
		Arg0 string `json:"email"`
		Arg1 string `json:"redirectUri"`
		Arg2 string `json:"intent"`
	}{email, redirectUri, intent}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[7], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) RegisterPublicKey(ctx context.Context, publicKey *PublicKey) (bool, error) {
	in := struct {
		Arg0 *PublicKey `json:"publicKey"`
	}{publicKey}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[8], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetPublicKey(ctx context.Context, id string) (*PublicKey, error) {
	in := struct {
		Arg0 string `json:"id"`
	}{id}
	out := struct {
		Ret0 *PublicKey `json:"publicKey"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[9], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) FriendList(ctx context.Context, nickname *string, page *Page) (*Page, []*Friend, error) {
	in := struct {
		Arg0 *string `json:"nickname"`
		Arg1 *Page   `json:"page"`
	}{nickname, page}
	out := struct {
		Ret0 *Page     `json:"page"`
		Ret1 []*Friend `json:"friends"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[10], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) GetFriendByAddress(ctx context.Context, friendAddress string) (bool, *Friend, error) {
	in := struct {
		Arg0 string `json:"friendAddress"`
	}{friendAddress}
	out := struct {
		Ret0 bool    `json:"status"`
		Ret1 *Friend `json:"friend"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[11], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) SearchFriends(ctx context.Context, filterUsername string, page *Page) ([]*Friend, error) {
	in := struct {
		Arg0 string `json:"filterUsername"`
		Arg1 *Page  `json:"page"`
	}{filterUsername, page}
	out := struct {
		Ret0 []*Friend `json:"friends"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[12], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) AddFriend(ctx context.Context, friendAddress string, optionalNickname *string) (bool, *Friend, error) {
	in := struct {
		Arg0 string  `json:"friendAddress"`
		Arg1 *string `json:"optionalNickname"`
	}{friendAddress, optionalNickname}
	out := struct {
		Ret0 bool    `json:"status"`
		Ret1 *Friend `json:"friend"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[13], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) UpdateFriendNickname(ctx context.Context, friendAddress string, nickname string) (bool, *Friend, error) {
	in := struct {
		Arg0 string `json:"friendAddress"`
		Arg1 string `json:"nickname"`
	}{friendAddress, nickname}
	out := struct {
		Ret0 bool    `json:"status"`
		Ret1 *Friend `json:"friend"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[14], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) RemoveFriend(ctx context.Context, friendAddress string) (bool, error) {
	in := struct {
		Arg0 string `json:"friendAddress"`
	}{friendAddress}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[15], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) ContractCall(ctx context.Context, chainID string, contract string, inputExpr string, outputExpr string, args []string) ([]string, error) {
	in := struct {
		Arg0 string   `json:"chainID"`
		Arg1 string   `json:"contract"`
		Arg2 string   `json:"inputExpr"`
		Arg3 string   `json:"outputExpr"`
		Arg4 []string `json:"args"`
	}{chainID, contract, inputExpr, outputExpr, args}
	out := struct {
		Ret0 []string `json:"returns"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[16], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) DecodeContractCall(ctx context.Context, callData string) (*ContractCall, error) {
	in := struct {
		Arg0 string `json:"callData"`
	}{callData}
	out := struct {
		Ret0 *ContractCall `json:"call"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[17], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) LookupContractCallSelectors(ctx context.Context, selectors []string) ([][]string, error) {
	in := struct {
		Arg0 []string `json:"selectors"`
	}{selectors}
	out := struct {
		Ret0 [][]string `json:"signatures"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[18], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) UserStorageFetch(ctx context.Context, key string) (interface{}, error) {
	in := struct {
		Arg0 string `json:"key"`
	}{key}
	out := struct {
		Ret0 interface{} `json:"object"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[19], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) UserStorageSave(ctx context.Context, key string, object interface{}) (bool, error) {
	in := struct {
		Arg0 string      `json:"key"`
		Arg1 interface{} `json:"object"`
	}{key, object}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[20], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) UserStorageDelete(ctx context.Context, key string) (bool, error) {
	in := struct {
		Arg0 string `json:"key"`
	}{key}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[21], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) UserStorageFetchAll(ctx context.Context, keys []string) (map[string]interface{}, error) {
	in := struct {
		Arg0 []string `json:"keys"`
	}{keys}
	out := struct {
		Ret0 map[string]interface{} `json:"objects"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[22], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetMoonpayLink(ctx context.Context, url string) (string, error) {
	in := struct {
		Arg0 string `json:"url"`
	}{url}
	out := struct {
		Ret0 string `json:"signedUrl"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[23], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) ResolveENSAddress(ctx context.Context, ens string) (string, bool, error) {
	in := struct {
		Arg0 string `json:"ens"`
	}{ens}
	out := struct {
		Ret0 string `json:"address"`
		Ret1 bool   `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[24], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) IsValidSignature(ctx context.Context, chainId string, walletAddress string, digest string, signature string) (bool, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"walletAddress"`
		Arg2 string `json:"digest"`
		Arg3 string `json:"signature"`
	}{chainId, walletAddress, digest, signature}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[25], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) IsValidMessageSignature(ctx context.Context, chainId string, walletAddress string, message string, signature string) (bool, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"walletAddress"`
		Arg2 string `json:"message"`
		Arg3 string `json:"signature"`
	}{chainId, walletAddress, message, signature}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[26], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) IsValidTypedDataSignature(ctx context.Context, chainId string, walletAddress string, typedData interface{}, signature string) (bool, error) {
	in := struct {
		Arg0 string      `json:"chainId"`
		Arg1 string      `json:"walletAddress"`
		Arg2 interface{} `json:"typedData"`
		Arg3 string      `json:"signature"`
	}{chainId, walletAddress, typedData, signature}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[27], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) IsValidETHAuthProof(ctx context.Context, chainId string, walletAddress string, ethAuthProofString string) (bool, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"walletAddress"`
		Arg2 string `json:"ethAuthProofString"`
	}{chainId, walletAddress, ethAuthProofString}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[28], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetClientToken(ctx context.Context) (string, error) {
	out := struct {
		Ret0 string `json:"token"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[29], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetNFTCheckoutToken(ctx context.Context, params *SardineNFTCheckoutParams) (*SardineNFTCheckout, error) {
	in := struct {
		Arg0 *SardineNFTCheckoutParams `json:"params"`
	}{params}
	out := struct {
		Ret0 *SardineNFTCheckout `json:"resp"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[30], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetNFTCheckoutOrderStatus(ctx context.Context, orderId string) (*SardineOrder, error) {
	in := struct {
		Arg0 string `json:"orderId"`
	}{orderId}
	out := struct {
		Ret0 *SardineOrder `json:"resp"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[31], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetSupportedRegions(ctx context.Context) ([]*SardineRegion, error) {
	out := struct {
		Ret0 []*SardineRegion `json:"regions"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[32], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetSupportedFiatCurrencies(ctx context.Context) ([]*SardineFiatCurrency, error) {
	out := struct {
		Ret0 []*SardineFiatCurrency `json:"tokens"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[33], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetSupportedTokens(ctx context.Context) ([]*SardineSupportedToken, error) {
	out := struct {
		Ret0 []*SardineSupportedToken `json:"tokens"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[34], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetSupportedTokenForSwap(ctx context.Context, network string, tokenAddress string) (*SardineSupportedTokenForSwap, error) {
	in := struct {
		Arg0 string `json:"network"`
		Arg1 string `json:"tokenAddress"`
	}{network, tokenAddress}
	out := struct {
		Ret0 *SardineSupportedTokenForSwap `json:"token"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[35], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetEnabledTokens(ctx context.Context) ([]*SardineEnabledToken, error) {
	out := struct {
		Ret0 []*SardineEnabledToken `json:"tokens"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[36], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetQuote(ctx context.Context, params *SardineGetQuoteParams) (*SardineQuote, error) {
	in := struct {
		Arg0 *SardineGetQuoteParams `json:"params"`
	}{params}
	out := struct {
		Ret0 *SardineQuote `json:"quote"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[37], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSardineClientToken(ctx context.Context) (string, error) {
	out := struct {
		Ret0 string `json:"token"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[38], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSardineNFTCheckoutToken(ctx context.Context, params *SardineNFTCheckoutParams) (*SardineNFTCheckout, error) {
	in := struct {
		Arg0 *SardineNFTCheckoutParams `json:"params"`
	}{params}
	out := struct {
		Ret0 *SardineNFTCheckout `json:"resp"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[39], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSardineNFTCheckoutOrderStatus(ctx context.Context, orderId string) (*SardineOrder, error) {
	in := struct {
		Arg0 string `json:"orderId"`
	}{orderId}
	out := struct {
		Ret0 *SardineOrder `json:"resp"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[40], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetCoinPrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error) {
	in := struct {
		Arg0 []*Token `json:"tokens"`
	}{tokens}
	out := struct {
		Ret0 []*TokenPrice `json:"tokenPrices"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[41], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetCollectiblePrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error) {
	in := struct {
		Arg0 []*Token `json:"tokens"`
	}{tokens}
	out := struct {
		Ret0 []*TokenPrice `json:"tokenPrices"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[42], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetExchangeRate(ctx context.Context, toCurrency string) (*ExchangeRate, error) {
	in := struct {
		Arg0 string `json:"toCurrency"`
	}{toCurrency}
	out := struct {
		Ret0 *ExchangeRate `json:"exchangeRate"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[43], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) MemoryStore(ctx context.Context, key string, value string) (bool, error) {
	in := struct {
		Arg0 string `json:"key"`
		Arg1 string `json:"value"`
	}{key, value}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[44], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) MemoryLoad(ctx context.Context, key string) (string, error) {
	in := struct {
		Arg0 string `json:"key"`
	}{key}
	out := struct {
		Ret0 string `json:"value"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[45], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetInviteInfo(ctx context.Context) (*InviteInfo, error) {
	out := struct {
		Ret0 *InviteInfo `json:"inviteInfo"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[46], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) IsValidAccessCode(ctx context.Context, accessCode string) (bool, error) {
	in := struct {
		Arg0 string `json:"accessCode"`
	}{accessCode}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[47], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) InternalClaimAccessCode(ctx context.Context, address string, accessCode string) (bool, error) {
	in := struct {
		Arg0 string `json:"address"`
		Arg1 string `json:"accessCode"`
	}{address, accessCode}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[48], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) BlockNumberAtTime(ctx context.Context, chainId uint64, timestamps []uint64) ([]uint64, error) {
	in := struct {
		Arg0 uint64   `json:"chainId"`
		Arg1 []uint64 `json:"timestamps"`
	}{chainId, timestamps}
	out := struct {
		Ret0 []uint64 `json:"blocks"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[49], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) PaperSessionSecret(ctx context.Context, chainName string, contractAddress string, paramsJson string, contractType string) (string, error) {
	in := struct {
		Arg0 string `json:"chainName"`
		Arg1 string `json:"contractAddress"`
		Arg2 string `json:"paramsJson"`
		Arg3 string `json:"contractType"`
	}{chainName, contractAddress, paramsJson, contractType}
	out := struct {
		Ret0 string `json:"secret"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[50], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) PaperSessionSecret2(ctx context.Context, chainName string, contractAddress string, paramsJson string, abi string) (string, error) {
	in := struct {
		Arg0 string `json:"chainName"`
		Arg1 string `json:"contractAddress"`
		Arg2 string `json:"paramsJson"`
		Arg3 string `json:"abi"`
	}{chainName, contractAddress, paramsJson, abi}
	out := struct {
		Ret0 string `json:"secret"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[51], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) LinkWallet(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, linkedWalletAddress string, linkedWalletMessage string, linkedWalletSignature string, signatureChainId string, linkedWalletType *string) (bool, error) {
	in := struct {
		Arg0 string  `json:"parentWalletAddress"`
		Arg1 string  `json:"parentWalletMessage"`
		Arg2 string  `json:"parentWalletSignature"`
		Arg3 string  `json:"linkedWalletAddress"`
		Arg4 string  `json:"linkedWalletMessage"`
		Arg5 string  `json:"linkedWalletSignature"`
		Arg6 string  `json:"signatureChainId"`
		Arg7 *string `json:"linkedWalletType"`
	}{parentWalletAddress, parentWalletMessage, parentWalletSignature, linkedWalletAddress, linkedWalletMessage, linkedWalletSignature, signatureChainId, linkedWalletType}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[52], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetLinkedWallets(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, signatureChainId string) ([]*LinkedWallet, error) {
	in := struct {
		Arg0 string `json:"parentWalletAddress"`
		Arg1 string `json:"parentWalletMessage"`
		Arg2 string `json:"parentWalletSignature"`
		Arg3 string `json:"signatureChainId"`
	}{parentWalletAddress, parentWalletMessage, parentWalletSignature, signatureChainId}
	out := struct {
		Ret0 []*LinkedWallet `json:"linkedWallets"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[53], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) RemoveLinkedWallet(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, linkedWalletAddress string, signatureChainId string) (bool, error) {
	in := struct {
		Arg0 string `json:"parentWalletAddress"`
		Arg1 string `json:"parentWalletMessage"`
		Arg2 string `json:"parentWalletSignature"`
		Arg3 string `json:"linkedWalletAddress"`
		Arg4 string `json:"signatureChainId"`
	}{parentWalletAddress, parentWalletMessage, parentWalletSignature, linkedWalletAddress, signatureChainId}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[54], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GenerateWaaSVerificationURL(ctx context.Context, walletAddress string) (string, string, error) {
	in := struct {
		Arg0 string `json:"walletAddress"`
	}{walletAddress}
	out := struct {
		Ret0 string `json:"nonce"`
		Ret1 string `json:"verificationURL"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[55], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) ValidateWaaSVerificationNonce(ctx context.Context, nonce string, signature string, sessionId string, chainId string) (string, error) {
	in := struct {
		Arg0 string `json:"nonce"`
		Arg1 string `json:"signature"`
		Arg2 string `json:"sessionId"`
		Arg3 string `json:"chainId"`
	}{nonce, signature, sessionId, chainId}
	out := struct {
		Ret0 string `json:"walletAddress"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[56], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) ListAdoptedWallets(ctx context.Context, page *Page) (*Page, []*AdoptedChildWallet, error) {
	in := struct {
		Arg0 *Page `json:"page"`
	}{page}
	out := struct {
		Ret0 *Page                 `json:"page"`
		Ret1 []*AdoptedChildWallet `json:"wallets"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[57], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) GetSwapPermit2Price(ctx context.Context, buyCurrencyAddress string, sellCurrencyAddress string, buyAmount string, chainId uint64, slippagePercentage *uint64) (*SwapPermit2Price, error) {
	in := struct {
		Arg0 string  `json:"buyCurrencyAddress"`
		Arg1 string  `json:"sellCurrencyAddress"`
		Arg2 string  `json:"buyAmount"`
		Arg3 uint64  `json:"chainId"`
		Arg4 *uint64 `json:"slippagePercentage"`
	}{buyCurrencyAddress, sellCurrencyAddress, buyAmount, chainId, slippagePercentage}
	out := struct {
		Ret0 *SwapPermit2Price `json:"swapPermit2Price"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[58], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSwapPermit2Prices(ctx context.Context, userAddress string, buyCurrencyAddress string, buyAmount string, chainId uint64, slippagePercentage *uint64) ([]*SwapPermit2Price, error) {
	in := struct {
		Arg0 string  `json:"userAddress"`
		Arg1 string  `json:"buyCurrencyAddress"`
		Arg2 string  `json:"buyAmount"`
		Arg3 uint64  `json:"chainId"`
		Arg4 *uint64 `json:"slippagePercentage"`
	}{userAddress, buyCurrencyAddress, buyAmount, chainId, slippagePercentage}
	out := struct {
		Ret0 []*SwapPermit2Price `json:"swapPermit2Prices"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[59], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSwapPermit2Quote(ctx context.Context, userAddress string, buyCurrencyAddress string, sellCurrencyAddress string, buyAmount string, chainId uint64, includeApprove bool, slippagePercentage *uint64) (*SwapPermit2Quote, error) {
	in := struct {
		Arg0 string  `json:"userAddress"`
		Arg1 string  `json:"buyCurrencyAddress"`
		Arg2 string  `json:"sellCurrencyAddress"`
		Arg3 string  `json:"buyAmount"`
		Arg4 uint64  `json:"chainId"`
		Arg5 bool    `json:"includeApprove"`
		Arg6 *uint64 `json:"slippagePercentage"`
	}{userAddress, buyCurrencyAddress, sellCurrencyAddress, buyAmount, chainId, includeApprove, slippagePercentage}
	out := struct {
		Ret0 *SwapPermit2Quote `json:"swapPermit2Quote"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[60], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSwapPrice(ctx context.Context, buyCurrencyAddress string, sellCurrencyAddress string, buyAmount string, chainId uint64, slippagePercentage *uint64) (*SwapPrice, error) {
	in := struct {
		Arg0 string  `json:"buyCurrencyAddress"`
		Arg1 string  `json:"sellCurrencyAddress"`
		Arg2 string  `json:"buyAmount"`
		Arg3 uint64  `json:"chainId"`
		Arg4 *uint64 `json:"slippagePercentage"`
	}{buyCurrencyAddress, sellCurrencyAddress, buyAmount, chainId, slippagePercentage}
	out := struct {
		Ret0 *SwapPrice `json:"swapPrice"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[61], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSwapPrices(ctx context.Context, userAddress string, buyCurrencyAddress string, buyAmount string, chainId uint64, slippagePercentage *uint64) ([]*SwapPrice, error) {
	in := struct {
		Arg0 string  `json:"userAddress"`
		Arg1 string  `json:"buyCurrencyAddress"`
		Arg2 string  `json:"buyAmount"`
		Arg3 uint64  `json:"chainId"`
		Arg4 *uint64 `json:"slippagePercentage"`
	}{userAddress, buyCurrencyAddress, buyAmount, chainId, slippagePercentage}
	out := struct {
		Ret0 []*SwapPrice `json:"swapPrices"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[62], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSwapQuote(ctx context.Context, userAddress string, buyCurrencyAddress string, sellCurrencyAddress string, buyAmount string, chainId uint64, includeApprove bool, slippagePercentage *uint64) (*SwapQuote, error) {
	in := struct {
		Arg0 string  `json:"userAddress"`
		Arg1 string  `json:"buyCurrencyAddress"`
		Arg2 string  `json:"sellCurrencyAddress"`
		Arg3 string  `json:"buyAmount"`
		Arg4 uint64  `json:"chainId"`
		Arg5 bool    `json:"includeApprove"`
		Arg6 *uint64 `json:"slippagePercentage"`
	}{userAddress, buyCurrencyAddress, sellCurrencyAddress, buyAmount, chainId, includeApprove, slippagePercentage}
	out := struct {
		Ret0 *SwapQuote `json:"swapQuote"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[63], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) IntentQuery(ctx context.Context, wallet string, preconditions []*IntentPrecondition) ([]*IntentSolution, error) {
	in := struct {
		Arg0 string                `json:"wallet"`
		Arg1 []*IntentPrecondition `json:"preconditions"`
	}{wallet, preconditions}
	out := struct {
		Ret0 []*IntentSolution `json:"solutions"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[64], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) ListCurrencyGroups(ctx context.Context) ([]*CurrencyGroup, error) {
	out := struct {
		Ret0 []*CurrencyGroup `json:"currencyGroups"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[65], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) AddOffchainInventory(ctx context.Context, inventory *OffchainInventory) (uint64, error) {
	in := struct {
		Arg0 *OffchainInventory `json:"inventory"`
	}{inventory}
	out := struct {
		Ret0 uint64 `json:"inventoryId"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[66], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetOffchainInventory(ctx context.Context, inventoryId uint64) (*OffchainInventory, error) {
	in := struct {
		Arg0 uint64 `json:"inventoryId"`
	}{inventoryId}
	out := struct {
		Ret0 *OffchainInventory `json:"inventory"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[67], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) ListOffchainInventories(ctx context.Context, projectId uint64) ([]*OffchainInventory, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 []*OffchainInventory `json:"inventory"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[68], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) UpdateOffchainInventory(ctx context.Context, inventory *OffchainInventory) error {
	in := struct {
		Arg0 *OffchainInventory `json:"inventory"`
	}{inventory}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[69], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return err
}

func (c *aPIClient) DeleteOffchainInventory(ctx context.Context, inventoryId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"inventoryId"`
	}{inventoryId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[70], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) RequestOffchainPayment(ctx context.Context, inventoryId uint64, recipient string, chainId *uint64, tokenAddress *string) (*PaymentResponse, error) {
	in := struct {
		Arg0 uint64  `json:"inventoryId"`
		Arg1 string  `json:"recipient"`
		Arg2 *uint64 `json:"chainId"`
		Arg3 *string `json:"tokenAddress"`
	}{inventoryId, recipient, chainId, tokenAddress}
	out := struct {
		Ret0 *PaymentResponse `json:"payment"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[71], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) ListOffchainPayments(ctx context.Context, inventoryId uint64, page *Page) (*Page, []*OffchainPayment, error) {
	in := struct {
		Arg0 uint64 `json:"inventoryId"`
		Arg1 *Page  `json:"page"`
	}{inventoryId, page}
	out := struct {
		Ret0 *Page              `json:"page"`
		Ret1 []*OffchainPayment `json:"payments"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[72], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) SaveLootbox(ctx context.Context, lootbox *Lootbox) (string, error) {
	in := struct {
		Arg0 *Lootbox `json:"lootbox"`
	}{lootbox}
	out := struct {
		Ret0 string `json:"merkleRoot"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[73], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetLootbox(ctx context.Context, contractAddress string, chainId uint64) (*Lootbox, error) {
	in := struct {
		Arg0 string `json:"contractAddress"`
		Arg1 uint64 `json:"chainId"`
	}{contractAddress, chainId}
	out := struct {
		Ret0 *Lootbox `json:"lootbox"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[74], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) DeleteLootbox(ctx context.Context, contractAddress string, chainId uint64) (bool, error) {
	in := struct {
		Arg0 string `json:"contractAddress"`
		Arg1 uint64 `json:"chainId"`
	}{contractAddress, chainId}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[75], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) UpdateLootboxContent(ctx context.Context, lootbox *Lootbox) (string, error) {
	in := struct {
		Arg0 *Lootbox `json:"lootbox"`
	}{lootbox}
	out := struct {
		Ret0 string `json:"merkleRoot"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[76], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// urlBase helps ensure that addr specifies a scheme. If it is unparsable
// as a URL, it returns addr unchanged.
func urlBase(addr string) string {
	// If the addr specifies a scheme, use it. If not, default to
	// http. If url.Parse fails on it, return it unchanged.
	url, err := url.Parse(addr)
	if err != nil {
		return addr
	}
	if url.Scheme == "" {
		url.Scheme = "http"
	}
	return url.String()
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) {
	req, err := http.NewRequestWithContext(ctx, "POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", contentType)
	req.Header.Set("Content-Type", contentType)
	req.Header.Set(WebrpcHeader, WebrpcHeaderValue)
	if headers, ok := HTTPRequestHeaders(ctx); ok {
		for k := range headers {
			for _, v := range headers[k] {
				req.Header.Add(k, v)
			}
		}
	}
	return req, nil
}

// doHTTPRequest is common code to make a request to the remote service.
func doHTTPRequest(ctx context.Context, client HTTPClient, url string, in, out interface{}) (*http.Response, error) {
	reqBody, err := json.Marshal(in)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("failed to marshal JSON body: %w", err)
	}
	if err = ctx.Err(); err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("aborted because context was done: %w", err)
	}

	req, err := newRequest(ctx, url, bytes.NewBuffer(reqBody), "application/json")
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("could not build request: %w", err)
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(err)
	}

	if resp.StatusCode != 200 {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to read server error response body: %w", err)
		}

		var rpcErr WebRPCError
		if err := json.Unmarshal(respBody, &rpcErr); err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to unmarshal server error: %w", err)
		}
		if rpcErr.Cause != "" {
			rpcErr.cause = errors.New(rpcErr.Cause)
		}
		return nil, rpcErr
	}

	if out != nil {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to read response body: %w", err)
		}

		err = json.Unmarshal(respBody, &out)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to unmarshal JSON response body: %w", err)
		}
	}

	return resp, nil
}

func WithHTTPRequestHeaders(ctx context.Context, h http.Header) (context.Context, error) {
	if _, ok := h["Accept"]; ok {
		return nil, errors.New("provided header cannot set Accept")
	}
	if _, ok := h["Content-Type"]; ok {
		return nil, errors.New("provided header cannot set Content-Type")
	}

	copied := make(http.Header, len(h))
	for k, vv := range h {
		if vv == nil {
			copied[k] = nil
			continue
		}
		copied[k] = make([]string, len(vv))
		copy(copied[k], vv)
	}

	return context.WithValue(ctx, HTTPClientRequestHeadersCtxKey, copied), nil
}

func HTTPRequestHeaders(ctx context.Context) (http.Header, bool) {
	h, ok := ctx.Value(HTTPClientRequestHeadersCtxKey).(http.Header)
	return h, ok
}

//
// Helpers
//

type method struct {
	Name        string
	Service     string
	Annotations map[string]string
}

type contextKey struct {
	name string
}

func (k *contextKey) String() string {
	return "webrpc context value " + k.name
}

var (
	HTTPClientRequestHeadersCtxKey = &contextKey{"HTTPClientRequestHeaders"}
	HTTPRequestCtxKey              = &contextKey{"HTTPRequest"}

	ServiceNameCtxKey = &contextKey{"ServiceName"}

	MethodNameCtxKey = &contextKey{"MethodName"}
)

func ServiceNameFromContext(ctx context.Context) string {
	service, _ := ctx.Value(ServiceNameCtxKey).(string)
	return service
}

func MethodNameFromContext(ctx context.Context) string {
	method, _ := ctx.Value(MethodNameCtxKey).(string)
	return method
}

func RequestFromContext(ctx context.Context) *http.Request {
	r, _ := ctx.Value(HTTPRequestCtxKey).(*http.Request)
	return r
}

func MethodCtx(ctx context.Context) (method, bool) {
	req := RequestFromContext(ctx)
	if req == nil {
		return method{}, false
	}

	m, ok := methods[req.URL.Path]
	if !ok {
		return method{}, false
	}

	return m, true
}

//
// Errors
//

type WebRPCError struct {
	Name       string `json:"error"`
	Code       int    `json:"code"`
	Message    string `json:"msg"`
	Cause      string `json:"cause,omitempty"`
	HTTPStatus int    `json:"status"`
	cause      error
}

var _ error = WebRPCError{}

func (e WebRPCError) Error() string {
	if e.cause != nil {
		return fmt.Sprintf("%s %d: %s: %v", e.Name, e.Code, e.Message, e.cause)
	}
	return fmt.Sprintf("%s %d: %s", e.Name, e.Code, e.Message)
}

func (e WebRPCError) Is(target error) bool {
	if target == nil {
		return false
	}
	if rpcErr, ok := target.(WebRPCError); ok {
		return rpcErr.Code == e.Code
	}
	return errors.Is(e.cause, target)
}

func (e WebRPCError) Unwrap() error {
	return e.cause
}

func (e WebRPCError) WithCause(cause error) WebRPCError {
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

func (e WebRPCError) WithCausef(format string, args ...interface{}) WebRPCError {
	cause := fmt.Errorf(format, args...)
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

// Deprecated: Use .WithCause() method on WebRPCError.
func ErrorWithCause(rpcErr WebRPCError, cause error) WebRPCError {
	return rpcErr.WithCause(cause)
}

// Webrpc errors
var (
	ErrWebrpcEndpoint           = WebRPCError{Code: 0, Name: "WebrpcEndpoint", Message: "endpoint error", HTTPStatus: 400}
	ErrWebrpcRequestFailed      = WebRPCError{Code: -1, Name: "WebrpcRequestFailed", Message: "request failed", HTTPStatus: 400}
	ErrWebrpcBadRoute           = WebRPCError{Code: -2, Name: "WebrpcBadRoute", Message: "bad route", HTTPStatus: 404}
	ErrWebrpcBadMethod          = WebRPCError{Code: -3, Name: "WebrpcBadMethod", Message: "bad method", HTTPStatus: 405}
	ErrWebrpcBadRequest         = WebRPCError{Code: -4, Name: "WebrpcBadRequest", Message: "bad request", HTTPStatus: 400}
	ErrWebrpcBadResponse        = WebRPCError{Code: -5, Name: "WebrpcBadResponse", Message: "bad response", HTTPStatus: 500}
	ErrWebrpcServerPanic        = WebRPCError{Code: -6, Name: "WebrpcServerPanic", Message: "server panic", HTTPStatus: 500}
	ErrWebrpcInternalError      = WebRPCError{Code: -7, Name: "WebrpcInternalError", Message: "internal error", HTTPStatus: 500}
	ErrWebrpcClientDisconnected = WebRPCError{Code: -8, Name: "WebrpcClientDisconnected", Message: "client disconnected", HTTPStatus: 400}
	ErrWebrpcStreamLost         = WebRPCError{Code: -9, Name: "WebrpcStreamLost", Message: "stream lost", HTTPStatus: 400}
	ErrWebrpcStreamFinished     = WebRPCError{Code: -10, Name: "WebrpcStreamFinished", Message: "stream finished", HTTPStatus: 200}
)

// Schema errors
var (
	ErrUnauthorized       = WebRPCError{Code: 1000, Name: "Unauthorized", Message: "Unauthorized access", HTTPStatus: 401}
	ErrPermissionDenied   = WebRPCError{Code: 1001, Name: "PermissionDenied", Message: "Permission denied", HTTPStatus: 403}
	ErrSessionExpired     = WebRPCError{Code: 1002, Name: "SessionExpired", Message: "Session expired", HTTPStatus: 403}
	ErrMethodNotFound     = WebRPCError{Code: 1003, Name: "MethodNotFound", Message: "Method not found", HTTPStatus: 404}
	ErrRequestConflict    = WebRPCError{Code: 1004, Name: "RequestConflict", Message: "Conflict with target resource", HTTPStatus: 409}
	ErrAborted            = WebRPCError{Code: 1005, Name: "Aborted", Message: "Request aborted", HTTPStatus: 400}
	ErrGeoblocked         = WebRPCError{Code: 1006, Name: "Geoblocked", Message: "Geoblocked region", HTTPStatus: 451}
	ErrRateLimited        = WebRPCError{Code: 1007, Name: "RateLimited", Message: "Rate-limited. Please slow down.", HTTPStatus: 429}
	ErrProjectNotFound    = WebRPCError{Code: 1008, Name: "ProjectNotFound", Message: "Project not found", HTTPStatus: 401}
	ErrAccessKeyNotFound  = WebRPCError{Code: 1101, Name: "AccessKeyNotFound", Message: "Access key not found", HTTPStatus: 401}
	ErrAccessKeyMismatch  = WebRPCError{Code: 1102, Name: "AccessKeyMismatch", Message: "Access key mismatch", HTTPStatus: 409}
	ErrInvalidOrigin      = WebRPCError{Code: 1103, Name: "InvalidOrigin", Message: "Invalid origin for Access Key", HTTPStatus: 403}
	ErrInvalidService     = WebRPCError{Code: 1104, Name: "InvalidService", Message: "Service not enabled for Access key", HTTPStatus: 403}
	ErrUnauthorizedUser   = WebRPCError{Code: 1105, Name: "UnauthorizedUser", Message: "Unauthorized user", HTTPStatus: 403}
	ErrQuotaExceeded      = WebRPCError{Code: 1200, Name: "QuotaExceeded", Message: "Quota request exceeded", HTTPStatus: 429}
	ErrQuotaRateLimit     = WebRPCError{Code: 1201, Name: "QuotaRateLimit", Message: "Quota rate limit exceeded", HTTPStatus: 429}
	ErrNoDefaultKey       = WebRPCError{Code: 1300, Name: "NoDefaultKey", Message: "No default access key found", HTTPStatus: 403}
	ErrMaxAccessKeys      = WebRPCError{Code: 1301, Name: "MaxAccessKeys", Message: "Access keys limit reached", HTTPStatus: 403}
	ErrAtLeastOneKey      = WebRPCError{Code: 1302, Name: "AtLeastOneKey", Message: "You need at least one Access Key", HTTPStatus: 403}
	ErrTimeout            = WebRPCError{Code: 1900, Name: "Timeout", Message: "Request timed out", HTTPStatus: 408}
	ErrInvalidArgument    = WebRPCError{Code: 2000, Name: "InvalidArgument", Message: "Invalid argument", HTTPStatus: 400}
	ErrUnavailable        = WebRPCError{Code: 2002, Name: "Unavailable", Message: "Unavailable resource", HTTPStatus: 400}
	ErrQueryFailed        = WebRPCError{Code: 2003, Name: "QueryFailed", Message: "Query failed", HTTPStatus: 400}
	ErrNotFound           = WebRPCError{Code: 3000, Name: "NotFound", Message: "Resource not found", HTTPStatus: 400}
	ErrUnsupportedNetwork = WebRPCError{Code: 3008, Name: "UnsupportedNetwork", Message: "Unsupported network", HTTPStatus: 422}
)
