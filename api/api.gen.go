// sequence-api v0.4.0 d026b8c7eb9ac3c9c5ed52994a34e2463c1aaa14
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/golang
// Do not edit by hand. Update your webrpc schema and re-generate.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"time"

	"github.com/0xsequence/go-sequence/lib/prototyp"
)

// WebRPC description and code-gen version
func WebRPCVersion() string {
	return "v1"
}

// Schema version of your RIDL schema
func WebRPCSchemaVersion() string {
	return "v0.4.0"
}

// Schema hash generated from your RIDL schema
func WebRPCSchemaHash() string {
	return "d026b8c7eb9ac3c9c5ed52994a34e2463c1aaa14"
}

//
// Types
//

type SmartRampOrderStatus uint32

const (
	SmartRampOrderStatus_UNKNOWN        SmartRampOrderStatus = 0
	SmartRampOrderStatus_RUNNING_CHECKS SmartRampOrderStatus = 1
	SmartRampOrderStatus_PROCESSING     SmartRampOrderStatus = 2
	SmartRampOrderStatus_FAILED         SmartRampOrderStatus = 3
	SmartRampOrderStatus_COMPLETE       SmartRampOrderStatus = 4
)

var SmartRampOrderStatus_name = map[uint32]string{
	0: "UNKNOWN",
	1: "RUNNING_CHECKS",
	2: "PROCESSING",
	3: "FAILED",
	4: "COMPLETE",
}

var SmartRampOrderStatus_value = map[string]uint32{
	"UNKNOWN":        0,
	"RUNNING_CHECKS": 1,
	"PROCESSING":     2,
	"FAILED":         3,
	"COMPLETE":       4,
}

func (x SmartRampOrderStatus) String() string {
	return SmartRampOrderStatus_name[uint32(x)]
}

func (x SmartRampOrderStatus) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBufferString(`"`)
	buf.WriteString(SmartRampOrderStatus_name[uint32(x)])
	buf.WriteString(`"`)
	return buf.Bytes(), nil
}

func (x *SmartRampOrderStatus) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	*x = SmartRampOrderStatus(SmartRampOrderStatus_value[j])
	return nil
}

type SortOrder uint32

const (
	SortOrder_DESC SortOrder = 0
	SortOrder_ASC  SortOrder = 1
)

var SortOrder_name = map[uint32]string{
	0: "DESC",
	1: "ASC",
}

var SortOrder_value = map[string]uint32{
	"DESC": 0,
	"ASC":  1,
}

func (x SortOrder) String() string {
	return SortOrder_name[uint32(x)]
}

func (x SortOrder) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBufferString(`"`)
	buf.WriteString(SortOrder_name[uint32(x)])
	buf.WriteString(`"`)
	return buf.Bytes(), nil
}

func (x *SortOrder) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err != nil {
		return err
	}
	*x = SortOrder(SortOrder_value[j])
	return nil
}

type Version struct {
	WebrpcVersion string `json:"webrpcVersion"`
	SchemaVersion string `json:"schemaVersion"`
	SchemaHash    string `json:"schemaHash"`
	AppVersion    string `json:"appVersion"`
}

type RuntimeStatus struct {
	HealthOK   bool           `json:"healthOK"`
	StartTime  time.Time      `json:"startTime"`
	Uptime     uint64         `json:"uptime"`
	Ver        string         `json:"ver"`
	Branch     string         `json:"branch"`
	CommitHash string         `json:"commitHash"`
	Checks     *RuntimeChecks `json:"checks"`
}

type RuntimeChecks struct {
}

type SequenceContext struct {
	Factory              string `json:"factory"`
	MainModule           string `json:"mainModule"`
	MainModuleUpgradable string `json:"mainModuleUpgradable"`
	GuestModule          string `json:"guestModule"`
	Utils                string `json:"utils"`
}

type User struct {
	Address            prototyp.Hash `json:"address" db:"address"`
	Username           string        `json:"username" db:"username"`
	NormalizedUsername string        `json:"-" db:"normalized_username"`
	Avatar             string        `json:"avatar" db:"avatar"`
	Bio                string        `json:"bio" db:"bio"`
	Location           string        `json:"location" db:"location"`
	Locale             string        `json:"locale" db:"locale"`
	Backup             *bool         `json:"backup,omitempty" db:"-"`
	BackupConfirmed    *bool         `json:"backupConfirmed,omitempty" db:"-"`
	MaxInvites         *uint32       `json:"maxInvites" db:"max_invites"`
	UpdatedAt          *time.Time    `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt          *time.Time    `json:"createdAt,omitempty" db:"created_at,omitempty"`
	SysAdmin           bool          `json:"-" db:"sys_admin"`
}

type WalletBackup struct {
	AccountAddress  prototyp.Hash `json:"accountAddress" db:"account_address"`
	SecretHash      string        `json:"secretHash" db:"secret_hash"`
	EncryptedWallet string        `json:"encryptedWallet" db:"encrypted_wallet"`
	UserConfirmed   bool          `json:"userConfirmed" db:"user_confirmed"`
	UpdatedAt       *time.Time    `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt       *time.Time    `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

type Friend struct {
	ID            uint64        `json:"id" db:"id,omitempty"`
	UserAddress   prototyp.Hash `json:"userAddress" db:"user_address"`
	FriendAddress prototyp.Hash `json:"friendAddress" db:"friend_address"`
	Nickname      string        `json:"nickname" db:"nickname"`
	User          *User         `json:"user" db:"-"`
	CreatedAt     *time.Time    `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

type InviteCode struct {
	Code         string             `json:"-" db:"code"`
	Source       string             `json:"-" db:"source"`
	UsesLeft     uint32             `json:"usesLeft" db:"uses_left"`
	OwnerAccount prototyp.HashMaybe `json:"ownerAccount" db:"owner_account"`
	Email        *string            `json:"email" db:"email"`
	Url          string             `json:"url"`
	CreatedAt    *time.Time         `json:"createdAt,omitempty" db:"created_at,omitempty"`
	ExpiresAt    *time.Time         `json:"expiresAt,omitempty" db:"expires_at,omitempty"`
}

type InviteCodeAccount struct {
	Code                 string        `json:"-" db:"code"`
	ClaimedByUserAddress prototyp.Hash `json:"claimedByUserAddress" db:"claimed_by_user_address"`
	ClaimedAt            *time.Time    `json:"claimedAt,omitempty" db:"claimed_at,omitempty"`
}

type InviteInfo struct {
	ExpiryInHours uint32        `json:"expiryInHours"`
	Max           uint32        `json:"max"`
	Invites       []*InviteCode `json:"invites"`
}

type ContractCall struct {
	Signature string            `json:"signature"`
	Function  string            `json:"function"`
	Args      []*TupleComponent `json:"args"`
}

type TupleComponent struct {
	Name  *string     `json:"name"`
	Type  string      `json:"type"`
	Value interface{} `json:"value"`
}

type Transaction struct {
	DelegateCall  bool            `json:"delegateCall"`
	RevertOnError bool            `json:"revertOnError"`
	GasLimit      prototyp.BigInt `json:"gasLimit"`
	Target        string          `json:"target"`
	Value         prototyp.BigInt `json:"value"`
	Data          string          `json:"data"`
	Call          *ContractCall   `json:"call"`
}

type UserStorage struct {
	UserAddress prototyp.Hash       `json:"userAddress" db:"user_address"`
	Key         string              `json:"key"`
	Value       prototyp.JSONString `json:"value"`
}

type Token struct {
	ChainId         uint64        `json:"chainId"`
	ContractAddress prototyp.Hash `json:"contractAddress"`
	TokenId         *string       `json:"tokenId"`
}

type Price struct {
	Value    float64 `json:"value"`
	Currency string  `json:"currency"`
}

type TokenPrice struct {
	Token          *Token     `json:"token"`
	Price          *Price     `json:"price"`
	Price24hChange *Price     `json:"price24hChange"`
	FloorPrice     *Price     `json:"floorPrice,omitempty"`
	BuyPrice       *Price     `json:"buyPrice,omitempty"`
	SellPrice      *Price     `json:"sellPrice,omitempty"`
	UpdatedAt      *time.Time `json:"updatedAt"`
}

type ExchangeRate struct {
	Name         string  `json:"name"`
	Symbol       string  `json:"symbol"`
	Value        float64 `json:"value"`
	VsCurrency   string  `json:"vsCurrency"`
	CurrencyType string  `json:"currencyType"`
}

type PayCard struct {
	ID                       uint64        `json:"id" db:"id,omitempty"`
	UserAddress              prototyp.Hash `json:"userAddress" db:"user_address"`
	CardType                 string        `json:"cardType" db:"card_type"`
	CardFirstName            string        `json:"cardFirstName" db:"card_first_name"`
	CardLastName             string        `json:"cardLastName" db:"card_last_name"`
	CardNumberLastFourDigits string        `json:"cardNumberLastFourDigits" db:"card_num_last_four"`
	CardNumberToken          string        `json:"cardNumberToken" db:"card_num_token"`
	CardCVCToken             string        `json:"cardCVCToken" db:"card_cvc_token"`
	CardExpMonth             uint32        `json:"cardExpMonth" db:"card_exp_month"`
	CardExpYear              uint32        `json:"cardExpYear" db:"card_exp_year"`
	ContactAddressToken      string        `json:"contactAddressToken" db:"contact_address_token"`
	ContactCityToken         string        `json:"contactCityToken" db:"contact_city_token"`
	ContactProvinceToken     string        `json:"contactProvinceToken" db:"contact_province_token"`
	ContactPostalCodeToken   string        `json:"contactPostalCodeToken" db:"contact_postal_code_token"`
	ContactCountryCode       string        `json:"contactCountryCode" db:"contact_country_code"`
	ContactEmail             string        `json:"contactEmail" db:"contact_email"`
	ContactPhoneToken        string        `json:"contactPhoneToken" db:"contact_phone_token"`
	UpdatedAt                *time.Time    `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt                *time.Time    `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

type SmartRampQuoteRequest struct {
	CountryCode              string            `json:"countryCode"`
	NiftyswapContractAddress string            `json:"niftyswapContractAddress"`
	TokenIDs                 []prototyp.BigInt `json:"tokenIds"`
	TokensBoughtAmounts      []prototyp.BigInt `json:"tokensBoughtAmounts"`
	MaxCurrency              float64           `json:"maxCurrency"`
	ExtraFeeRecipients       []prototyp.Hash   `json:"extraFeeRecipients"`
	ExtraFeeAmounts          []prototyp.BigInt `json:"extraFeeAmounts"`
}

type SmartRampQuoteDetails struct {
	QuoteID          string                 `json:"quoteId"`
	SmartScriptID    string                 `json:"smartScriptId"`
	QuoteRequest     *SmartRampQuoteRequest `json:"quoteRequest"`
	RecipientAddress string                 `json:"recipientAddress"`
	PurchaseAmount   float64                `json:"purchaseAmount"`
	PurchaseFees     float64                `json:"purchaseFees"`
	PurchaseTotal    float64                `json:"purchaseTotal"`
	SourceCurrency   string                 `json:"sourceCurrency"`
	DestCurrency     string                 `json:"destCurrency"`
	CreatedAt        time.Time              `json:"createdAt"`
	ExpiresAt        time.Time              `json:"expiresAt"`
}

type SmartRampPurchaseReceipt struct {
	OrderID            string               `json:"orderId"`
	QuoteID            string               `json:"quoteId"`
	SmartScriptID      string               `json:"smartScriptId"`
	CreatedAt          time.Time            `json:"createdAt"`
	Status             SmartRampOrderStatus `json:"status"`
	AuthCodesRequested bool                 `json:"authCodesRequested"`
	AuthCodesSubmitted bool                 `json:"authCodesSubmitted"`
	SourceCurrency     string               `json:"sourceCurrency"`
	PurchaseAmount     float64              `json:"purchaseAmount"`
	PurchaseFees       float64              `json:"purchaseFees"`
	PurchaseTotal      float64              `json:"purchaseTotal"`
}

type SmartRampOrder struct {
	ID                 uint64                 `json:"id" db:"id,omitempty"`
	UserAddress        prototyp.Hash          `json:"userAddress" db:"user_address"`
	ContractAddress    prototyp.Hash          `json:"contractAddress" db:"contract_address"`
	PayCardID          uint64                 `json:"payCardId" db:"pay_card_id"`
	OrderID            string                 `json:"orderId" db:"order_id"`
	QuoteID            string                 `json:"quoteId" db:"quote_id"`
	Status             SmartRampOrderStatus   `json:"status" db:"status"`
	AuthCodesRequested bool                   `json:"authCodesRequested" db:"auth_codes_requested"`
	AuthCodesSubmitted bool                   `json:"authCodesSubmitted" db:"auth_codes_submitted"`
	CountryCode        string                 `json:"countryCode" db:"country_code"`
	Email              string                 `json:"email" db:"email"`
	SourceCurrency     string                 `json:"sourceCurrency" db:"source_currency"`
	DestCurrency       string                 `json:"destCurrency" db:"dest_currency"`
	PurchaseAmount     float64                `json:"purchaseAmount" db:"purchase_amount"`
	PurchaseFees       float64                `json:"purchaseFees" db:"purchase_fees"`
	PurchaseTotal      float64                `json:"purchaseTotal" db:"purchase_total"`
	SmartScriptParams  map[string]interface{} `json:"smartScriptParams" db:"smart_script_params"`
	UpdatedAt          *time.Time             `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt          *time.Time             `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

type PayCardAuth struct {
	OrderID             string `json:"orderId"`
	SmsNeeded           bool   `json:"smsNeeded"`
	Card2faNeeded       bool   `json:"card2faNeeded"`
	Authorization3dsUrl string `json:"authorization3dsUrl"`
}

type Page struct {
	PageSize     *uint32      `json:"pageSize"`
	Page         *uint32      `json:"page"`
	TotalRecords *uint64      `json:"totalRecords"`
	Column       *string      `json:"column"`
	Before       *interface{} `json:"before"`
	After        *interface{} `json:"after"`
	Sort         []*SortBy    `json:"sort"`
}

type SortBy struct {
	Column string     `json:"column"`
	Order  *SortOrder `json:"order"`
}

type API interface {
	Ping(ctx context.Context) (bool, error)
	Version(ctx context.Context) (*Version, error)
	RuntimeStatus(ctx context.Context) (*RuntimeStatus, error)
	GetSequenceContext(ctx context.Context) (*SequenceContext, error)
	GetAuthToken(ctx context.Context, ewtString string, testnetMode *bool) (bool, string, string, *User, error)
	SendPasswordlessLink(ctx context.Context, email string, redirectUri string, intent string) (bool, error)
	FriendList(ctx context.Context, page *Page) (*Page, []*Friend, error)
	GetFriendByAddress(ctx context.Context, friendAddress string) (bool, *Friend, error)
	SearchFriends(ctx context.Context, filterUsername string) ([]*Friend, error)
	AddFriend(ctx context.Context, friendAddress string, optionalNickname *string) (bool, *Friend, error)
	UpdateFriendNickname(ctx context.Context, friendAddress string, nickname string) (bool, *Friend, error)
	RemoveFriend(ctx context.Context, friendAddress string) (bool, error)
	ContractCall(ctx context.Context, chainID string, contract string, inputExpr string, outputExpr string, args []string) ([]string, error)
	DecodeContractCall(ctx context.Context, callData string) (*ContractCall, error)
	LookupContractCallSelectors(ctx context.Context, selectors []string) ([][]string, error)
	UserStorageFetch(ctx context.Context, key string) (interface{}, error)
	UserStorageSave(ctx context.Context, key string, object interface{}) (bool, error)
	UserStorageDelete(ctx context.Context, key string) (bool, error)
	UserStorageFetchAll(ctx context.Context, keys []string) (map[string]interface{}, error)
	GetMoonpayLink(ctx context.Context, url string) (string, error)
	IsUsingGoogleMail(ctx context.Context, domain string) (bool, error)
	IsValidSignature(ctx context.Context, chainId string, walletAddress string, digest string, signature string) (bool, error)
	IsValidMessageSignature(ctx context.Context, chainId string, walletAddress string, message string, signature string) (bool, error)
	IsValidTypedDataSignature(ctx context.Context, chainId string, walletAddress string, typedData interface{}, signature string) (bool, error)
	IsValidETHAuthProof(ctx context.Context, chainId string, walletAddress string, ethAuthProof string) (bool, error)
	GetCoinPrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
	GetCollectiblePrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
	GetExchangeRate(ctx context.Context, toCurrency string) (*ExchangeRate, error)
	ListPayCardsOnFile(ctx context.Context) ([]*PayCard, error)
	SavePayCard(ctx context.Context, payCard *PayCard) (bool, *PayCard, error)
	UpdatePayCardCVC(ctx context.Context, payCardId uint64, payCardCVC string) (bool, error)
	DeletePayCard(ctx context.Context, payCardId uint64) (bool, error)
	SmartRampQuote(ctx context.Context, quoteRequest *SmartRampQuoteRequest) (bool, *SmartRampQuoteDetails, error)
	SmartRampPurchase(ctx context.Context, quoteDetails *SmartRampQuoteDetails, payCardId uint64, payCardCVC *string) (bool, *SmartRampPurchaseReceipt, error)
	SmartRampWaitOrderConfirmation(ctx context.Context, orderId string) (bool, *SmartRampPurchaseReceipt, error)
	SmartRampGetOrder(ctx context.Context, orderId *string, id *uint64) (*SmartRampOrder, error)
	SmartRampCheckCardAuthorization(ctx context.Context, orderId string) (*PayCardAuth, error)
	SmartRampSubmitCardAuthorization(ctx context.Context, orderId string, sms *string, card2fa *string) (bool, error)
	SmartRampOrdersList(ctx context.Context, page *Page, userAddressFilter *string) (*Page, []*SmartRampOrder, error)
	GetInviteInfo(ctx context.Context) (*InviteInfo, error)
	IsValidAccessCode(ctx context.Context, accessCode string) (bool, error)
	InternalClaimAccessCode(ctx context.Context, address string, accessCode string) (bool, error)
	WalletRecover(ctx context.Context, username string, secretHash string) (string, error)
}

var WebRPCServices = map[string][]string{
	"API": {
		"Ping",
		"Version",
		"RuntimeStatus",
		"GetSequenceContext",
		"GetAuthToken",
		"SendPasswordlessLink",
		"FriendList",
		"GetFriendByAddress",
		"SearchFriends",
		"AddFriend",
		"UpdateFriendNickname",
		"RemoveFriend",
		"ContractCall",
		"DecodeContractCall",
		"LookupContractCallSelectors",
		"UserStorageFetch",
		"UserStorageSave",
		"UserStorageDelete",
		"UserStorageFetchAll",
		"GetMoonpayLink",
		"IsUsingGoogleMail",
		"IsValidSignature",
		"IsValidMessageSignature",
		"IsValidTypedDataSignature",
		"IsValidETHAuthProof",
		"GetCoinPrices",
		"GetCollectiblePrices",
		"GetExchangeRate",
		"ListPayCardsOnFile",
		"SavePayCard",
		"UpdatePayCardCVC",
		"DeletePayCard",
		"SmartRampQuote",
		"SmartRampPurchase",
		"SmartRampWaitOrderConfirmation",
		"SmartRampGetOrder",
		"SmartRampCheckCardAuthorization",
		"SmartRampSubmitCardAuthorization",
		"SmartRampOrdersList",
		"GetInviteInfo",
		"IsValidAccessCode",
		"InternalClaimAccessCode",
		"WalletRecover",
	},
}

//
// Client
//

const APIPathPrefix = "/rpc/API/"

type aPIClient struct {
	client HTTPClient
	urls   [43]string
}

func NewAPIClient(addr string, client HTTPClient) API {
	prefix := urlBase(addr) + APIPathPrefix
	urls := [43]string{
		prefix + "Ping",
		prefix + "Version",
		prefix + "RuntimeStatus",
		prefix + "GetSequenceContext",
		prefix + "GetAuthToken",
		prefix + "SendPasswordlessLink",
		prefix + "FriendList",
		prefix + "GetFriendByAddress",
		prefix + "SearchFriends",
		prefix + "AddFriend",
		prefix + "UpdateFriendNickname",
		prefix + "RemoveFriend",
		prefix + "ContractCall",
		prefix + "DecodeContractCall",
		prefix + "LookupContractCallSelectors",
		prefix + "UserStorageFetch",
		prefix + "UserStorageSave",
		prefix + "UserStorageDelete",
		prefix + "UserStorageFetchAll",
		prefix + "GetMoonpayLink",
		prefix + "IsUsingGoogleMail",
		prefix + "IsValidSignature",
		prefix + "IsValidMessageSignature",
		prefix + "IsValidTypedDataSignature",
		prefix + "IsValidETHAuthProof",
		prefix + "GetCoinPrices",
		prefix + "GetCollectiblePrices",
		prefix + "GetExchangeRate",
		prefix + "ListPayCardsOnFile",
		prefix + "SavePayCard",
		prefix + "UpdatePayCardCVC",
		prefix + "DeletePayCard",
		prefix + "SmartRampQuote",
		prefix + "SmartRampPurchase",
		prefix + "SmartRampWaitOrderConfirmation",
		prefix + "SmartRampGetOrder",
		prefix + "SmartRampCheckCardAuthorization",
		prefix + "SmartRampSubmitCardAuthorization",
		prefix + "SmartRampOrdersList",
		prefix + "GetInviteInfo",
		prefix + "IsValidAccessCode",
		prefix + "InternalClaimAccessCode",
		prefix + "WalletRecover",
	}
	return &aPIClient{
		client: client,
		urls:   urls,
	}
}

func (c *aPIClient) Ping(ctx context.Context) (bool, error) {
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[0], nil, &out)
	return out.Ret0, err
}

func (c *aPIClient) Version(ctx context.Context) (*Version, error) {
	out := struct {
		Ret0 *Version `json:"version"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[1], nil, &out)
	return out.Ret0, err
}

func (c *aPIClient) RuntimeStatus(ctx context.Context) (*RuntimeStatus, error) {
	out := struct {
		Ret0 *RuntimeStatus `json:"status"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[2], nil, &out)
	return out.Ret0, err
}

func (c *aPIClient) GetSequenceContext(ctx context.Context) (*SequenceContext, error) {
	out := struct {
		Ret0 *SequenceContext `json:"data"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[3], nil, &out)
	return out.Ret0, err
}

func (c *aPIClient) GetAuthToken(ctx context.Context, ewtString string, testnetMode *bool) (bool, string, string, *User, error) {
	in := struct {
		Arg0 string `json:"ewtString"`
		Arg1 *bool  `json:"testnetMode"`
	}{ewtString, testnetMode}
	out := struct {
		Ret0 bool   `json:"status"`
		Ret1 string `json:"jwtToken"`
		Ret2 string `json:"address"`
		Ret3 *User  `json:"user"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[4], in, &out)
	return out.Ret0, out.Ret1, out.Ret2, out.Ret3, err
}

func (c *aPIClient) SendPasswordlessLink(ctx context.Context, email string, redirectUri string, intent string) (bool, error) {
	in := struct {
		Arg0 string `json:"email"`
		Arg1 string `json:"redirectUri"`
		Arg2 string `json:"intent"`
	}{email, redirectUri, intent}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[5], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) FriendList(ctx context.Context, page *Page) (*Page, []*Friend, error) {
	in := struct {
		Arg0 *Page `json:"page"`
	}{page}
	out := struct {
		Ret0 *Page     `json:"page"`
		Ret1 []*Friend `json:"friends"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[6], in, &out)
	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) GetFriendByAddress(ctx context.Context, friendAddress string) (bool, *Friend, error) {
	in := struct {
		Arg0 string `json:"friendAddress"`
	}{friendAddress}
	out := struct {
		Ret0 bool    `json:"status"`
		Ret1 *Friend `json:"friend"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[7], in, &out)
	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) SearchFriends(ctx context.Context, filterUsername string) ([]*Friend, error) {
	in := struct {
		Arg0 string `json:"filterUsername"`
	}{filterUsername}
	out := struct {
		Ret0 []*Friend `json:"friends"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[8], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) AddFriend(ctx context.Context, friendAddress string, optionalNickname *string) (bool, *Friend, error) {
	in := struct {
		Arg0 string  `json:"friendAddress"`
		Arg1 *string `json:"optionalNickname"`
	}{friendAddress, optionalNickname}
	out := struct {
		Ret0 bool    `json:"status"`
		Ret1 *Friend `json:"friend"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[9], in, &out)
	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) UpdateFriendNickname(ctx context.Context, friendAddress string, nickname string) (bool, *Friend, error) {
	in := struct {
		Arg0 string `json:"friendAddress"`
		Arg1 string `json:"nickname"`
	}{friendAddress, nickname}
	out := struct {
		Ret0 bool    `json:"status"`
		Ret1 *Friend `json:"friend"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[10], in, &out)
	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) RemoveFriend(ctx context.Context, friendAddress string) (bool, error) {
	in := struct {
		Arg0 string `json:"friendAddress"`
	}{friendAddress}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[11], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) ContractCall(ctx context.Context, chainID string, contract string, inputExpr string, outputExpr string, args []string) ([]string, error) {
	in := struct {
		Arg0 string   `json:"chainID"`
		Arg1 string   `json:"contract"`
		Arg2 string   `json:"inputExpr"`
		Arg3 string   `json:"outputExpr"`
		Arg4 []string `json:"args"`
	}{chainID, contract, inputExpr, outputExpr, args}
	out := struct {
		Ret0 []string `json:"returns"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[12], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) DecodeContractCall(ctx context.Context, callData string) (*ContractCall, error) {
	in := struct {
		Arg0 string `json:"callData"`
	}{callData}
	out := struct {
		Ret0 *ContractCall `json:"call"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[13], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) LookupContractCallSelectors(ctx context.Context, selectors []string) ([][]string, error) {
	in := struct {
		Arg0 []string `json:"selectors"`
	}{selectors}
	out := struct {
		Ret0 [][]string `json:"signatures"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[14], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) UserStorageFetch(ctx context.Context, key string) (interface{}, error) {
	in := struct {
		Arg0 string `json:"key"`
	}{key}
	out := struct {
		Ret0 interface{} `json:"object"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[15], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) UserStorageSave(ctx context.Context, key string, object interface{}) (bool, error) {
	in := struct {
		Arg0 string      `json:"key"`
		Arg1 interface{} `json:"object"`
	}{key, object}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[16], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) UserStorageDelete(ctx context.Context, key string) (bool, error) {
	in := struct {
		Arg0 string `json:"key"`
	}{key}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[17], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) UserStorageFetchAll(ctx context.Context, keys []string) (map[string]interface{}, error) {
	in := struct {
		Arg0 []string `json:"keys"`
	}{keys}
	out := struct {
		Ret0 map[string]interface{} `json:"objects"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[18], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) GetMoonpayLink(ctx context.Context, url string) (string, error) {
	in := struct {
		Arg0 string `json:"url"`
	}{url}
	out := struct {
		Ret0 string `json:"signedUrl"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[19], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) IsUsingGoogleMail(ctx context.Context, domain string) (bool, error) {
	in := struct {
		Arg0 string `json:"domain"`
	}{domain}
	out := struct {
		Ret0 bool `json:"yes"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[20], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) IsValidSignature(ctx context.Context, chainId string, walletAddress string, digest string, signature string) (bool, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"walletAddress"`
		Arg2 string `json:"digest"`
		Arg3 string `json:"signature"`
	}{chainId, walletAddress, digest, signature}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[21], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) IsValidMessageSignature(ctx context.Context, chainId string, walletAddress string, message string, signature string) (bool, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"walletAddress"`
		Arg2 string `json:"message"`
		Arg3 string `json:"signature"`
	}{chainId, walletAddress, message, signature}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[22], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) IsValidTypedDataSignature(ctx context.Context, chainId string, walletAddress string, typedData interface{}, signature string) (bool, error) {
	in := struct {
		Arg0 string      `json:"chainId"`
		Arg1 string      `json:"walletAddress"`
		Arg2 interface{} `json:"typedData"`
		Arg3 string      `json:"signature"`
	}{chainId, walletAddress, typedData, signature}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[23], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) IsValidETHAuthProof(ctx context.Context, chainId string, walletAddress string, ethAuthProof string) (bool, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"walletAddress"`
		Arg2 string `json:"ethAuthProof"`
	}{chainId, walletAddress, ethAuthProof}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[24], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) GetCoinPrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error) {
	in := struct {
		Arg0 []*Token `json:"tokens"`
	}{tokens}
	out := struct {
		Ret0 []*TokenPrice `json:"tokenPrices"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[25], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) GetCollectiblePrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error) {
	in := struct {
		Arg0 []*Token `json:"tokens"`
	}{tokens}
	out := struct {
		Ret0 []*TokenPrice `json:"tokenPrices"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[26], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) GetExchangeRate(ctx context.Context, toCurrency string) (*ExchangeRate, error) {
	in := struct {
		Arg0 string `json:"toCurrency"`
	}{toCurrency}
	out := struct {
		Ret0 *ExchangeRate `json:"exchangeRate"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[27], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) ListPayCardsOnFile(ctx context.Context) ([]*PayCard, error) {
	out := struct {
		Ret0 []*PayCard `json:"payCards"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[28], nil, &out)
	return out.Ret0, err
}

func (c *aPIClient) SavePayCard(ctx context.Context, payCard *PayCard) (bool, *PayCard, error) {
	in := struct {
		Arg0 *PayCard `json:"payCard"`
	}{payCard}
	out := struct {
		Ret0 bool     `json:"ok"`
		Ret1 *PayCard `json:"payCard"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[29], in, &out)
	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) UpdatePayCardCVC(ctx context.Context, payCardId uint64, payCardCVC string) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"payCardId"`
		Arg1 string `json:"payCardCVC"`
	}{payCardId, payCardCVC}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[30], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) DeletePayCard(ctx context.Context, payCardId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"payCardId"`
	}{payCardId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[31], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) SmartRampQuote(ctx context.Context, quoteRequest *SmartRampQuoteRequest) (bool, *SmartRampQuoteDetails, error) {
	in := struct {
		Arg0 *SmartRampQuoteRequest `json:"quoteRequest"`
	}{quoteRequest}
	out := struct {
		Ret0 bool                   `json:"status"`
		Ret1 *SmartRampQuoteDetails `json:"quoteDetails"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[32], in, &out)
	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) SmartRampPurchase(ctx context.Context, quoteDetails *SmartRampQuoteDetails, payCardId uint64, payCardCVC *string) (bool, *SmartRampPurchaseReceipt, error) {
	in := struct {
		Arg0 *SmartRampQuoteDetails `json:"quoteDetails"`
		Arg1 uint64                 `json:"payCardId"`
		Arg2 *string                `json:"payCardCVC"`
	}{quoteDetails, payCardId, payCardCVC}
	out := struct {
		Ret0 bool                      `json:"processing"`
		Ret1 *SmartRampPurchaseReceipt `json:"receipt"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[33], in, &out)
	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) SmartRampWaitOrderConfirmation(ctx context.Context, orderId string) (bool, *SmartRampPurchaseReceipt, error) {
	in := struct {
		Arg0 string `json:"orderId"`
	}{orderId}
	out := struct {
		Ret0 bool                      `json:"done"`
		Ret1 *SmartRampPurchaseReceipt `json:"receipt"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[34], in, &out)
	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) SmartRampGetOrder(ctx context.Context, orderId *string, id *uint64) (*SmartRampOrder, error) {
	in := struct {
		Arg0 *string `json:"orderId"`
		Arg1 *uint64 `json:"id"`
	}{orderId, id}
	out := struct {
		Ret0 *SmartRampOrder `json:"order"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[35], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) SmartRampCheckCardAuthorization(ctx context.Context, orderId string) (*PayCardAuth, error) {
	in := struct {
		Arg0 string `json:"orderId"`
	}{orderId}
	out := struct {
		Ret0 *PayCardAuth `json:"cardAuth"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[36], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) SmartRampSubmitCardAuthorization(ctx context.Context, orderId string, sms *string, card2fa *string) (bool, error) {
	in := struct {
		Arg0 string  `json:"orderId"`
		Arg1 *string `json:"sms"`
		Arg2 *string `json:"card2fa"`
	}{orderId, sms, card2fa}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[37], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) SmartRampOrdersList(ctx context.Context, page *Page, userAddressFilter *string) (*Page, []*SmartRampOrder, error) {
	in := struct {
		Arg0 *Page   `json:"page"`
		Arg1 *string `json:"userAddressFilter"`
	}{page, userAddressFilter}
	out := struct {
		Ret0 *Page             `json:"page"`
		Ret1 []*SmartRampOrder `json:"orders"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[38], in, &out)
	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) GetInviteInfo(ctx context.Context) (*InviteInfo, error) {
	out := struct {
		Ret0 *InviteInfo `json:"inviteInfo"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[39], nil, &out)
	return out.Ret0, err
}

func (c *aPIClient) IsValidAccessCode(ctx context.Context, accessCode string) (bool, error) {
	in := struct {
		Arg0 string `json:"accessCode"`
	}{accessCode}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[40], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) InternalClaimAccessCode(ctx context.Context, address string, accessCode string) (bool, error) {
	in := struct {
		Arg0 string `json:"address"`
		Arg1 string `json:"accessCode"`
	}{address, accessCode}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[41], in, &out)
	return out.Ret0, err
}

func (c *aPIClient) WalletRecover(ctx context.Context, username string, secretHash string) (string, error) {
	in := struct {
		Arg0 string `json:"username"`
		Arg1 string `json:"secretHash"`
	}{username, secretHash}
	out := struct {
		Ret0 string `json:"encryptedWallet"`
	}{}

	err := doJSONRequest(ctx, c.client, c.urls[42], in, &out)
	return out.Ret0, err
}

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// urlBase helps ensure that addr specifies a scheme. If it is unparsable
// as a URL, it returns addr unchanged.
func urlBase(addr string) string {
	// If the addr specifies a scheme, use it. If not, default to
	// http. If url.Parse fails on it, return it unchanged.
	url, err := url.Parse(addr)
	if err != nil {
		return addr
	}
	if url.Scheme == "" {
		url.Scheme = "http"
	}
	return url.String()
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) {
	req, err := http.NewRequest("POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", contentType)
	req.Header.Set("Content-Type", contentType)
	if headers, ok := HTTPRequestHeaders(ctx); ok {
		for k := range headers {
			for _, v := range headers[k] {
				req.Header.Add(k, v)
			}
		}
	}
	return req, nil
}

// doJSONRequest is common code to make a request to the remote service.
func doJSONRequest(ctx context.Context, client HTTPClient, url string, in, out interface{}) error {
	reqBody, err := json.Marshal(in)
	if err != nil {
		return clientError("failed to marshal json request", err)
	}
	if err = ctx.Err(); err != nil {
		return clientError("aborted because context was done", err)
	}

	req, err := newRequest(ctx, url, bytes.NewBuffer(reqBody), "application/json")
	if err != nil {
		return clientError("could not build request", err)
	}
	resp, err := client.Do(req)
	if err != nil {
		return clientError("request failed", err)
	}

	defer func() {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = clientError("failed to close response body", cerr)
		}
	}()

	if err = ctx.Err(); err != nil {
		return clientError("aborted because context was done", err)
	}

	if resp.StatusCode != 200 {
		return errorFromResponse(resp)
	}

	if out != nil {
		respBody, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			return clientError("failed to read response body", err)
		}

		err = json.Unmarshal(respBody, &out)
		if err != nil {
			return clientError("failed to unmarshal json response body", err)
		}
		if err = ctx.Err(); err != nil {
			return clientError("aborted because context was done", err)
		}
	}

	return nil
}

// errorFromResponse builds a webrpc Error from a non-200 HTTP response.
func errorFromResponse(resp *http.Response) Error {
	respBody, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return clientError("failed to read server error response body", err)
	}

	var respErr ErrorPayload
	if err := json.Unmarshal(respBody, &respErr); err != nil {
		return clientError("failed unmarshal error response", err)
	}

	errCode := ErrorCode(respErr.Code)

	if HTTPStatusFromErrorCode(errCode) == 0 {
		return ErrorInternal("invalid code returned from server error response: %s", respErr.Code)
	}

	return &rpcErr{
		code:  errCode,
		msg:   respErr.Msg,
		cause: errors.New(respErr.Cause),
	}
}

func clientError(desc string, err error) Error {
	return WrapError(ErrInternal, err, desc)
}

func WithHTTPRequestHeaders(ctx context.Context, h http.Header) (context.Context, error) {
	if _, ok := h["Accept"]; ok {
		return nil, errors.New("provided header cannot set Accept")
	}
	if _, ok := h["Content-Type"]; ok {
		return nil, errors.New("provided header cannot set Content-Type")
	}

	copied := make(http.Header, len(h))
	for k, vv := range h {
		if vv == nil {
			copied[k] = nil
			continue
		}
		copied[k] = make([]string, len(vv))
		copy(copied[k], vv)
	}

	return context.WithValue(ctx, HTTPClientRequestHeadersCtxKey, copied), nil
}

func HTTPRequestHeaders(ctx context.Context) (http.Header, bool) {
	h, ok := ctx.Value(HTTPClientRequestHeadersCtxKey).(http.Header)
	return h, ok
}

//
// Helpers
//

type ErrorPayload struct {
	Status int    `json:"status"`
	Code   string `json:"code"`
	Cause  string `json:"cause,omitempty"`
	Msg    string `json:"msg"`
	Error  string `json:"error"`
}

type Error interface {
	// Code is of the valid error codes
	Code() ErrorCode

	// Msg returns a human-readable, unstructured messages describing the error
	Msg() string

	// Cause is reason for the error
	Cause() error

	// Error returns a string of the form "webrpc error <Code>: <Msg>"
	Error() string

	// Error response payload
	Payload() ErrorPayload
}

func Errorf(code ErrorCode, msgf string, args ...interface{}) Error {
	msg := fmt.Sprintf(msgf, args...)
	if IsValidErrorCode(code) {
		return &rpcErr{code: code, msg: msg}
	}
	return &rpcErr{code: ErrInternal, msg: "invalid error type " + string(code)}
}

func WrapError(code ErrorCode, cause error, format string, args ...interface{}) Error {
	msg := fmt.Sprintf(format, args...)
	if IsValidErrorCode(code) {
		return &rpcErr{code: code, msg: msg, cause: cause}
	}
	return &rpcErr{code: ErrInternal, msg: "invalid error type " + string(code), cause: cause}
}

func Failf(format string, args ...interface{}) Error {
	return Errorf(ErrFail, format, args...)
}

func WrapFailf(cause error, format string, args ...interface{}) Error {
	return WrapError(ErrFail, cause, format, args...)
}

func ErrorNotFound(format string, args ...interface{}) Error {
	return Errorf(ErrNotFound, format, args...)
}

func ErrorInvalidArgument(argument string, validationMsg string) Error {
	return Errorf(ErrInvalidArgument, argument+" "+validationMsg)
}

func ErrorRequiredArgument(argument string) Error {
	return ErrorInvalidArgument(argument, "is required")
}

func ErrorInternal(format string, args ...interface{}) Error {
	return Errorf(ErrInternal, format, args...)
}

type ErrorCode string

const (
	// Unknown error. For example when handling errors raised by APIs that do not
	// return enough error information.
	ErrUnknown ErrorCode = "unknown"

	// Fail error. General failure error type.
	ErrFail ErrorCode = "fail"

	// Canceled indicates the operation was cancelled (typically by the caller).
	ErrCanceled ErrorCode = "canceled"

	// InvalidArgument indicates client specified an invalid argument. It
	// indicates arguments that are problematic regardless of the state of the
	// system (i.e. a malformed file name, required argument, number out of range,
	// etc.).
	ErrInvalidArgument ErrorCode = "invalid argument"

	// DeadlineExceeded means operation expired before completion. For operations
	// that change the state of the system, this error may be returned even if the
	// operation has completed successfully (timeout).
	ErrDeadlineExceeded ErrorCode = "deadline exceeded"

	// NotFound means some requested entity was not found.
	ErrNotFound ErrorCode = "not found"

	// BadRoute means that the requested URL path wasn't routable to a webrpc
	// service and method. This is returned by the generated server, and usually
	// shouldn't be returned by applications. Instead, applications should use
	// NotFound or Unimplemented.
	ErrBadRoute ErrorCode = "bad route"

	// AlreadyExists means an attempt to create an entity failed because one
	// already exists.
	ErrAlreadyExists ErrorCode = "already exists"

	// PermissionDenied indicates the caller does not have permission to execute
	// the specified operation. It must not be used if the caller cannot be
	// identified (Unauthenticated).
	ErrPermissionDenied ErrorCode = "permission denied"

	// Unauthenticated indicates the request does not have valid authentication
	// credentials for the operation.
	ErrUnauthenticated ErrorCode = "unauthenticated"

	// ResourceExhausted indicates some resource has been exhausted, perhaps a
	// per-user quota, or perhaps the entire file system is out of space.
	ErrResourceExhausted ErrorCode = "resource exhausted"

	// FailedPrecondition indicates operation was rejected because the system is
	// not in a state required for the operation's execution. For example, doing
	// an rmdir operation on a directory that is non-empty, or on a non-directory
	// object, or when having conflicting read-modify-write on the same resource.
	ErrFailedPrecondition ErrorCode = "failed precondition"

	// Aborted indicates the operation was aborted, typically due to a concurrency
	// issue like sequencer check failures, transaction aborts, etc.
	ErrAborted ErrorCode = "aborted"

	// OutOfRange means operation was attempted past the valid range. For example,
	// seeking or reading past end of a paginated collection.
	//
	// Unlike InvalidArgument, this error indicates a problem that may be fixed if
	// the system state changes (i.e. adding more items to the collection).
	//
	// There is a fair bit of overlap between FailedPrecondition and OutOfRange.
	// We recommend using OutOfRange (the more specific error) when it applies so
	// that callers who are iterating through a space can easily look for an
	// OutOfRange error to detect when they are done.
	ErrOutOfRange ErrorCode = "out of range"

	// Unimplemented indicates operation is not implemented or not
	// supported/enabled in this service.
	ErrUnimplemented ErrorCode = "unimplemented"

	// Internal errors. When some invariants expected by the underlying system
	// have been broken. In other words, something bad happened in the library or
	// backend service. Do not confuse with HTTP Internal Server Error; an
	// Internal error could also happen on the client code, i.e. when parsing a
	// server response.
	ErrInternal ErrorCode = "internal"

	// Unavailable indicates the service is currently unavailable. This is a most
	// likely a transient condition and may be corrected by retrying with a
	// backoff.
	ErrUnavailable ErrorCode = "unavailable"

	// DataLoss indicates unrecoverable data loss or corruption.
	ErrDataLoss ErrorCode = "data loss"

	// ErrNone is the zero-value, is considered an empty error and should not be
	// used.
	ErrNone ErrorCode = ""
)

func HTTPStatusFromErrorCode(code ErrorCode) int {
	switch code {
	case ErrCanceled:
		return 408 // RequestTimeout
	case ErrUnknown:
		return 400 // Bad Request
	case ErrFail:
		return 422 // Unprocessable Entity
	case ErrInvalidArgument:
		return 400 // BadRequest
	case ErrDeadlineExceeded:
		return 408 // RequestTimeout
	case ErrNotFound:
		return 404 // Not Found
	case ErrBadRoute:
		return 404 // Not Found
	case ErrAlreadyExists:
		return 409 // Conflict
	case ErrPermissionDenied:
		return 403 // Forbidden
	case ErrUnauthenticated:
		return 401 // Unauthorized
	case ErrResourceExhausted:
		return 403 // Forbidden
	case ErrFailedPrecondition:
		return 412 // Precondition Failed
	case ErrAborted:
		return 409 // Conflict
	case ErrOutOfRange:
		return 400 // Bad Request
	case ErrUnimplemented:
		return 501 // Not Implemented
	case ErrInternal:
		return 500 // Internal Server Error
	case ErrUnavailable:
		return 503 // Service Unavailable
	case ErrDataLoss:
		return 500 // Internal Server Error
	case ErrNone:
		return 200 // OK
	default:
		return 0 // Invalid!
	}
}

func IsErrorCode(err error, code ErrorCode) bool {
	if rpcErr, ok := err.(Error); ok {
		if rpcErr.Code() == code {
			return true
		}
	}
	return false
}

func IsValidErrorCode(code ErrorCode) bool {
	return HTTPStatusFromErrorCode(code) != 0
}

type rpcErr struct {
	code  ErrorCode
	msg   string
	cause error
}

func (e *rpcErr) Code() ErrorCode {
	return e.code
}

func (e *rpcErr) Msg() string {
	return e.msg
}

func (e *rpcErr) Cause() error {
	return e.cause
}

func (e *rpcErr) Error() string {
	if e.cause != nil && e.cause.Error() != "" {
		if e.msg != "" {
			return fmt.Sprintf("webrpc %s error: %s -- %s", e.code, e.cause.Error(), e.msg)
		} else {
			return fmt.Sprintf("webrpc %s error: %s", e.code, e.cause.Error())
		}
	} else {
		return fmt.Sprintf("webrpc %s error: %s", e.code, e.msg)
	}
}

func (e *rpcErr) Payload() ErrorPayload {
	statusCode := HTTPStatusFromErrorCode(e.Code())
	errPayload := ErrorPayload{
		Status: statusCode,
		Code:   string(e.Code()),
		Msg:    e.Msg(),
		Error:  e.Error(),
	}
	if e.Cause() != nil {
		errPayload.Cause = e.Cause().Error()
	}
	return errPayload
}

type contextKey struct {
	name string
}

func (k *contextKey) String() string {
	return "webrpc context value " + k.name
}

var (
	// For Client
	HTTPClientRequestHeadersCtxKey = &contextKey{"HTTPClientRequestHeaders"}

	// For Server
	HTTPResponseWriterCtxKey = &contextKey{"HTTPResponseWriter"}

	HTTPRequestCtxKey = &contextKey{"HTTPRequest"}

	ServiceNameCtxKey = &contextKey{"ServiceName"}

	MethodNameCtxKey = &contextKey{"MethodName"}
)
