// sequence-api v0.4.0 c7a95904c3e083c5e5239662c725ee904ab4492a
// --
// Code generated by webrpc-gen@v0.31.0 with golang generator. DO NOT EDIT.
//
// webrpc-gen -schema=api.ridl -target=golang -pkg=api -client -out=./clients/api.gen.go
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/0xsequence/go-sequence/lib/prototyp"
)

// WebRPC description and code-gen version
func WebRPCVersion() string {
	return "v1"
}

// Schema version of your RIDL schema
func WebRPCSchemaVersion() string {
	return "v0.4.0"
}

// Schema hash generated from your RIDL schema
func WebRPCSchemaHash() string {
	return "c7a95904c3e083c5e5239662c725ee904ab4492a"
}

//
// Client interface
//

type APIClient interface {
	//
	// Runtime
	//
	Ping(ctx context.Context) (bool, error)
	Version(ctx context.Context) (*Version, error)
	RuntimeStatus(ctx context.Context) (*RuntimeStatus, error)
	Clock(ctx context.Context) (time.Time, error)
	GetSequenceContext(ctx context.Context) (*SequenceContext, error)
	//
	// Auth
	//
	// TODO: rename 'ewtString' arg to 'ethauthProof'
	GetAuthToken(ctx context.Context, ewtString string, testnetMode *bool) (bool, string, string, *User, error)
	GetAuthToken2(ctx context.Context, ewtString string, chainID string) (bool, string, string, *User, error)
	SendPasswordlessLink(ctx context.Context, email string, redirectUri string, intent string) (bool, error)
	RegisterPublicKey(ctx context.Context, publicKey *PublicKey) (bool, error)
	GetPublicKey(ctx context.Context, id string) (*PublicKey, error)
	//
	// Contacts / Friends
	//
	FriendList(ctx context.Context, nickname *string, page *Page) (*Page, []*Friend, error)
	GetFriendByAddress(ctx context.Context, friendAddress string) (bool, *Friend, error)
	SearchFriends(ctx context.Context, filterUsername string, page *Page) ([]*Friend, error)
	AddFriend(ctx context.Context, friendAddress string, optionalNickname *string) (bool, *Friend, error)
	UpdateFriendNickname(ctx context.Context, friendAddress string, nickname string) (bool, *Friend, error)
	RemoveFriend(ctx context.Context, friendAddress string) (bool, error)
	//
	// Chain-Utils
	//
	ContractCall(ctx context.Context, chainID string, contract string, inputExpr string, outputExpr string, args []string) ([]string, error)
	DecodeContractCall(ctx context.Context, callData string) (*ContractCall, error)
	LookupContractCallSelectors(ctx context.Context, selectors []string) ([][]string, error)
	//
	// User Storage
	//
	UserStorageFetch(ctx context.Context, key string) (interface{}, error)
	UserStorageSave(ctx context.Context, key string, object interface{}) (bool, error)
	UserStorageDelete(ctx context.Context, key string) (bool, error)
	UserStorageFetchAll(ctx context.Context, keys []string) (map[string]interface{}, error)
	//
	// Wallet utils
	//
	GetMoonpayLink(ctx context.Context, url string) (string, error)
	// - IsUsingGoogleMail(domain: string) => (yes: bool)
	ResolveENSAddress(ctx context.Context, ens string) (string, bool, error)
	// TODO: we can add walletContext optional in the future when we need it
	// NOTE: chainId can be either a number or canonical name
	IsValidSignature(ctx context.Context, chainId string, walletAddress string, digest string, signature string) (bool, error)
	IsValidMessageSignature(ctx context.Context, chainId string, walletAddress string, message string, signature string) (bool, error)
	IsValidTypedDataSignature(ctx context.Context, chainId string, walletAddress string, typedData interface{}, signature string) (bool, error)
	IsValidETHAuthProof(ctx context.Context, chainId string, walletAddress string, ethAuthProofString string) (bool, error)
	GetOnRampURL(ctx context.Context, chainId string) (string, error)
	TransakGetCountries(ctx context.Context) ([]*TransakCountry, error)
	TransakGetCryptoCurrencies(ctx context.Context) ([]*TransakCryptoCurrency, error)
	TransakGetFiatCurrencies(ctx context.Context) ([]*TransakFiatCurrency, error)
	TransakGetPrice(ctx context.Context, params *TransakGetPriceParams) (*TransakPrice, error)
	TransakGetSupportedNFTCheckoutChains(ctx context.Context) ([]*TransakChain, error)
	TransakGetWidgetURL(ctx context.Context, params *TransakGetWidgetURLParams) (string, error)
	//
	// Price Feed
	//
	GetCoinPrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
	GetCollectiblePrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
	//
	// Price Feed utils
	//
	GetExchangeRate(ctx context.Context, toCurrency string) (*ExchangeRate, error)
	//
	// Util / misc
	//
	MemoryStore(ctx context.Context, key string, value string) (bool, error)
	MemoryLoad(ctx context.Context, key string) (string, error)
	//
	// Legacy
	//
	GetInviteInfo(ctx context.Context) (*InviteInfo, error)
	// NOTE: we're still using this from SW-API to Sequence-API to claim invite code
	IsValidAccessCode(ctx context.Context, accessCode string) (bool, error)
	InternalClaimAccessCode(ctx context.Context, address string, accessCode string) (bool, error)
	// Utils
	BlockNumberAtTime(ctx context.Context, chainId uint64, timestamps []uint64) ([]uint64, error)
	//
	// Paper
	// TODO: deprecate in the future
	//
	PaperSessionSecret(ctx context.Context, chainName string, contractAddress string, paramsJson string, contractType string) (string, error)
	PaperSessionSecret2(ctx context.Context, chainName string, contractAddress string, paramsJson string, abi string) (string, error)
	//
	// Linked wallets (v0 -- simple support)
	//
	LinkWallet(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, linkedWalletAddress string, linkedWalletMessage string, linkedWalletSignature string, signatureChainId string, linkedWalletType *string) (bool, error)
	GetLinkedWallets(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, signatureChainId string) ([]*LinkedWallet, error)
	RemoveLinkedWallet(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, linkedWalletAddress string, signatureChainId string) (bool, error)
	// NOTE: these methods are deprecated, please do not use them. We may resurface them in the future, but just wanted
	// to be clear, they are not necessary for our linked wallets.
	GenerateWaaSVerificationURL(ctx context.Context, walletAddress string) (string, string, error)
	ValidateWaaSVerificationNonce(ctx context.Context, nonce string, signature string, sessionId string, chainId string) (string, error)
	//
	//
	// WaaS child wallet adoption
	//
	ListAdoptedWallets(ctx context.Context, page *Page) (*Page, []*AdoptedChildWallet, error)
	GetLifiChains(ctx context.Context) ([]uint64, error)
	GetLifiTokens(ctx context.Context, chainIds []uint64) ([]*Token, error)
	// All parameters except `params` are deprecated.
	// Use only the `params` object to pass values.
	GetLifiSwapRoutes(ctx context.Context, params *GetLifiSwapRouteParams) ([]*LifiSwapRoute, error)
	GetLifiSwapQuote(ctx context.Context, params *GetLifiSwapQuoteParams) (*LifiSwapQuote, error)
	//
	// Chain abstraction
	//
	GetIntentCallsPayloads(ctx context.Context, userAddress string, destinationChainId uint64, destinationTokenAddress string, destinationTokenAmount string, destinationToAddress string, originChainId uint64, originTokenAddress string, originTokenAmount string, destinationCallData *string, destinationCallValue *string, provider *string, addressOverrides *AddressOverrides, destinationSalt *string, takerFee *TakerFee, slippageTolerance *float64, tradeType *TradeType) ([]*IntentCallsPayload, []*IntentPrecondition, []*MetaTxn, *TrailsFee, *IntentQuote, map[string]string, string, string, error)
	CommitIntentConfig(ctx context.Context, originIntentAddress string, destinationIntentAddress string, mainSigner string, calls []*IntentCallsPayload, preconditions []*IntentPrecondition, addressOverrides *AddressOverrides) (*IntentConfig, error)
	GetIntentConfig(ctx context.Context, intentAddress string) (*IntentConfig, error)
	//
	// Inventory, payments and management
	//
	ListCurrencyGroups(ctx context.Context) ([]*CurrencyGroup, error)
	AddOffchainInventory(ctx context.Context, inventory *OffchainInventory) (uint64, error)
	GetOffchainInventory(ctx context.Context, inventoryId uint64) (*OffchainInventory, error)
	ListOffchainInventories(ctx context.Context, projectId uint64) ([]*OffchainInventory, error)
	UpdateOffchainInventory(ctx context.Context, inventory *OffchainInventory) error
	DeleteOffchainInventory(ctx context.Context, inventoryId uint64) (bool, error)
	RequestOffchainPayment(ctx context.Context, inventoryId uint64, recipient string, chainId *uint64, tokenAddress *string) (*PaymentResponse, error)
	ListOffchainPayments(ctx context.Context, inventoryId uint64, page *Page) (*Page, []*OffchainPayment, error)
	//
	// Packs
	//
	SavePack(ctx context.Context, pack *Pack) (string, error)
	GetPack(ctx context.Context, contractAddress string, packId string, chainId uint64) (*Pack, error)
	GetPackIds(ctx context.Context, contractAddress string, chainId uint64) ([]string, error)
	DeletePack(ctx context.Context, contractAddress string, packId string, chainId uint64) (bool, error)
	UpdatePackContent(ctx context.Context, pack *Pack) (string, error)
	GetRevealTxData(ctx context.Context, contractAddress string, packId string, chainId uint64, userAddress string) (string, error)
	CheckoutOptionsPrimary(ctx context.Context, chainId uint64, wallet string, contractAddress string, collectionAddress string, params []*CheckoutOptionsPrimaryParams) (*CheckoutOptions, error)
	CheckoutOptionsSecondary(ctx context.Context, chainId uint64, wallet string, params []*CheckoutOptionsSecondaryParams) (*CheckoutOptions, error)
	CheckoutOptionsGetTransakContractID(ctx context.Context, chainId uint64, contractAddress string) (string, error)
	FortePayCreateIntent(ctx context.Context, intent *FortePayCreateIntent) (*FortePayIntent, error)
	FortePayGetPaymentStatuses(ctx context.Context, paymentIntentIds []string) ([]*FortePaymentStatus, error)
	//
	// CCTP
	//
	GetCCTPTransfer(ctx context.Context, id string) (*CCTPTransfer, error)
	QueueCCTPTransfer(ctx context.Context, sourceTxHash *string, metaTxHash *string, sourceChainId uint64, destinationChainId uint64) (*CCTPTransfer, error)
	//
	// Intent Machine Worker
	//
	QueueIntentConfigExecution(ctx context.Context, intentConfigId uint64) (bool, error)
	GetIntentConfigExecutionStatus(ctx context.Context, intentConfigId uint64) (string, error)
	ListIntentConfigs(ctx context.Context, page *Page, executionStatus *string) (*Page, []*IntentConfig, error)
	QueueMetaTxnReceipt(ctx context.Context, metaTxID string) (bool, error)
}

//
// Schema types
//

type SortOrder uint32

const (
	SortOrder_DESC SortOrder = 0
	SortOrder_ASC  SortOrder = 1
)

var SortOrder_name = map[uint32]string{
	0: "DESC",
	1: "ASC",
}

var SortOrder_value = map[string]uint32{
	"DESC": 0,
	"ASC":  1,
}

func (x SortOrder) String() string {
	return SortOrder_name[uint32(x)]
}

func (x SortOrder) MarshalText() ([]byte, error) {
	return []byte(SortOrder_name[uint32(x)]), nil
}

func (x *SortOrder) UnmarshalText(b []byte) error {
	*x = SortOrder(SortOrder_value[string(b)])
	return nil
}

func (x *SortOrder) Is(values ...SortOrder) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type GetLifiSwapRouteDirection uint8

const (
	GetLifiSwapRouteDirection_to   GetLifiSwapRouteDirection = 1
	GetLifiSwapRouteDirection_from GetLifiSwapRouteDirection = 2
)

var GetLifiSwapRouteDirection_name = map[uint8]string{
	1: "to",
	2: "from",
}

var GetLifiSwapRouteDirection_value = map[string]uint8{
	"to":   1,
	"from": 2,
}

func (x GetLifiSwapRouteDirection) String() string {
	return GetLifiSwapRouteDirection_name[uint8(x)]
}

func (x GetLifiSwapRouteDirection) MarshalText() ([]byte, error) {
	return []byte(GetLifiSwapRouteDirection_name[uint8(x)]), nil
}

func (x *GetLifiSwapRouteDirection) UnmarshalText(b []byte) error {
	*x = GetLifiSwapRouteDirection(GetLifiSwapRouteDirection_value[string(b)])
	return nil
}

func (x *GetLifiSwapRouteDirection) Is(values ...GetLifiSwapRouteDirection) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TokenType uint8

const (
	TokenType_ERC20   TokenType = 0
	TokenType_ERC721  TokenType = 1
	TokenType_ERC1155 TokenType = 2
)

var TokenType_name = map[uint8]string{
	0: "ERC20",
	1: "ERC721",
	2: "ERC1155",
}

var TokenType_value = map[string]uint8{
	"ERC20":   0,
	"ERC721":  1,
	"ERC1155": 2,
}

func (x TokenType) String() string {
	return TokenType_name[uint8(x)]
}

func (x TokenType) MarshalText() ([]byte, error) {
	return []byte(TokenType_name[uint8(x)]), nil
}

func (x *TokenType) UnmarshalText(b []byte) error {
	*x = TokenType(TokenType_value[string(b)])
	return nil
}

func (x *TokenType) Is(values ...TokenType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TransakBuySell uint8

const (
	TransakBuySell_UNKNOWN TransakBuySell = 0
	TransakBuySell_BUY     TransakBuySell = 1
	TransakBuySell_SELL    TransakBuySell = 2
)

var TransakBuySell_name = map[uint8]string{
	0: "UNKNOWN",
	1: "BUY",
	2: "SELL",
}

var TransakBuySell_value = map[string]uint8{
	"UNKNOWN": 0,
	"BUY":     1,
	"SELL":    2,
}

func (x TransakBuySell) String() string {
	return TransakBuySell_name[uint8(x)]
}

func (x TransakBuySell) MarshalText() ([]byte, error) {
	return []byte(TransakBuySell_name[uint8(x)]), nil
}

func (x *TransakBuySell) UnmarshalText(b []byte) error {
	*x = TransakBuySell(TransakBuySell_value[string(b)])
	return nil
}

func (x *TransakBuySell) Is(values ...TransakBuySell) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TradeType string

const (
	TradeType_EXACT_INPUT  TradeType = "EXACT_INPUT"
	TradeType_EXACT_OUTPUT TradeType = "EXACT_OUTPUT"
)

func (x TradeType) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *TradeType) UnmarshalText(b []byte) error {
	*x = TradeType(string(b))
	return nil
}

func (x *TradeType) Is(values ...TradeType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type CheckoutOptionCrypto uint32

const (
	CheckoutOptionCrypto_none      CheckoutOptionCrypto = 0
	CheckoutOptionCrypto_partially CheckoutOptionCrypto = 1
	CheckoutOptionCrypto_all       CheckoutOptionCrypto = 2
)

var CheckoutOptionCrypto_name = map[uint32]string{
	0: "none",
	1: "partially",
	2: "all",
}

var CheckoutOptionCrypto_value = map[string]uint32{
	"none":      0,
	"partially": 1,
	"all":       2,
}

func (x CheckoutOptionCrypto) String() string {
	return CheckoutOptionCrypto_name[uint32(x)]
}

func (x CheckoutOptionCrypto) MarshalText() ([]byte, error) {
	return []byte(CheckoutOptionCrypto_name[uint32(x)]), nil
}

func (x *CheckoutOptionCrypto) UnmarshalText(b []byte) error {
	*x = CheckoutOptionCrypto(CheckoutOptionCrypto_value[string(b)])
	return nil
}

func (x *CheckoutOptionCrypto) Is(values ...CheckoutOptionCrypto) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type CheckoutOptionNFTCheckoutProvider uint32

const (
	CheckoutOptionNFTCheckoutProvider_unknown CheckoutOptionNFTCheckoutProvider = 0
	CheckoutOptionNFTCheckoutProvider_transak CheckoutOptionNFTCheckoutProvider = 1
)

var CheckoutOptionNFTCheckoutProvider_name = map[uint32]string{
	0: "unknown",
	1: "transak",
}

var CheckoutOptionNFTCheckoutProvider_value = map[string]uint32{
	"unknown": 0,
	"transak": 1,
}

func (x CheckoutOptionNFTCheckoutProvider) String() string {
	return CheckoutOptionNFTCheckoutProvider_name[uint32(x)]
}

func (x CheckoutOptionNFTCheckoutProvider) MarshalText() ([]byte, error) {
	return []byte(CheckoutOptionNFTCheckoutProvider_name[uint32(x)]), nil
}

func (x *CheckoutOptionNFTCheckoutProvider) UnmarshalText(b []byte) error {
	*x = CheckoutOptionNFTCheckoutProvider(CheckoutOptionNFTCheckoutProvider_value[string(b)])
	return nil
}

func (x *CheckoutOptionNFTCheckoutProvider) Is(values ...CheckoutOptionNFTCheckoutProvider) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type CheckoutOptionOnRampProvider uint32

const (
	CheckoutOptionOnRampProvider_unknown CheckoutOptionOnRampProvider = 0
	CheckoutOptionOnRampProvider_transak CheckoutOptionOnRampProvider = 1
)

var CheckoutOptionOnRampProvider_name = map[uint32]string{
	0: "unknown",
	1: "transak",
}

var CheckoutOptionOnRampProvider_value = map[string]uint32{
	"unknown": 0,
	"transak": 1,
}

func (x CheckoutOptionOnRampProvider) String() string {
	return CheckoutOptionOnRampProvider_name[uint32(x)]
}

func (x CheckoutOptionOnRampProvider) MarshalText() ([]byte, error) {
	return []byte(CheckoutOptionOnRampProvider_name[uint32(x)]), nil
}

func (x *CheckoutOptionOnRampProvider) UnmarshalText(b []byte) error {
	*x = CheckoutOptionOnRampProvider(CheckoutOptionOnRampProvider_value[string(b)])
	return nil
}

func (x *CheckoutOptionOnRampProvider) Is(values ...CheckoutOptionOnRampProvider) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type CheckoutOptionSwapProvider uint32

const (
	CheckoutOptionSwapProvider_unknown CheckoutOptionSwapProvider = 0
	CheckoutOptionSwapProvider_lifi    CheckoutOptionSwapProvider = 1
)

var CheckoutOptionSwapProvider_name = map[uint32]string{
	0: "unknown",
	1: "lifi",
}

var CheckoutOptionSwapProvider_value = map[string]uint32{
	"unknown": 0,
	"lifi":    1,
}

func (x CheckoutOptionSwapProvider) String() string {
	return CheckoutOptionSwapProvider_name[uint32(x)]
}

func (x CheckoutOptionSwapProvider) MarshalText() ([]byte, error) {
	return []byte(CheckoutOptionSwapProvider_name[uint32(x)]), nil
}

func (x *CheckoutOptionSwapProvider) UnmarshalText(b []byte) error {
	*x = CheckoutOptionSwapProvider(CheckoutOptionSwapProvider_value[string(b)])
	return nil
}

func (x *CheckoutOptionSwapProvider) Is(values ...CheckoutOptionSwapProvider) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type Version struct {
	WebrpcVersion string `json:"webrpcVersion"`
	SchemaVersion string `json:"schemaVersion"`
	SchemaHash    string `json:"schemaHash"`
	AppVersion    string `json:"appVersion"`
}

type RuntimeStatus struct {
	// overall status, true/false
	HealthOK       bool                       `json:"healthOK"`
	StartTime      time.Time                  `json:"startTime"`
	Uptime         uint64                     `json:"uptime"`
	Ver            string                     `json:"ver"`
	Branch         string                     `json:"branch"`
	CommitHash     string                     `json:"commitHash"`
	Checks         *RuntimeChecks             `json:"checks"`
	NumTxnsRelayed map[string]*NumTxnsRelayed `json:"numTxnsRelayed"`
}

type NumTxnsRelayed struct {
	ChainID uint64 `json:"chainID"`
	Prev    uint64 `json:"prev"`
	Current uint64 `json:"current"`
	Period  uint64 `json:"period"`
}

type RuntimeChecks struct {
}

type SequenceContext struct {
	Factory              string `json:"factory"`
	MainModule           string `json:"mainModule"`
	MainModuleUpgradable string `json:"mainModuleUpgradable"`
	GuestModule          string `json:"guestModule"`
	Utils                string `json:"utils"`
}

type PublicKey struct {
	ID string `json:"id" db:"id"`
	X  string `json:"x" db:"x"`
	Y  string `json:"y" db:"y"`
}

// Users
type User struct {
	Address            prototyp.Hash `json:"address" db:"address"`
	Username           string        `json:"username" db:"username"`
	NormalizedUsername string        `json:"-" db:"normalized_username"`
	Avatar             string        `json:"avatar" db:"avatar"`
	Bio                string        `json:"bio" db:"bio"`
	Location           string        `json:"location" db:"location"`
	Locale             string        `json:"locale" db:"locale"`
	Backup             *bool         `json:"backup,omitempty" db:"-"`
	BackupConfirmed    *bool         `json:"backupConfirmed,omitempty" db:"-"`
	MaxInvites         *uint32       `json:"maxInvites" db:"max_invites"`
	UpdatedAt          *time.Time    `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt          *time.Time    `json:"createdAt,omitempty" db:"created_at,omitempty"`
	SysAdmin           bool          `json:"-" db:"sys_admin"`
}

// Wallet Backup
type WalletBackup struct {
	AccountAddress  prototyp.Hash `json:"accountAddress" db:"account_address"`
	SecretHash      string        `json:"secretHash" db:"secret_hash"`
	EncryptedWallet string        `json:"encryptedWallet" db:"encrypted_wallet"`
	// userConfirmed is a flag that the user tells us they've backed up
	// their wallet mnemonic for future recovery. It's just a user-experience field
	// so we can nag them if they haven't confirmed yet.
	UserConfirmed bool       `json:"userConfirmed" db:"user_confirmed"`
	UpdatedAt     *time.Time `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt     *time.Time `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// Friends
type Friend struct {
	ID            uint64        `json:"id" db:"id,omitempty"`
	UserAddress   prototyp.Hash `json:"userAddress" db:"user_address"`
	FriendAddress prototyp.Hash `json:"friendAddress" db:"friend_address"`
	// Nickname allows the user to assign a friend a label, useful for the case
	// when that friend doesn't have an arcadeum user account
	Nickname  string     `json:"nickname" db:"nickname"`
	User      *User      `json:"user" db:"-"`
	CreatedAt *time.Time `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// From: `0xsequence/relayer`: https://github.com/0xsequence/relayer/blob/2c695b820970c68c57bfe71810f469412cdec675/proto/relayer.ridl#L502
// TODO: rename this to MetaTxnRaw (eventually), we can leave it for now to not break compat
// or name it, MetaTxnArgs ..?
type MetaTxn struct {
	ID            string          `json:"id"`
	ChainId       prototyp.BigInt `json:"chainId"`
	WalletAddress string          `json:"walletAddress" db:"wallet_address"`
	// TODO (later): rename this to `to: string`
	Contract string `json:"contract" db:"to_address"`
	// TODO: rename to 'execdata'
	Input string `json:"input" db:"tx_data"`
}

type Call struct {
	To              prototyp.Hash   `json:"to"`
	Value           prototyp.BigInt `json:"value"`
	Data            prototyp.Hash   `json:"data"`
	GasLimit        prototyp.BigInt `json:"gasLimit"`
	DelegateCall    *bool           `json:"delegateCall"`
	OnlyFallback    *bool           `json:"onlyFallback"`
	BehaviorOnError *uint8          `json:"behaviorOnError"`
}

type IntentCallsPayload struct {
	ChainId prototyp.BigInt `json:"chainId"`
	Space   prototyp.BigInt `json:"space"`
	Nonce   prototyp.BigInt `json:"nonce"`
	Calls   []*Call         `json:"calls"`
}

// IntentConfig
type IntentConfig struct {
	ID                       uint64              `json:"id" db:"id,omitempty"`
	ConfigHash               prototyp.Hash       `json:"configHash" db:"config_hash"`
	OriginIntentAddress      prototyp.Hash       `json:"originIntentAddress" db:"origin_intent_address"`
	DestinationIntentAddress prototyp.Hash       `json:"destinationIntentAddress" db:"destination_intent_address"`
	MainSigner               prototyp.Hash       `json:"mainSigner" db:"main_signer"`
	Calls                    prototyp.JSONString `json:"calls" db:"calls"`
	Preconditions            prototyp.JSONString `json:"preconditions" db:"preconditions"`
	ExecutionStatus          *string             `json:"executionStatus" db:"execution_status,omitempty"`
	MetaTxnID                *string             `json:"metaTxnId" db:"meta_txn_id,omitempty"`
	TxnHash                  *string             `json:"txnHash" db:"txn_hash,omitempty"`
	UpdatedAt                *time.Time          `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt                *time.Time          `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// MetaTxnReceipt
type MetaTxnReceipt struct {
	MetaTxID     string  `json:"metaTxID" db:"meta_tx_id"`
	Status       string  `json:"status" db:"status"`
	TxnReceipt   *string `json:"txnReceipt" db:"txn_receipt"`
	RevertReason *string `json:"revertReason" db:"revert_reason"`
}

// InviteCode
type InviteCode struct {
	Code         string             `json:"-" db:"code"`
	Source       string             `json:"-" db:"source"`
	UsesLeft     uint32             `json:"usesLeft" db:"uses_left"`
	OwnerAccount prototyp.HashMaybe `json:"ownerAccount" db:"owner_account"`
	Email        *string            `json:"email" db:"email"`
	Url          string             `json:"url"`
	CreatedAt    *time.Time         `json:"createdAt,omitempty" db:"created_at,omitempty"`
	ExpiresAt    *time.Time         `json:"expiresAt,omitempty" db:"expires_at,omitempty"`
}

// InviteCode Account
type InviteCodeAccount struct {
	Code                 string        `json:"-" db:"code"`
	ClaimedByUserAddress prototyp.Hash `json:"claimedByUserAddress" db:"claimed_by_user_address"`
	ClaimedAt            *time.Time    `json:"claimedAt,omitempty" db:"claimed_at,omitempty"`
}

// Invite info
type InviteInfo struct {
	ExpiryInHours uint32        `json:"expiryInHours"`
	Max           uint32        `json:"max"`
	Invites       []*InviteCode `json:"invites"`
}

type ContractCall struct {
	Signature string            `json:"signature"`
	Function  string            `json:"function"`
	Args      []*TupleComponent `json:"args"`
}

type TupleComponent struct {
	Name  *string     `json:"name"`
	Type  string      `json:"type"`
	Value interface{} `json:"value"`
}

type AddressOverrides struct {
	TrailsLiFiSapientSignerAddress   *string `json:"trailsLiFiSapientSignerAddress"`
	TrailsRelaySapientSignerAddress  *string `json:"trailsRelaySapientSignerAddress"`
	TrailsCCTPV2SapientSignerAddress *string `json:"trailsCCTPV2SapientSignerAddress"`
}

type TakerFee struct {
	Address prototyp.Hash `json:"address"`
	Bps     uint64        `json:"bps"`
}

type OriginCall struct {
	ChainId          prototyp.BigInt `json:"chainId"`
	To               string          `json:"to"`
	TransactionData  string          `json:"transactionData"`
	TransactionValue prototyp.BigInt `json:"transactionValue"`
}

type IntentPrecondition struct {
	Type    string          `json:"type"`
	ChainId prototyp.BigInt `json:"chainId"`
	Data    interface{}     `json:"data"`
}

type UserStorage struct {
	UserAddress prototyp.Hash       `json:"userAddress" db:"user_address"`
	Key         string              `json:"key"`
	Value       prototyp.JSONString `json:"value"`
}

type Token struct {
	ChainId         uint64        `json:"chainId"`
	ContractAddress prototyp.Hash `json:"contractAddress"`
	TokenId         *string       `json:"tokenId"`
}

type Price struct {
	Value    float64 `json:"value"`
	Currency string  `json:"currency"`
}

type TokenPrice struct {
	Token          *Token     `json:"token"`
	Price          *Price     `json:"price"`
	Price24hChange *Price     `json:"price24hChange"`
	Price24hVol    *Price     `json:"price24hVol"`
	FloorPrice     *Price     `json:"floorPrice,omitempty"`
	BuyPrice       *Price     `json:"buyPrice,omitempty"`
	SellPrice      *Price     `json:"sellPrice,omitempty"`
	UpdatedAt      *time.Time `json:"updatedAt"`
}

type ExchangeRate struct {
	Name         string  `json:"name"`
	Symbol       string  `json:"symbol"`
	Value        float64 `json:"value"`
	VsCurrency   string  `json:"vsCurrency"`
	CurrencyType string  `json:"currencyType"`
}

type LinkedWallet struct {
	ID                  uint64        `json:"id" db:"id,omitempty"`
	WalletType          *string       `json:"walletType" db:"wallet_type"`
	WalletAddress       prototyp.Hash `json:"walletAddress" db:"wallet_address"`
	LinkedWalletAddress prototyp.Hash `json:"linkedWalletAddress" db:"linked_wallet_address"`
	CreatedAt           *time.Time    `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// TOOD: refactor, we should be returning a cursor always..
// see indexer/indexer.ridl Page object..
//
// ---
//
// Page represents a results page. This can be used both to request a page and
// to store the state of a page.
type Page struct {
	// Common for both numbered pages and cursor: Number of items per page
	// TODO: REMOVE..
	PageSize *uint32 `json:"pageSize"`
	// Numbered pages: Page number, this is multiplied by the value of the <pageSize> parameter.
	// TODO: REMOVE..
	Page *uint32 `json:"page"`
	// Number of total items on this query.
	// TODO: REMOVE..
	TotalRecords *uint64 `json:"totalRecords"`
	// Cursor: column to compare before/after to
	Column *string `json:"column"`
	// Cursor: return column < before - include to get previous page
	Before *interface{} `json:"before"`
	// Cursor: return column > after - include to get next page
	After *interface{} `json:"after"`
	// Sorting filter
	Sort []*SortBy `json:"sort"`
	// Indicates if there are more results available
	More *bool `json:"more,omitempty"`
}

type SortBy struct {
	Column string    `json:"column"`
	Order  SortOrder `json:"order"`
}

type LifiToken struct {
	ChainID  uint64           `json:"chainId"`
	Address  string           `json:"address"`
	Symbol   string           `json:"symbol"`
	Name     string           `json:"name"`
	Decimals uint32           `json:"decimals"`
	PriceUSD float64          `json:"priceUsd"`
	Price    *prototyp.BigInt `json:"price"`
	CoinKey  string           `json:"coinKey"`
	LogoURI  string           `json:"logoUri"`
}

type GetLifiSwapRouteParams struct {
	Direction GetLifiSwapRouteDirection `json:"direction"`
	// Required
	ChainID uint64 `json:"chainId"`
	// Required
	WalletAddress prototyp.Hash `json:"walletAddress"`
	// Required
	TokenAddress prototyp.Hash `json:"tokenAddress"`
	TokenAmount  string        `json:"tokenAmount"`
}

type LifiSwapRoute struct {
	FromChainID uint64       `json:"fromChainId"`
	ToChainID   uint64       `json:"toChainId"`
	FromTokens  []*LifiToken `json:"fromTokens"`
	ToTokens    []*LifiToken `json:"toTokens"`
}

type GetLifiSwapQuoteParams struct {
	// Required
	ChainID uint64 `json:"chainId"`
	// Required
	WalletAddress prototyp.Hash `json:"walletAddress"`
	// Required
	FromTokenAddress prototyp.Hash `json:"fromTokenAddress"`
	// Required
	ToTokenAddress prototyp.Hash `json:"toTokenAddress"`
	// Define either 'fromTokenAmount' or 'toTokenAmount', but not both
	FromTokenAmount *string `json:"fromTokenAmount"`
	// Define either 'fromTokenAmount' or 'toTokenAmount', but not both
	ToTokenAmount  *string `json:"toTokenAmount"`
	IncludeApprove bool    `json:"includeApprove"`
	// Basis point - 100 bps = 1%
	SlippageBPS uint64 `json:"slippageBps"`
}

type LifiSwapQuote struct {
	CurrencyAddress prototyp.Hash   `json:"currencyAddress"`
	CurrencyBalance prototyp.BigInt `json:"currencyBalance"`
	Price           prototyp.BigInt `json:"price"`
	// Guaranteed price for the swap (incl slippage).
	MaxPrice prototyp.BigInt `json:"maxPrice"`
	// to must be approved to access maxPrice of currencyAddress for the sender
	To               prototyp.Hash   `json:"to"`
	TransactionData  string          `json:"transactionData"`
	TransactionValue prototyp.BigInt `json:"transactionValue"`
	// Supplied when includeApprove is true
	ApproveData string          `json:"approveData"`
	Amount      prototyp.BigInt `json:"amount"`
	AmountMin   prototyp.BigInt `json:"amountMin"`
}

// Cross chain matching tokens
type CurrencyGroup struct {
	Name   string                `json:"name" db:"name"`
	Tokens []*CurrencyGroupToken `json:"tokens"`
}

type CurrencyGroupToken struct {
	ChainID      uint64        `json:"chainId" db:"chain_id"`
	TokenAddress prototyp.Hash `json:"tokenAddress" db:"token_address"`
}

type OffchainInventory struct {
	ID                  uint64        `json:"id" db:"id,omitempty"`
	ProjectID           uint64        `json:"projectId" db:"project_id"`
	ChainID             uint64        `json:"chainId" db:"chain_id"`
	ExternalProductID   string        `json:"externalProductId" db:"external_product_id"`
	PaymentTokenAddress prototyp.Hash `json:"paymentTokenAddress" db:"payment_token_address"`
	PaymentTokenType    TokenType     `json:"paymentTokenType" db:"payment_token_type"`
	PaymentTokenID      uint64        `json:"paymentTokenId" db:"payment_token_id"`
	PaymentAmount       uint64        `json:"paymentAmount" db:"payment_amount"`
	PaymentRecipient    prototyp.Hash `json:"paymentRecipient" db:"payment_recipient"`
	ChainedCallAddress  prototyp.Hash `json:"chainedCallAddress" db:"chained_call_address"`
	// product recipient address is added as the first argument (after selector)
	ChainedCallData         *string    `json:"chainedCallData" db:"chained_call_data"`
	AllowCrossChainPayments *bool      `json:"allowCrossChainPayments" db:"allow_cross_chain_payments"`
	CallbackURL             *string    `json:"callbackURL" db:"callback_url,omitempty"`
	CreatedAt               *time.Time `json:"createdAt" db:"created_at,omitempty"`
	DeletedAt               *time.Time `json:"-" db:"deleted_at,omitempty"`
}

type CCTPTransfer struct {
	ID                 string    `json:"id"`
	SourceTxHash       string    `json:"sourceTxHash"`
	SourceChainID      uint64    `json:"sourceChainId"`
	DestinationChainID uint64    `json:"destinationChainId"`
	Message            string    `json:"message"`
	Attestation        string    `json:"attestation"`
	Status             string    `json:"status"`
	CreatedAt          time.Time `json:"createdAt"`
	UpdatedAt          time.Time `json:"updatedAt"`
}

type OffchainPayment struct {
	ID                  uint64        `json:"id" db:"id,omitempty"`
	OffchainInventoryID uint64        `json:"offchainInventoryId" db:"offchain_inventory_id"`
	ProductRecipient    prototyp.Hash `json:"productRecipient" db:"product_recipient"`
	PaymentChainID      uint64        `json:"paymentChainId" db:"payment_chain_id"`
	PaymentTokenAddress prototyp.Hash `json:"paymentTokenAddress" db:"payment_token_address"`
	Expiration          *time.Time    `json:"expiration" db:"expiration"`
	CreatedAt           *time.Time    `json:"createdAt" db:"created_at"`
	CompletedAt         *time.Time    `json:"completedAt" db:"completed_at"`
	ProcessedAt         *time.Time    `json:"processedAt" db:"processed_at"`
}

type PaymentResponse struct {
	PaymentID           uint64        `json:"paymentId"`
	OffchainInventoryID uint64        `json:"offchainInventoryId"`
	ChainID             uint64        `json:"chainId"`
	ExternalProductID   string        `json:"externalProductId"`
	PaymentTokenAddress prototyp.Hash `json:"paymentTokenAddress"`
	PaymentTokenType    TokenType     `json:"paymentTokenType"`
	PaymentTokenID      uint64        `json:"paymentTokenId"`
	PaymentTotal        uint64        `json:"paymentTotal"`
	Expiration          *time.Time    `json:"expiration"`
	Signature           string        `json:"signature"`
	TxTo                prototyp.Hash `json:"txTo"`
	TxData              string        `json:"txData"`
}

type AdoptedChildWallet struct {
	Address string `json:"address"`
}

type Pack struct {
	ID              uint64         `json:"id" db:"id,omitempty"`
	ChainID         uint64         `json:"chainId" db:"chain_id"`
	ProjectID       uint64         `json:"projectId,omitempty" db:"project_id"`
	ContractAddress prototyp.Hash  `json:"contractAddress" db:"contract_address"`
	PackID          string         `json:"packId" db:"pack_id"`
	Content         []*PackContent `json:"content" db:"content"`
	CreatedAt       *time.Time     `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

type PackContent struct {
	TokenAddresses []string   `json:"tokenAddresses"`
	IsERC721       []bool     `json:"isERC721"`
	TokenIds       [][]string `json:"tokenIds"`
	Amounts        [][]string `json:"amounts"`
}

type TransakCountry struct {
	Alpha2             string            `json:"alpha2"`
	Alpha3             string            `json:"alpha3"`
	IsAllowed          bool              `json:"isAllowed"`
	IsLightKycAllowed  bool              `json:"isLightKycAllowed"`
	Name               string            `json:"name"`
	CurrencyCode       string            `json:"currencyCode"`
	SupportedDocuments []string          `json:"supportedDocuments"`
	Partners           []*TransakPartner `json:"partners"`
	States             []*TransakState   `json:"states"`
}

type TransakPartner struct {
	Name          string `json:"name"`
	IsCardPayment bool   `json:"isCardPayment"`
	CurrencyCode  string `json:"currencyCode"`
}

type TransakState struct {
	Code      string `json:"code"`
	Name      string `json:"name"`
	IsAllowed bool   `json:"isAllowed"`
}

type TransakCryptoCurrency struct {
	ID                        string                        `json:"id"`
	CoinID                    string                        `json:"coinID"`
	Address                   string                        `json:"address"`
	AddressAdditionalData     interface{}                   `json:"addressAdditionalData"`
	CreatedAt                 time.Time                     `json:"createdAt"`
	Decimals                  int                           `json:"decimals"`
	Image                     *TransakCryptoCurrencyImage   `json:"image"`
	IsAllowed                 bool                          `json:"isAllowed"`
	IsPopular                 bool                          `json:"isPopular"`
	IsStable                  bool                          `json:"isStable"`
	Name                      string                        `json:"name"`
	RoundOff                  int                           `json:"roundOff"`
	Symbol                    string                        `json:"symbol"`
	IsIgnorePriceVerification bool                          `json:"isIgnorePriceVerification"`
	ImageBk                   *TransakCryptoCurrencyImage   `json:"imageBk"`
	KycCountriesNotSupported  []string                      `json:"kycCountriesNotSupported"`
	Network                   *TransakCryptoCurrencyNetwork `json:"network"`
	UniqueID                  string                        `json:"uniqueID"`
	TokenType                 string                        `json:"tokenType"`
	TokenIdentifier           string                        `json:"tokenIdentifier"`
	IsPayInAllowed            bool                          `json:"isPayInAllowed"`
	IsSuspended               bool                          `json:"isSuspended"`
}

type TransakCryptoCurrencyImage struct {
	Large string `json:"large"`
	Small string `json:"small"`
	Thumb string `json:"thumb"`
}

type TransakCryptoCurrencyNetwork struct {
	Name                       string        `json:"name"`
	FiatCurrenciesNotSupported []interface{} `json:"fiatCurrenciesNotSupported"`
	ChainID                    string        `json:"chainID"`
}

type TransakCryptoCurrencyNetworkFiatNotSupported struct {
	FiatCurrency  string `json:"fiatCurrency"`
	PaymentMethod string `json:"paymentMethod"`
}

type TransakFiatCurrency struct {
	Symbol               string                              `json:"symbol"`
	SupportingCountries  []string                            `json:"supportingCountries"`
	LogoSymbol           string                              `json:"logoSymbol"`
	Name                 string                              `json:"name"`
	PaymentOptions       []*TransakFiatCurrencyPaymentOption `json:"paymentOptions"`
	IsPopular            bool                                `json:"isPopular"`
	IsAllowed            bool                                `json:"isAllowed"`
	RoundOff             int                                 `json:"roundOff"`
	IsPayOutAllowed      bool                                `json:"isPayOutAllowed"`
	DefaultCountryForNFT string                              `json:"defaultCountryForNFT"`
	Icon                 string                              `json:"icon"`
	DisplayMessage       string                              `json:"displayMessage"`
}

type TransakFiatCurrencyPaymentOption struct {
	Name                      string   `json:"name"`
	ID                        string   `json:"id"`
	IsNftAllowed              bool     `json:"isNftAllowed"`
	IsNonCustodial            bool     `json:"isNonCustodial"`
	ProcessingTime            string   `json:"processingTime"`
	DisplayText               bool     `json:"displayText"`
	Icon                      string   `json:"icon"`
	LimitCurrency             string   `json:"limitCurrency"`
	IsActive                  bool     `json:"isActive"`
	Provider                  string   `json:"provider"`
	MaxAmount                 int      `json:"maxAmount"`
	MinAmount                 int      `json:"minAmount"`
	DefaultAmount             int      `json:"defaultAmount"`
	IsConverted               bool     `json:"isConverted"`
	VisaPayoutCountries       []string `json:"visaPayoutCountries"`
	MastercardPayoutCountries []string `json:"mastercardPayoutCountries"`
	IsPayOutAllowed           bool     `json:"isPayOutAllowed"`
	MinAmountForPayOut        int      `json:"minAmountForPayOut"`
	MaxAmountForPayOut        int      `json:"maxAmountForPayOut"`
	DefaultAmountForPayOut    int      `json:"defaultAmountForPayOut"`
}

type TransakPrice struct {
	QuoteID                 string                      `json:"quoteID"`
	ConversionPrice         float64                     `json:"conversionPrice"`
	MarketConversionPrice   float64                     `json:"marketConversionPrice"`
	Slippage                int                         `json:"slippage"`
	FiatCurrency            string                      `json:"fiatCurrency"`
	CryptoCurrency          string                      `json:"cryptoCurrency"`
	PaymentMethod           string                      `json:"paymentMethod"`
	FiatAmount              float64                     `json:"fiatAmount"`
	CryptoAmount            float64                     `json:"cryptoAmount"`
	IsBuyOrSell             string                      `json:"isBuyOrSell"`
	Network                 string                      `json:"network"`
	FeeDecimal              float64                     `json:"feeDecimal"`
	TotalFee                float64                     `json:"totalFee"`
	FeeBreakdown            []*TransakPriceFeeBreakdown `json:"feeBreakdown"`
	Nonce                   int                         `json:"nonce"`
	CryptoLiquidityProvider string                      `json:"cryptoLiquidityProvider"`
	Notes                   []interface{}               `json:"notes"`
}

type TransakPriceFeeBreakdown struct {
	Name  string   `json:"Name"`
	Value float64  `json:"Value"`
	ID    string   `json:"ID"`
	Ids   []string `json:"Ids"`
}

type TransakGetPriceParams struct {
	// required Defaults to GBP
	FiatCurrency string `json:"fiatCurrency"`
	// required Defaults to ETH
	CryptoCurrency string `json:"cryptoCurrency"`
	// required Defaults to BUY
	IsBuyOrSell TransakBuySell `json:"isBuyOrSell"`
	// required Defaults to ethereum
	Network string `json:"network"`
	// required Defaults to credit_debit_card Payment method. You can get the payment method id from getFiatCurrencies endpoint
	PaymentMethod string `json:"paymentMethod"`
	// Defaults to 100
	FiatAmount   float64 `json:"fiatAmount"`
	CryptoAmount float64 `json:"cryptoAmount"`
	// ISO 3166 Alpha-2 Country Code
	QuoteCountryCode string `json:"quoteCountryCode"`
}

type TransakNFTData struct {
	ImageURL          string    `json:"imageUrl"`
	NFTName           string    `json:"nftName"`
	CollectionAddress string    `json:"collectionAddress"`
	TokenIDs          []string  `json:"tokenIds"`
	Prices            []float64 `json:"prices"`
	Quantity          uint64    `json:"quantity"`
	NFTType           string    `json:"nftType"`
}

type TransakGetWidgetURLParams struct {
	TargetContractAddress    *string           `json:"targetContractAddress"`
	IsNFT                    *bool             `json:"isNft"`
	Calldata                 *string           `json:"calldata"`
	CryptoCurrencyCode       *string           `json:"cryptoCurrencyCode"`
	EstimatedGasLimit        *uint64           `json:"estimatedGasLimit"`
	NFTData                  []*TransakNFTData `json:"nftData"`
	WalletAddress            *string           `json:"walletAddress"`
	DisableWalletAddressForm *bool             `json:"disableWalletAddressForm"`
	PartnerOrderID           *string           `json:"partnerOrderId"`
	Network                  *string           `json:"network"`
	ReferrerDomain           *string           `json:"referrerDomain"`
	FiatAmount               *string           `json:"fiatAmount"`
	FiatCurrency             *string           `json:"fiatCurrency"`
	DefaultFiatAmount        *string           `json:"defaultFiatAmount"`
	DefaultCryptoCurrency    *string           `json:"defaultCryptoCurrency"`
	CryptoCurrencyList       *string           `json:"cryptoCurrencyList"`
	Networks                 *string           `json:"networks"`
}

type TransakChain struct {
	Name    string `json:"name"`
	ChainID uint64 `json:"chainId"`
}

type CheckoutOptionsPrimaryParams struct {
	Quantity prototyp.BigInt `json:"quantity"`
	TokenID  string          `json:"tokenId"`
}

type CheckoutOptionsSecondaryParams struct {
	CollectionAddress  prototyp.Hash   `json:"collectionAddress"`
	MarketplaceAddress prototyp.Hash   `json:"marketplaceAddress"`
	CurrencyAddress    prototyp.Hash   `json:"currencyAddress"`
	PriceAmount        prototyp.BigInt `json:"priceAmount"`
	TokenID            string          `json:"tokenId"`
}

type CheckoutOptions struct {
	Crypto      CheckoutOptionCrypto                `json:"crypto"`
	Swap        []CheckoutOptionSwapProvider        `json:"swap"`
	NFTCheckout []CheckoutOptionNFTCheckoutProvider `json:"nftCheckout"`
	OnRamp      []CheckoutOptionOnRampProvider      `json:"onRamp"`
}

type FortePayCreateIntent struct {
	Blockchain      string          `json:"blockchain"`
	Buyer           *FortePayBuyer  `json:"buyer"`
	Currency        string          `json:"currency"`
	IdempotencyKey  string          `json:"idempotencyKey"`
	Items           []*FortePayItem `json:"items"`
	Seller          *FortePaySeller `json:"seller"`
	TransactionType string          `json:"transactionType"`
}

type FortePayBuyer struct {
	Wallet *FortePayWallet `json:"wallet"`
	Email  string          `json:"email"`
	ID     string          `json:"id"`
}

type FortePaySeller struct {
	Wallet *FortePayWallet `json:"wallet"`
}

type FortePayWallet struct {
	Address    string `json:"address"`
	Blockchain string `json:"blockchain"`
}

type FortePayItem struct {
	Amount      string                   `json:"amount"`
	ID          string                   `json:"id"`
	ImageURL    string                   `json:"imageUrl"`
	ListingData *FortePayItemListingData `json:"listingData"`
	NFTData     *FortePayItemNFTData     `json:"nftData"`
	MintData    *FortePayItemMintData    `json:"mintData"`
	Title       string                   `json:"title"`
}

type FortePayItemListingData struct {
	OrderHash          string      `json:"orderHash"`
	Protocol           string      `json:"protocol"`
	ProtocolAddress    string      `json:"protocolAddress"`
	AuctionHouse       string      `json:"auctionHouse"`
	TokenAddress       string      `json:"tokenAddress"`
	Calldata           string      `json:"calldata"`
	PayToAddress       string      `json:"payToAddress"`
	StructuredCalldata interface{} `json:"structuredCalldata"`
}

type FortePayItemNFTData struct {
	ContractAddress string `json:"contractAddress"`
	TokenID         string `json:"tokenId"`
}

type FortePayItemMintData struct {
	Nonce                string      `json:"nonce"`
	Protocol             string      `json:"protocol"`
	ProtocolAddress      string      `json:"protocolAddress"`
	Signature            string      `json:"signature"`
	TokenIDs             []string    `json:"tokenIds"`
	Calldata             string      `json:"calldata"`
	PayToAddress         string      `json:"payToAddress"`
	TokenContractAddress string      `json:"tokenContractAddress"`
	StructuredCalldata   interface{} `json:"structuredCalldata"`
}

type FortePayIntent struct {
	Flow            string   `json:"flow"`
	WidgetData      string   `json:"widgetData"`
	PaymentIntentID string   `json:"paymentIntentId"`
	Notes           []string `json:"notes"`
}

type FortePaymentStatus struct {
	PaymentIntentId string `json:"paymentIntentId"`
	Status          string `json:"status"`
}

type CrossChainFee struct {
	ProviderFee      prototyp.BigInt `json:"providerFee"`
	TrailsSwapFee    prototyp.BigInt `json:"trailsSwapFee"`
	ProviderFeeUSD   float64         `json:"providerFeeUSD"`
	TrailsSwapFeeUSD float64         `json:"trailsSwapFeeUSD"`
	TotalFeeAmount   prototyp.BigInt `json:"totalFeeAmount"`
	TotalFeeUSD      float64         `json:"totalFeeUSD"`
}

type MetaTxnFeeDetail struct {
	MetaTxnID         string          `json:"metaTxnID"`
	EstimatedGasLimit prototyp.BigInt `json:"estimatedGasLimit"`
	FeeNative         prototyp.BigInt `json:"feeNative"`
}

type ChainExecuteQuote struct {
	ChainId           prototyp.BigInt     `json:"chainId"`
	TotalGasLimit     prototyp.BigInt     `json:"totalGasLimit"`
	GasPrice          prototyp.BigInt     `json:"gasPrice"`
	TotalFeeAmount    prototyp.BigInt     `json:"totalFeeAmount"`
	NativeTokenSymbol string              `json:"nativeTokenSymbol"`
	NativeTokenPrice  float64             `json:"nativeTokenPrice"`
	MetaTxnFeeDetails []*MetaTxnFeeDetail `json:"metaTxnFeeDetails"`
	TotalFeeUSD       float64             `json:"totalFeeUSD"`
}

type ExecuteQuote struct {
	ChainQuotes []*ChainExecuteQuote `json:"chainQuotes"`
}

type TrailsFee struct {
	ExecuteQuote           *ExecuteQuote   `json:"executeQuote"`
	CrossChainFee          *CrossChainFee  `json:"crossChainFee"`
	TakerFeeAmount         prototyp.BigInt `json:"takerFeeAmount"`
	TakerFeeUSD            *float64        `json:"takerFeeUSD"`
	TrailsFixedFeeUSD      float64         `json:"trailsFixedFeeUSD"`
	FeeToken               prototyp.Hash   `json:"feeToken"`
	OriginTokenTotalAmount prototyp.BigInt `json:"originTokenTotalAmount"`
	TotalFeeAmount         prototyp.BigInt `json:"totalFeeAmount"`
	TotalFeeUSD            float64         `json:"totalFeeUSD"`
	QuoteProvider          *string         `json:"quoteProvider"`
}

type IntentQuote struct {
	FromAmount             prototyp.BigInt   `json:"fromAmount"`
	FromAmountMin          prototyp.BigInt   `json:"fromAmountMin"`
	ToAmount               prototyp.BigInt   `json:"toAmount"`
	ToAmountMin            prototyp.BigInt   `json:"toAmountMin"`
	PriceImpact            float64           `json:"priceImpact"`
	PriceImpactUsd         string            `json:"priceImpactUsd"`
	MaxSlippage            float64           `json:"maxSlippage"`
	QuoteProvider          string            `json:"quoteProvider"`
	QuoteProviderRequestId string            `json:"quoteProviderRequestId"`
	QuoteProviderFeeUsd    string            `json:"quoteProviderFeeUsd"`
	FeeQuotes              map[string]string `json:"feeQuotes"`
}

var methods = map[string]method{
	"/rpc/API/Ping": {
		name:        "Ping",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/Version": {
		name:        "Version",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/RuntimeStatus": {
		name:        "RuntimeStatus",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/Clock": {
		name:        "Clock",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetSequenceContext": {
		name:        "GetSequenceContext",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetAuthToken": {
		name:        "GetAuthToken",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetAuthToken2": {
		name:        "GetAuthToken2",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/SendPasswordlessLink": {
		name:        "SendPasswordlessLink",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/RegisterPublicKey": {
		name:        "RegisterPublicKey",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetPublicKey": {
		name:        "GetPublicKey",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/FriendList": {
		name:        "FriendList",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetFriendByAddress": {
		name:        "GetFriendByAddress",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/SearchFriends": {
		name:        "SearchFriends",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/AddFriend": {
		name:        "AddFriend",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/UpdateFriendNickname": {
		name:        "UpdateFriendNickname",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/RemoveFriend": {
		name:        "RemoveFriend",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/ContractCall": {
		name:        "ContractCall",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/DecodeContractCall": {
		name:        "DecodeContractCall",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/LookupContractCallSelectors": {
		name:        "LookupContractCallSelectors",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/UserStorageFetch": {
		name:        "UserStorageFetch",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/UserStorageSave": {
		name:        "UserStorageSave",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/UserStorageDelete": {
		name:        "UserStorageDelete",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/UserStorageFetchAll": {
		name:        "UserStorageFetchAll",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetMoonpayLink": {
		name:        "GetMoonpayLink",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/ResolveENSAddress": {
		name:        "ResolveENSAddress",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/IsValidSignature": {
		name:        "IsValidSignature",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/IsValidMessageSignature": {
		name:        "IsValidMessageSignature",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/IsValidTypedDataSignature": {
		name:        "IsValidTypedDataSignature",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/IsValidETHAuthProof": {
		name:        "IsValidETHAuthProof",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GetOnRampURL": {
		name:        "GetOnRampURL",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/TransakGetCountries": {
		name:        "TransakGetCountries",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/TransakGetCryptoCurrencies": {
		name:        "TransakGetCryptoCurrencies",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/TransakGetFiatCurrencies": {
		name:        "TransakGetFiatCurrencies",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/TransakGetPrice": {
		name:        "TransakGetPrice",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/TransakGetSupportedNFTCheckoutChains": {
		name:        "TransakGetSupportedNFTCheckoutChains",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/TransakGetWidgetURL": {
		name:        "TransakGetWidgetURL",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetCoinPrices": {
		name:        "GetCoinPrices",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetCollectiblePrices": {
		name:        "GetCollectiblePrices",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetExchangeRate": {
		name:        "GetExchangeRate",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/MemoryStore": {
		name:        "MemoryStore",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/MemoryLoad": {
		name:        "MemoryLoad",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetInviteInfo": {
		name:        "GetInviteInfo",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/IsValidAccessCode": {
		name:        "IsValidAccessCode",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/InternalClaimAccessCode": {
		name:        "InternalClaimAccessCode",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/BlockNumberAtTime": {
		name:        "BlockNumberAtTime",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/PaperSessionSecret": {
		name:        "PaperSessionSecret",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/PaperSessionSecret2": {
		name:        "PaperSessionSecret2",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/LinkWallet": {
		name:        "LinkWallet",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GetLinkedWallets": {
		name:        "GetLinkedWallets",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/RemoveLinkedWallet": {
		name:        "RemoveLinkedWallet",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GenerateWaaSVerificationURL": {
		name:        "GenerateWaaSVerificationURL",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/ValidateWaaSVerificationNonce": {
		name:        "ValidateWaaSVerificationNonce",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/ListAdoptedWallets": {
		name:        "ListAdoptedWallets",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetLifiChains": {
		name:        "GetLifiChains",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GetLifiTokens": {
		name:        "GetLifiTokens",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GetLifiSwapRoutes": {
		name:        "GetLifiSwapRoutes",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GetLifiSwapQuote": {
		name:        "GetLifiSwapQuote",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GetIntentCallsPayloads": {
		name:        "GetIntentCallsPayloads",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/CommitIntentConfig": {
		name:        "CommitIntentConfig",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetIntentConfig": {
		name:        "GetIntentConfig",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/ListCurrencyGroups": {
		name:        "ListCurrencyGroups",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/AddOffchainInventory": {
		name:        "AddOffchainInventory",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetOffchainInventory": {
		name:        "GetOffchainInventory",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/ListOffchainInventories": {
		name:        "ListOffchainInventories",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/UpdateOffchainInventory": {
		name:        "UpdateOffchainInventory",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/DeleteOffchainInventory": {
		name:        "DeleteOffchainInventory",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/RequestOffchainPayment": {
		name:        "RequestOffchainPayment",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/ListOffchainPayments": {
		name:        "ListOffchainPayments",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/SavePack": {
		name:        "SavePack",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetPack": {
		name:        "GetPack",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetPackIds": {
		name:        "GetPackIds",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/DeletePack": {
		name:        "DeletePack",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/UpdatePackContent": {
		name:        "UpdatePackContent",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetRevealTxData": {
		name:        "GetRevealTxData",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/CheckoutOptionsPrimary": {
		name:        "CheckoutOptionsPrimary",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/CheckoutOptionsSecondary": {
		name:        "CheckoutOptionsSecondary",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/CheckoutOptionsGetTransakContractID": {
		name:        "CheckoutOptionsGetTransakContractID",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/FortePayCreateIntent": {
		name:        "FortePayCreateIntent",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/FortePayGetPaymentStatuses": {
		name:        "FortePayGetPaymentStatuses",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetCCTPTransfer": {
		name:        "GetCCTPTransfer",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/QueueCCTPTransfer": {
		name:        "QueueCCTPTransfer",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/QueueIntentConfigExecution": {
		name:        "QueueIntentConfigExecution",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GetIntentConfigExecutionStatus": {
		name:        "GetIntentConfigExecutionStatus",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/ListIntentConfigs": {
		name:        "ListIntentConfigs",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/QueueMetaTxnReceipt": {
		name:        "QueueMetaTxnReceipt",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
}

func WebrpcMethods() map[string]method {
	res := make(map[string]method, len(methods))
	for k, v := range methods {
		res[k] = v
	}

	return res
}

var WebRPCServices = map[string][]string{
	"API": {
		"Ping",
		"Version",
		"RuntimeStatus",
		"Clock",
		"GetSequenceContext",
		"GetAuthToken",
		"GetAuthToken2",
		"SendPasswordlessLink",
		"RegisterPublicKey",
		"GetPublicKey",
		"FriendList",
		"GetFriendByAddress",
		"SearchFriends",
		"AddFriend",
		"UpdateFriendNickname",
		"RemoveFriend",
		"ContractCall",
		"DecodeContractCall",
		"LookupContractCallSelectors",
		"UserStorageFetch",
		"UserStorageSave",
		"UserStorageDelete",
		"UserStorageFetchAll",
		"GetMoonpayLink",
		"ResolveENSAddress",
		"IsValidSignature",
		"IsValidMessageSignature",
		"IsValidTypedDataSignature",
		"IsValidETHAuthProof",
		"GetOnRampURL",
		"TransakGetCountries",
		"TransakGetCryptoCurrencies",
		"TransakGetFiatCurrencies",
		"TransakGetPrice",
		"TransakGetSupportedNFTCheckoutChains",
		"TransakGetWidgetURL",
		"GetCoinPrices",
		"GetCollectiblePrices",
		"GetExchangeRate",
		"MemoryStore",
		"MemoryLoad",
		"GetInviteInfo",
		"IsValidAccessCode",
		"InternalClaimAccessCode",
		"BlockNumberAtTime",
		"PaperSessionSecret",
		"PaperSessionSecret2",
		"LinkWallet",
		"GetLinkedWallets",
		"RemoveLinkedWallet",
		"GenerateWaaSVerificationURL",
		"ValidateWaaSVerificationNonce",
		"ListAdoptedWallets",
		"GetLifiChains",
		"GetLifiTokens",
		"GetLifiSwapRoutes",
		"GetLifiSwapQuote",
		"GetIntentCallsPayloads",
		"CommitIntentConfig",
		"GetIntentConfig",
		"ListCurrencyGroups",
		"AddOffchainInventory",
		"GetOffchainInventory",
		"ListOffchainInventories",
		"UpdateOffchainInventory",
		"DeleteOffchainInventory",
		"RequestOffchainPayment",
		"ListOffchainPayments",
		"SavePack",
		"GetPack",
		"GetPackIds",
		"DeletePack",
		"UpdatePackContent",
		"GetRevealTxData",
		"CheckoutOptionsPrimary",
		"CheckoutOptionsSecondary",
		"CheckoutOptionsGetTransakContractID",
		"FortePayCreateIntent",
		"FortePayGetPaymentStatuses",
		"GetCCTPTransfer",
		"QueueCCTPTransfer",
		"QueueIntentConfigExecution",
		"GetIntentConfigExecutionStatus",
		"ListIntentConfigs",
		"QueueMetaTxnReceipt",
	},
}

//
// Client
//

const APIPathPrefix = "/rpc/API/"

type apiClient struct {
	client HTTPClient
	urls   [85]string
}

func NewAPIClient(addr string, client HTTPClient) APIClient {
	prefix := urlBase(addr) + APIPathPrefix
	urls := [85]string{
		prefix + "Ping",
		prefix + "Version",
		prefix + "RuntimeStatus",
		prefix + "Clock",
		prefix + "GetSequenceContext",
		prefix + "GetAuthToken",
		prefix + "GetAuthToken2",
		prefix + "SendPasswordlessLink",
		prefix + "RegisterPublicKey",
		prefix + "GetPublicKey",
		prefix + "FriendList",
		prefix + "GetFriendByAddress",
		prefix + "SearchFriends",
		prefix + "AddFriend",
		prefix + "UpdateFriendNickname",
		prefix + "RemoveFriend",
		prefix + "ContractCall",
		prefix + "DecodeContractCall",
		prefix + "LookupContractCallSelectors",
		prefix + "UserStorageFetch",
		prefix + "UserStorageSave",
		prefix + "UserStorageDelete",
		prefix + "UserStorageFetchAll",
		prefix + "GetMoonpayLink",
		prefix + "ResolveENSAddress",
		prefix + "IsValidSignature",
		prefix + "IsValidMessageSignature",
		prefix + "IsValidTypedDataSignature",
		prefix + "IsValidETHAuthProof",
		prefix + "GetOnRampURL",
		prefix + "TransakGetCountries",
		prefix + "TransakGetCryptoCurrencies",
		prefix + "TransakGetFiatCurrencies",
		prefix + "TransakGetPrice",
		prefix + "TransakGetSupportedNFTCheckoutChains",
		prefix + "TransakGetWidgetURL",
		prefix + "GetCoinPrices",
		prefix + "GetCollectiblePrices",
		prefix + "GetExchangeRate",
		prefix + "MemoryStore",
		prefix + "MemoryLoad",
		prefix + "GetInviteInfo",
		prefix + "IsValidAccessCode",
		prefix + "InternalClaimAccessCode",
		prefix + "BlockNumberAtTime",
		prefix + "PaperSessionSecret",
		prefix + "PaperSessionSecret2",
		prefix + "LinkWallet",
		prefix + "GetLinkedWallets",
		prefix + "RemoveLinkedWallet",
		prefix + "GenerateWaaSVerificationURL",
		prefix + "ValidateWaaSVerificationNonce",
		prefix + "ListAdoptedWallets",
		prefix + "GetLifiChains",
		prefix + "GetLifiTokens",
		prefix + "GetLifiSwapRoutes",
		prefix + "GetLifiSwapQuote",
		prefix + "GetIntentCallsPayloads",
		prefix + "CommitIntentConfig",
		prefix + "GetIntentConfig",
		prefix + "ListCurrencyGroups",
		prefix + "AddOffchainInventory",
		prefix + "GetOffchainInventory",
		prefix + "ListOffchainInventories",
		prefix + "UpdateOffchainInventory",
		prefix + "DeleteOffchainInventory",
		prefix + "RequestOffchainPayment",
		prefix + "ListOffchainPayments",
		prefix + "SavePack",
		prefix + "GetPack",
		prefix + "GetPackIds",
		prefix + "DeletePack",
		prefix + "UpdatePackContent",
		prefix + "GetRevealTxData",
		prefix + "CheckoutOptionsPrimary",
		prefix + "CheckoutOptionsSecondary",
		prefix + "CheckoutOptionsGetTransakContractID",
		prefix + "FortePayCreateIntent",
		prefix + "FortePayGetPaymentStatuses",
		prefix + "GetCCTPTransfer",
		prefix + "QueueCCTPTransfer",
		prefix + "QueueIntentConfigExecution",
		prefix + "GetIntentConfigExecutionStatus",
		prefix + "ListIntentConfigs",
		prefix + "QueueMetaTxnReceipt",
	}
	return &apiClient{
		client: client,
		urls:   urls,
	}
}

func (c *apiClient) Ping(ctx context.Context) (bool, error) {
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) Version(ctx context.Context) (*Version, error) {
	out := struct {
		Ret0 *Version `json:"version"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) RuntimeStatus(ctx context.Context) (*RuntimeStatus, error) {
	out := struct {
		Ret0 *RuntimeStatus `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) Clock(ctx context.Context) (time.Time, error) {
	out := struct {
		Ret0 time.Time `json:"serverTime"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetSequenceContext(ctx context.Context) (*SequenceContext, error) {
	out := struct {
		Ret0 *SequenceContext `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetAuthToken(ctx context.Context, ewtString string, testnetMode *bool) (bool, string, string, *User, error) {
	in := struct {
		Arg0 string `json:"ewtString"`
		Arg1 *bool  `json:"testnetMode"`
	}{ewtString, testnetMode}
	out := struct {
		Ret0 bool   `json:"status"`
		Ret1 string `json:"jwtToken"`
		Ret2 string `json:"address"`
		Ret3 *User  `json:"user"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[5], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, out.Ret2, out.Ret3, err
}

func (c *apiClient) GetAuthToken2(ctx context.Context, ewtString string, chainID string) (bool, string, string, *User, error) {
	in := struct {
		Arg0 string `json:"ewtString"`
		Arg1 string `json:"chainID"`
	}{ewtString, chainID}
	out := struct {
		Ret0 bool   `json:"status"`
		Ret1 string `json:"jwtToken"`
		Ret2 string `json:"address"`
		Ret3 *User  `json:"user"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[6], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, out.Ret2, out.Ret3, err
}

func (c *apiClient) SendPasswordlessLink(ctx context.Context, email string, redirectUri string, intent string) (bool, error) {
	in := struct {
		Arg0 string `json:"email"`
		Arg1 string `json:"redirectUri"`
		Arg2 string `json:"intent"`
	}{email, redirectUri, intent}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[7], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) RegisterPublicKey(ctx context.Context, publicKey *PublicKey) (bool, error) {
	in := struct {
		Arg0 *PublicKey `json:"publicKey"`
	}{publicKey}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[8], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetPublicKey(ctx context.Context, id string) (*PublicKey, error) {
	in := struct {
		Arg0 string `json:"id"`
	}{id}
	out := struct {
		Ret0 *PublicKey `json:"publicKey"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[9], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) FriendList(ctx context.Context, nickname *string, page *Page) (*Page, []*Friend, error) {
	in := struct {
		Arg0 *string `json:"nickname"`
		Arg1 *Page   `json:"page"`
	}{nickname, page}
	out := struct {
		Ret0 *Page     `json:"page"`
		Ret1 []*Friend `json:"friends"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[10], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *apiClient) GetFriendByAddress(ctx context.Context, friendAddress string) (bool, *Friend, error) {
	in := struct {
		Arg0 string `json:"friendAddress"`
	}{friendAddress}
	out := struct {
		Ret0 bool    `json:"status"`
		Ret1 *Friend `json:"friend"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[11], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *apiClient) SearchFriends(ctx context.Context, filterUsername string, page *Page) ([]*Friend, error) {
	in := struct {
		Arg0 string `json:"filterUsername"`
		Arg1 *Page  `json:"page"`
	}{filterUsername, page}
	out := struct {
		Ret0 []*Friend `json:"friends"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[12], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) AddFriend(ctx context.Context, friendAddress string, optionalNickname *string) (bool, *Friend, error) {
	in := struct {
		Arg0 string  `json:"friendAddress"`
		Arg1 *string `json:"optionalNickname"`
	}{friendAddress, optionalNickname}
	out := struct {
		Ret0 bool    `json:"status"`
		Ret1 *Friend `json:"friend"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[13], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *apiClient) UpdateFriendNickname(ctx context.Context, friendAddress string, nickname string) (bool, *Friend, error) {
	in := struct {
		Arg0 string `json:"friendAddress"`
		Arg1 string `json:"nickname"`
	}{friendAddress, nickname}
	out := struct {
		Ret0 bool    `json:"status"`
		Ret1 *Friend `json:"friend"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[14], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *apiClient) RemoveFriend(ctx context.Context, friendAddress string) (bool, error) {
	in := struct {
		Arg0 string `json:"friendAddress"`
	}{friendAddress}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[15], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) ContractCall(ctx context.Context, chainID string, contract string, inputExpr string, outputExpr string, args []string) ([]string, error) {
	in := struct {
		Arg0 string   `json:"chainID"`
		Arg1 string   `json:"contract"`
		Arg2 string   `json:"inputExpr"`
		Arg3 string   `json:"outputExpr"`
		Arg4 []string `json:"args"`
	}{chainID, contract, inputExpr, outputExpr, args}
	out := struct {
		Ret0 []string `json:"returns"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[16], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) DecodeContractCall(ctx context.Context, callData string) (*ContractCall, error) {
	in := struct {
		Arg0 string `json:"callData"`
	}{callData}
	out := struct {
		Ret0 *ContractCall `json:"call"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[17], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) LookupContractCallSelectors(ctx context.Context, selectors []string) ([][]string, error) {
	in := struct {
		Arg0 []string `json:"selectors"`
	}{selectors}
	out := struct {
		Ret0 [][]string `json:"signatures"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[18], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) UserStorageFetch(ctx context.Context, key string) (interface{}, error) {
	in := struct {
		Arg0 string `json:"key"`
	}{key}
	out := struct {
		Ret0 interface{} `json:"object"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[19], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) UserStorageSave(ctx context.Context, key string, object interface{}) (bool, error) {
	in := struct {
		Arg0 string      `json:"key"`
		Arg1 interface{} `json:"object"`
	}{key, object}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[20], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) UserStorageDelete(ctx context.Context, key string) (bool, error) {
	in := struct {
		Arg0 string `json:"key"`
	}{key}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[21], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) UserStorageFetchAll(ctx context.Context, keys []string) (map[string]interface{}, error) {
	in := struct {
		Arg0 []string `json:"keys"`
	}{keys}
	out := struct {
		Ret0 map[string]interface{} `json:"objects"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[22], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetMoonpayLink(ctx context.Context, url string) (string, error) {
	in := struct {
		Arg0 string `json:"url"`
	}{url}
	out := struct {
		Ret0 string `json:"signedUrl"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[23], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) ResolveENSAddress(ctx context.Context, ens string) (string, bool, error) {
	in := struct {
		Arg0 string `json:"ens"`
	}{ens}
	out := struct {
		Ret0 string `json:"address"`
		Ret1 bool   `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[24], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *apiClient) IsValidSignature(ctx context.Context, chainId string, walletAddress string, digest string, signature string) (bool, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"walletAddress"`
		Arg2 string `json:"digest"`
		Arg3 string `json:"signature"`
	}{chainId, walletAddress, digest, signature}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[25], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) IsValidMessageSignature(ctx context.Context, chainId string, walletAddress string, message string, signature string) (bool, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"walletAddress"`
		Arg2 string `json:"message"`
		Arg3 string `json:"signature"`
	}{chainId, walletAddress, message, signature}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[26], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) IsValidTypedDataSignature(ctx context.Context, chainId string, walletAddress string, typedData interface{}, signature string) (bool, error) {
	in := struct {
		Arg0 string      `json:"chainId"`
		Arg1 string      `json:"walletAddress"`
		Arg2 interface{} `json:"typedData"`
		Arg3 string      `json:"signature"`
	}{chainId, walletAddress, typedData, signature}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[27], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) IsValidETHAuthProof(ctx context.Context, chainId string, walletAddress string, ethAuthProofString string) (bool, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"walletAddress"`
		Arg2 string `json:"ethAuthProofString"`
	}{chainId, walletAddress, ethAuthProofString}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[28], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetOnRampURL(ctx context.Context, chainId string) (string, error) {
	in := struct {
		Arg0 string `json:"chainId"`
	}{chainId}
	out := struct {
		Ret0 string `json:"url"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[29], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) TransakGetCountries(ctx context.Context) ([]*TransakCountry, error) {
	out := struct {
		Ret0 []*TransakCountry `json:"regions"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[30], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) TransakGetCryptoCurrencies(ctx context.Context) ([]*TransakCryptoCurrency, error) {
	out := struct {
		Ret0 []*TransakCryptoCurrency `json:"currencies"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[31], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) TransakGetFiatCurrencies(ctx context.Context) ([]*TransakFiatCurrency, error) {
	out := struct {
		Ret0 []*TransakFiatCurrency `json:"currencies"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[32], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) TransakGetPrice(ctx context.Context, params *TransakGetPriceParams) (*TransakPrice, error) {
	in := struct {
		Arg0 *TransakGetPriceParams `json:"params"`
	}{params}
	out := struct {
		Ret0 *TransakPrice `json:"price"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[33], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) TransakGetSupportedNFTCheckoutChains(ctx context.Context) ([]*TransakChain, error) {
	out := struct {
		Ret0 []*TransakChain `json:"chains"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[34], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) TransakGetWidgetURL(ctx context.Context, params *TransakGetWidgetURLParams) (string, error) {
	in := struct {
		Arg0 *TransakGetWidgetURLParams `json:"params"`
	}{params}
	out := struct {
		Ret0 string `json:"url"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[35], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetCoinPrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error) {
	in := struct {
		Arg0 []*Token `json:"tokens"`
	}{tokens}
	out := struct {
		Ret0 []*TokenPrice `json:"tokenPrices"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[36], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetCollectiblePrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error) {
	in := struct {
		Arg0 []*Token `json:"tokens"`
	}{tokens}
	out := struct {
		Ret0 []*TokenPrice `json:"tokenPrices"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[37], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetExchangeRate(ctx context.Context, toCurrency string) (*ExchangeRate, error) {
	in := struct {
		Arg0 string `json:"toCurrency"`
	}{toCurrency}
	out := struct {
		Ret0 *ExchangeRate `json:"exchangeRate"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[38], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) MemoryStore(ctx context.Context, key string, value string) (bool, error) {
	in := struct {
		Arg0 string `json:"key"`
		Arg1 string `json:"value"`
	}{key, value}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[39], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) MemoryLoad(ctx context.Context, key string) (string, error) {
	in := struct {
		Arg0 string `json:"key"`
	}{key}
	out := struct {
		Ret0 string `json:"value"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[40], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetInviteInfo(ctx context.Context) (*InviteInfo, error) {
	out := struct {
		Ret0 *InviteInfo `json:"inviteInfo"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[41], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) IsValidAccessCode(ctx context.Context, accessCode string) (bool, error) {
	in := struct {
		Arg0 string `json:"accessCode"`
	}{accessCode}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[42], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) InternalClaimAccessCode(ctx context.Context, address string, accessCode string) (bool, error) {
	in := struct {
		Arg0 string `json:"address"`
		Arg1 string `json:"accessCode"`
	}{address, accessCode}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[43], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) BlockNumberAtTime(ctx context.Context, chainId uint64, timestamps []uint64) ([]uint64, error) {
	in := struct {
		Arg0 uint64   `json:"chainId"`
		Arg1 []uint64 `json:"timestamps"`
	}{chainId, timestamps}
	out := struct {
		Ret0 []uint64 `json:"blocks"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[44], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) PaperSessionSecret(ctx context.Context, chainName string, contractAddress string, paramsJson string, contractType string) (string, error) {
	in := struct {
		Arg0 string `json:"chainName"`
		Arg1 string `json:"contractAddress"`
		Arg2 string `json:"paramsJson"`
		Arg3 string `json:"contractType"`
	}{chainName, contractAddress, paramsJson, contractType}
	out := struct {
		Ret0 string `json:"secret"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[45], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) PaperSessionSecret2(ctx context.Context, chainName string, contractAddress string, paramsJson string, abi string) (string, error) {
	in := struct {
		Arg0 string `json:"chainName"`
		Arg1 string `json:"contractAddress"`
		Arg2 string `json:"paramsJson"`
		Arg3 string `json:"abi"`
	}{chainName, contractAddress, paramsJson, abi}
	out := struct {
		Ret0 string `json:"secret"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[46], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) LinkWallet(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, linkedWalletAddress string, linkedWalletMessage string, linkedWalletSignature string, signatureChainId string, linkedWalletType *string) (bool, error) {
	in := struct {
		Arg0 string  `json:"parentWalletAddress"`
		Arg1 string  `json:"parentWalletMessage"`
		Arg2 string  `json:"parentWalletSignature"`
		Arg3 string  `json:"linkedWalletAddress"`
		Arg4 string  `json:"linkedWalletMessage"`
		Arg5 string  `json:"linkedWalletSignature"`
		Arg6 string  `json:"signatureChainId"`
		Arg7 *string `json:"linkedWalletType"`
	}{parentWalletAddress, parentWalletMessage, parentWalletSignature, linkedWalletAddress, linkedWalletMessage, linkedWalletSignature, signatureChainId, linkedWalletType}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[47], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetLinkedWallets(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, signatureChainId string) ([]*LinkedWallet, error) {
	in := struct {
		Arg0 string `json:"parentWalletAddress"`
		Arg1 string `json:"parentWalletMessage"`
		Arg2 string `json:"parentWalletSignature"`
		Arg3 string `json:"signatureChainId"`
	}{parentWalletAddress, parentWalletMessage, parentWalletSignature, signatureChainId}
	out := struct {
		Ret0 []*LinkedWallet `json:"linkedWallets"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[48], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) RemoveLinkedWallet(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, linkedWalletAddress string, signatureChainId string) (bool, error) {
	in := struct {
		Arg0 string `json:"parentWalletAddress"`
		Arg1 string `json:"parentWalletMessage"`
		Arg2 string `json:"parentWalletSignature"`
		Arg3 string `json:"linkedWalletAddress"`
		Arg4 string `json:"signatureChainId"`
	}{parentWalletAddress, parentWalletMessage, parentWalletSignature, linkedWalletAddress, signatureChainId}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[49], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GenerateWaaSVerificationURL(ctx context.Context, walletAddress string) (string, string, error) {
	in := struct {
		Arg0 string `json:"walletAddress"`
	}{walletAddress}
	out := struct {
		Ret0 string `json:"nonce"`
		Ret1 string `json:"verificationURL"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[50], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *apiClient) ValidateWaaSVerificationNonce(ctx context.Context, nonce string, signature string, sessionId string, chainId string) (string, error) {
	in := struct {
		Arg0 string `json:"nonce"`
		Arg1 string `json:"signature"`
		Arg2 string `json:"sessionId"`
		Arg3 string `json:"chainId"`
	}{nonce, signature, sessionId, chainId}
	out := struct {
		Ret0 string `json:"walletAddress"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[51], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) ListAdoptedWallets(ctx context.Context, page *Page) (*Page, []*AdoptedChildWallet, error) {
	in := struct {
		Arg0 *Page `json:"page"`
	}{page}
	out := struct {
		Ret0 *Page                 `json:"page"`
		Ret1 []*AdoptedChildWallet `json:"wallets"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[52], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *apiClient) GetLifiChains(ctx context.Context) ([]uint64, error) {
	out := struct {
		Ret0 []uint64 `json:"chains"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[53], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetLifiTokens(ctx context.Context, chainIds []uint64) ([]*Token, error) {
	in := struct {
		Arg0 []uint64 `json:"chainIds"`
	}{chainIds}
	out := struct {
		Ret0 []*Token `json:"tokens"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[54], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetLifiSwapRoutes(ctx context.Context, params *GetLifiSwapRouteParams) ([]*LifiSwapRoute, error) {
	in := struct {
		Arg0 *GetLifiSwapRouteParams `json:"params"`
	}{params}
	out := struct {
		Ret0 []*LifiSwapRoute `json:"routes"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[55], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetLifiSwapQuote(ctx context.Context, params *GetLifiSwapQuoteParams) (*LifiSwapQuote, error) {
	in := struct {
		Arg0 *GetLifiSwapQuoteParams `json:"params"`
	}{params}
	out := struct {
		Ret0 *LifiSwapQuote `json:"quote"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[56], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetIntentCallsPayloads(ctx context.Context, userAddress string, destinationChainId uint64, destinationTokenAddress string, destinationTokenAmount string, destinationToAddress string, originChainId uint64, originTokenAddress string, originTokenAmount string, destinationCallData *string, destinationCallValue *string, provider *string, addressOverrides *AddressOverrides, destinationSalt *string, takerFee *TakerFee, slippageTolerance *float64, tradeType *TradeType) ([]*IntentCallsPayload, []*IntentPrecondition, []*MetaTxn, *TrailsFee, *IntentQuote, map[string]string, string, string, error) {
	in := struct {
		Arg0  string            `json:"userAddress"`
		Arg1  uint64            `json:"destinationChainId"`
		Arg2  string            `json:"destinationTokenAddress"`
		Arg3  string            `json:"destinationTokenAmount"`
		Arg4  string            `json:"destinationToAddress"`
		Arg5  uint64            `json:"originChainId"`
		Arg6  string            `json:"originTokenAddress"`
		Arg7  string            `json:"originTokenAmount"`
		Arg8  *string           `json:"destinationCallData"`
		Arg9  *string           `json:"destinationCallValue"`
		Arg10 *string           `json:"provider"`
		Arg11 *AddressOverrides `json:"addressOverrides"`
		Arg12 *string           `json:"destinationSalt"`
		Arg13 *TakerFee         `json:"takerFee"`
		Arg14 *float64          `json:"slippageTolerance"`
		Arg15 *TradeType        `json:"tradeType"`
	}{userAddress, destinationChainId, destinationTokenAddress, destinationTokenAmount, destinationToAddress, originChainId, originTokenAddress, originTokenAmount, destinationCallData, destinationCallValue, provider, addressOverrides, destinationSalt, takerFee, slippageTolerance, tradeType}
	out := struct {
		Ret0 []*IntentCallsPayload `json:"calls"`
		Ret1 []*IntentPrecondition `json:"preconditions"`
		Ret2 []*MetaTxn            `json:"metaTxns"`
		Ret3 *TrailsFee            `json:"trailsFee"`
		Ret4 *IntentQuote          `json:"quote"`
		Ret5 map[string]string     `json:"feeQuotes"`
		Ret6 string                `json:"originIntentAddress"`
		Ret7 string                `json:"destinationIntentAddress"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[57], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, out.Ret2, out.Ret3, out.Ret4, out.Ret5, out.Ret6, out.Ret7, err
}

func (c *apiClient) CommitIntentConfig(ctx context.Context, originIntentAddress string, destinationIntentAddress string, mainSigner string, calls []*IntentCallsPayload, preconditions []*IntentPrecondition, addressOverrides *AddressOverrides) (*IntentConfig, error) {
	in := struct {
		Arg0 string                `json:"originIntentAddress"`
		Arg1 string                `json:"destinationIntentAddress"`
		Arg2 string                `json:"mainSigner"`
		Arg3 []*IntentCallsPayload `json:"calls"`
		Arg4 []*IntentPrecondition `json:"preconditions"`
		Arg5 *AddressOverrides     `json:"addressOverrides"`
	}{originIntentAddress, destinationIntentAddress, mainSigner, calls, preconditions, addressOverrides}
	out := struct {
		Ret0 *IntentConfig `json:"config"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[58], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetIntentConfig(ctx context.Context, intentAddress string) (*IntentConfig, error) {
	in := struct {
		Arg0 string `json:"intentAddress"`
	}{intentAddress}
	out := struct {
		Ret0 *IntentConfig `json:"config"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[59], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) ListCurrencyGroups(ctx context.Context) ([]*CurrencyGroup, error) {
	out := struct {
		Ret0 []*CurrencyGroup `json:"currencyGroups"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[60], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) AddOffchainInventory(ctx context.Context, inventory *OffchainInventory) (uint64, error) {
	in := struct {
		Arg0 *OffchainInventory `json:"inventory"`
	}{inventory}
	out := struct {
		Ret0 uint64 `json:"inventoryId"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[61], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetOffchainInventory(ctx context.Context, inventoryId uint64) (*OffchainInventory, error) {
	in := struct {
		Arg0 uint64 `json:"inventoryId"`
	}{inventoryId}
	out := struct {
		Ret0 *OffchainInventory `json:"inventory"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[62], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) ListOffchainInventories(ctx context.Context, projectId uint64) ([]*OffchainInventory, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 []*OffchainInventory `json:"inventory"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[63], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) UpdateOffchainInventory(ctx context.Context, inventory *OffchainInventory) error {
	in := struct {
		Arg0 *OffchainInventory `json:"inventory"`
	}{inventory}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[64], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return err
}

func (c *apiClient) DeleteOffchainInventory(ctx context.Context, inventoryId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"inventoryId"`
	}{inventoryId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[65], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) RequestOffchainPayment(ctx context.Context, inventoryId uint64, recipient string, chainId *uint64, tokenAddress *string) (*PaymentResponse, error) {
	in := struct {
		Arg0 uint64  `json:"inventoryId"`
		Arg1 string  `json:"recipient"`
		Arg2 *uint64 `json:"chainId"`
		Arg3 *string `json:"tokenAddress"`
	}{inventoryId, recipient, chainId, tokenAddress}
	out := struct {
		Ret0 *PaymentResponse `json:"payment"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[66], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) ListOffchainPayments(ctx context.Context, inventoryId uint64, page *Page) (*Page, []*OffchainPayment, error) {
	in := struct {
		Arg0 uint64 `json:"inventoryId"`
		Arg1 *Page  `json:"page"`
	}{inventoryId, page}
	out := struct {
		Ret0 *Page              `json:"page"`
		Ret1 []*OffchainPayment `json:"payments"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[67], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *apiClient) SavePack(ctx context.Context, pack *Pack) (string, error) {
	in := struct {
		Arg0 *Pack `json:"pack"`
	}{pack}
	out := struct {
		Ret0 string `json:"merkleRoot"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[68], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetPack(ctx context.Context, contractAddress string, packId string, chainId uint64) (*Pack, error) {
	in := struct {
		Arg0 string `json:"contractAddress"`
		Arg1 string `json:"packId"`
		Arg2 uint64 `json:"chainId"`
	}{contractAddress, packId, chainId}
	out := struct {
		Ret0 *Pack `json:"pack"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[69], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetPackIds(ctx context.Context, contractAddress string, chainId uint64) ([]string, error) {
	in := struct {
		Arg0 string `json:"contractAddress"`
		Arg1 uint64 `json:"chainId"`
	}{contractAddress, chainId}
	out := struct {
		Ret0 []string `json:"packIds"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[70], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) DeletePack(ctx context.Context, contractAddress string, packId string, chainId uint64) (bool, error) {
	in := struct {
		Arg0 string `json:"contractAddress"`
		Arg1 string `json:"packId"`
		Arg2 uint64 `json:"chainId"`
	}{contractAddress, packId, chainId}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[71], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) UpdatePackContent(ctx context.Context, pack *Pack) (string, error) {
	in := struct {
		Arg0 *Pack `json:"pack"`
	}{pack}
	out := struct {
		Ret0 string `json:"merkleRoot"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[72], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetRevealTxData(ctx context.Context, contractAddress string, packId string, chainId uint64, userAddress string) (string, error) {
	in := struct {
		Arg0 string `json:"contractAddress"`
		Arg1 string `json:"packId"`
		Arg2 uint64 `json:"chainId"`
		Arg3 string `json:"userAddress"`
	}{contractAddress, packId, chainId, userAddress}
	out := struct {
		Ret0 string `json:"txData"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[73], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) CheckoutOptionsPrimary(ctx context.Context, chainId uint64, wallet string, contractAddress string, collectionAddress string, params []*CheckoutOptionsPrimaryParams) (*CheckoutOptions, error) {
	in := struct {
		Arg0 uint64                          `json:"chainId"`
		Arg1 string                          `json:"wallet"`
		Arg2 string                          `json:"contractAddress"`
		Arg3 string                          `json:"collectionAddress"`
		Arg4 []*CheckoutOptionsPrimaryParams `json:"params"`
	}{chainId, wallet, contractAddress, collectionAddress, params}
	out := struct {
		Ret0 *CheckoutOptions `json:"options"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[74], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) CheckoutOptionsSecondary(ctx context.Context, chainId uint64, wallet string, params []*CheckoutOptionsSecondaryParams) (*CheckoutOptions, error) {
	in := struct {
		Arg0 uint64                            `json:"chainId"`
		Arg1 string                            `json:"wallet"`
		Arg2 []*CheckoutOptionsSecondaryParams `json:"params"`
	}{chainId, wallet, params}
	out := struct {
		Ret0 *CheckoutOptions `json:"options"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[75], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) CheckoutOptionsGetTransakContractID(ctx context.Context, chainId uint64, contractAddress string) (string, error) {
	in := struct {
		Arg0 uint64 `json:"chainId"`
		Arg1 string `json:"contractAddress"`
	}{chainId, contractAddress}
	out := struct {
		Ret0 string `json:"contractId"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[76], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) FortePayCreateIntent(ctx context.Context, intent *FortePayCreateIntent) (*FortePayIntent, error) {
	in := struct {
		Arg0 *FortePayCreateIntent `json:"intent"`
	}{intent}
	out := struct {
		Ret0 *FortePayIntent `json:"resp"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[77], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) FortePayGetPaymentStatuses(ctx context.Context, paymentIntentIds []string) ([]*FortePaymentStatus, error) {
	in := struct {
		Arg0 []string `json:"paymentIntentIds"`
	}{paymentIntentIds}
	out := struct {
		Ret0 []*FortePaymentStatus `json:"statuses"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[78], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetCCTPTransfer(ctx context.Context, id string) (*CCTPTransfer, error) {
	in := struct {
		Arg0 string `json:"id"`
	}{id}
	out := struct {
		Ret0 *CCTPTransfer `json:"transfer"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[79], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) QueueCCTPTransfer(ctx context.Context, sourceTxHash *string, metaTxHash *string, sourceChainId uint64, destinationChainId uint64) (*CCTPTransfer, error) {
	in := struct {
		Arg0 *string `json:"sourceTxHash"`
		Arg1 *string `json:"metaTxHash"`
		Arg2 uint64  `json:"sourceChainId"`
		Arg3 uint64  `json:"destinationChainId"`
	}{sourceTxHash, metaTxHash, sourceChainId, destinationChainId}
	out := struct {
		Ret0 *CCTPTransfer `json:"transfer"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[80], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) QueueIntentConfigExecution(ctx context.Context, intentConfigId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"intentConfigId"`
	}{intentConfigId}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[81], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) GetIntentConfigExecutionStatus(ctx context.Context, intentConfigId uint64) (string, error) {
	in := struct {
		Arg0 uint64 `json:"intentConfigId"`
	}{intentConfigId}
	out := struct {
		Ret0 string `json:"executionStatus"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[82], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *apiClient) ListIntentConfigs(ctx context.Context, page *Page, executionStatus *string) (*Page, []*IntentConfig, error) {
	in := struct {
		Arg0 *Page   `json:"page"`
		Arg1 *string `json:"executionStatus"`
	}{page, executionStatus}
	out := struct {
		Ret0 *Page           `json:"page"`
		Ret1 []*IntentConfig `json:"intentConfigs"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[83], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *apiClient) QueueMetaTxnReceipt(ctx context.Context, metaTxID string) (bool, error) {
	in := struct {
		Arg0 string `json:"metaTxID"`
	}{metaTxID}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[84], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

//
// Client helpers
//

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// urlBase helps ensure that addr specifies a scheme. If it is unparsable
// as a URL, it returns addr unchanged.
func urlBase(addr string) string {
	// If the addr specifies a scheme, use it. If not, default to
	// http. If url.Parse fails on it, return it unchanged.
	url, err := url.Parse(addr)
	if err != nil {
		return addr
	}
	if url.Scheme == "" {
		url.Scheme = "http"
	}
	return url.String()
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) {
	req, err := http.NewRequestWithContext(ctx, "POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", contentType)
	req.Header.Set("Content-Type", contentType)
	req.Header.Set(WebrpcHeader, WebrpcHeaderValue)
	if headers, ok := HTTPRequestHeaders(ctx); ok {
		for k := range headers {
			for _, v := range headers[k] {
				req.Header.Add(k, v)
			}
		}
	}
	return req, nil
}

// doHTTPRequest is common code to make a request to the remote service.
func doHTTPRequest(ctx context.Context, client HTTPClient, url string, in, out interface{}) (*http.Response, error) {
	reqBody, err := json.Marshal(in)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("failed to marshal JSON body: %w", err)
	}
	if err = ctx.Err(); err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("aborted because context was done: %w", err)
	}

	req, err := newRequest(ctx, url, bytes.NewBuffer(reqBody), "application/json")
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("could not build request: %w", err)
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(err)
	}

	if resp.StatusCode != 200 {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to read server error response body: %w", err)
		}

		var rpcErr WebRPCError
		if err := json.Unmarshal(respBody, &rpcErr); err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to unmarshal server error: %w", err)
		}
		if rpcErr.Cause != "" {
			rpcErr.cause = errors.New(rpcErr.Cause)
		}
		return nil, rpcErr
	}

	if out != nil {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to read response body: %w", err)
		}

		err = json.Unmarshal(respBody, &out)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to unmarshal JSON response body: %w", err)
		}
	}

	return resp, nil
}

func WithHTTPRequestHeaders(ctx context.Context, h http.Header) (context.Context, error) {
	if _, ok := h["Accept"]; ok {
		return nil, errors.New("provided header cannot set Accept")
	}
	if _, ok := h["Content-Type"]; ok {
		return nil, errors.New("provided header cannot set Content-Type")
	}

	copied := make(http.Header, len(h))
	for k, vv := range h {
		if vv == nil {
			copied[k] = nil
			continue
		}
		copied[k] = make([]string, len(vv))
		copy(copied[k], vv)
	}

	return context.WithValue(ctx, HTTPClientRequestHeadersCtxKey, copied), nil
}

func HTTPRequestHeaders(ctx context.Context) (http.Header, bool) {
	h, ok := ctx.Value(HTTPClientRequestHeadersCtxKey).(http.Header)
	return h, ok
}

//
// Webrpc helpers
//

type method struct {
	name        string
	service     string
	annotations map[string]string
}

func (m method) Name() string {
	return m.name
}

func (m method) Service() string {
	return m.service
}

func (m method) Annotations() map[string]string {
	res := make(map[string]string, len(m.annotations))
	for k, v := range m.annotations {
		res[k] = v
	}

	return res
}

type contextKey struct {
	name string
}

func (k *contextKey) String() string {
	return "webrpc context value " + k.name
}

var (
	HTTPClientRequestHeadersCtxKey = &contextKey{"HTTPClientRequestHeaders"} // client
	HTTPRequestCtxKey              = &contextKey{"HTTPRequest"}              // server
	ServiceNameCtxKey              = &contextKey{"ServiceName"}              // server
	MethodNameCtxKey               = &contextKey{"MethodName"}               // server
)

func ServiceNameFromContext(ctx context.Context) string {
	service, _ := ctx.Value(ServiceNameCtxKey).(string)
	return service
}

func MethodNameFromContext(ctx context.Context) string {
	method, _ := ctx.Value(MethodNameCtxKey).(string)
	return method
}

func RequestFromContext(ctx context.Context) *http.Request {
	r, _ := ctx.Value(HTTPRequestCtxKey).(*http.Request)
	return r
}

func MethodCtx(ctx context.Context) (method, bool) {
	req := RequestFromContext(ctx)
	if req == nil {
		return method{}, false
	}

	m, ok := methods[req.URL.Path]
	if !ok {
		return method{}, false
	}

	return m, true
}

// PtrTo is a useful helper when constructing values for optional fields.
func PtrTo[T any](v T) *T { return &v }

//
// Errors
//

type WebRPCError struct {
	Name       string `json:"error"`
	Code       int    `json:"code"`
	Message    string `json:"msg"`
	Cause      string `json:"cause,omitempty"`
	HTTPStatus int    `json:"status"`
	cause      error
}

var _ error = WebRPCError{}

func (e WebRPCError) Error() string {
	if e.cause != nil {
		return fmt.Sprintf("%s %d: %s: %v", e.Name, e.Code, e.Message, e.cause)
	}
	return fmt.Sprintf("%s %d: %s", e.Name, e.Code, e.Message)
}

func (e WebRPCError) Is(target error) bool {
	if target == nil {
		return false
	}
	if rpcErr, ok := target.(WebRPCError); ok {
		return rpcErr.Code == e.Code
	}
	return errors.Is(e.cause, target)
}

func (e WebRPCError) Unwrap() error {
	return e.cause
}

func (e WebRPCError) WithCause(cause error) WebRPCError {
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

func (e WebRPCError) WithCausef(format string, args ...interface{}) WebRPCError {
	cause := fmt.Errorf(format, args...)
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

// Deprecated: Use .WithCause() method on WebRPCError.
func ErrorWithCause(rpcErr WebRPCError, cause error) WebRPCError {
	return rpcErr.WithCause(cause)
}

// Webrpc errors
var (
	ErrWebrpcEndpoint       = WebRPCError{Code: 0, Name: "WebrpcEndpoint", Message: "endpoint error", HTTPStatus: 400}
	ErrWebrpcRequestFailed  = WebRPCError{Code: -1, Name: "WebrpcRequestFailed", Message: "request failed", HTTPStatus: 400}
	ErrWebrpcBadRoute       = WebRPCError{Code: -2, Name: "WebrpcBadRoute", Message: "bad route", HTTPStatus: 404}
	ErrWebrpcBadMethod      = WebRPCError{Code: -3, Name: "WebrpcBadMethod", Message: "bad method", HTTPStatus: 405}
	ErrWebrpcBadRequest     = WebRPCError{Code: -4, Name: "WebrpcBadRequest", Message: "bad request", HTTPStatus: 400}
	ErrWebrpcBadResponse    = WebRPCError{Code: -5, Name: "WebrpcBadResponse", Message: "bad response", HTTPStatus: 500}
	ErrWebrpcServerPanic    = WebRPCError{Code: -6, Name: "WebrpcServerPanic", Message: "server panic", HTTPStatus: 500}
	ErrWebrpcInternalError  = WebRPCError{Code: -7, Name: "WebrpcInternalError", Message: "internal error", HTTPStatus: 500}
	ErrWebrpcClientAborted  = WebRPCError{Code: -8, Name: "WebrpcClientAborted", Message: "request aborted by client", HTTPStatus: 400}
	ErrWebrpcStreamLost     = WebRPCError{Code: -9, Name: "WebrpcStreamLost", Message: "stream lost", HTTPStatus: 400}
	ErrWebrpcStreamFinished = WebRPCError{Code: -10, Name: "WebrpcStreamFinished", Message: "stream finished", HTTPStatus: 200}
)

// Schema errors
var (
	ErrUnauthorized       = WebRPCError{Code: 1000, Name: "Unauthorized", Message: "Unauthorized access", HTTPStatus: 401}
	ErrPermissionDenied   = WebRPCError{Code: 1001, Name: "PermissionDenied", Message: "Permission denied", HTTPStatus: 403}
	ErrSessionExpired     = WebRPCError{Code: 1002, Name: "SessionExpired", Message: "Session expired", HTTPStatus: 403}
	ErrMethodNotFound     = WebRPCError{Code: 1003, Name: "MethodNotFound", Message: "Method not found", HTTPStatus: 404}
	ErrRequestConflict    = WebRPCError{Code: 1004, Name: "RequestConflict", Message: "Conflict with target resource", HTTPStatus: 409}
	ErrAborted            = WebRPCError{Code: 1005, Name: "Aborted", Message: "Request aborted", HTTPStatus: 400}
	ErrGeoblocked         = WebRPCError{Code: 1006, Name: "Geoblocked", Message: "Geoblocked region", HTTPStatus: 451}
	ErrRateLimited        = WebRPCError{Code: 1007, Name: "RateLimited", Message: "Rate-limited. Please slow down.", HTTPStatus: 429}
	ErrProjectNotFound    = WebRPCError{Code: 1008, Name: "ProjectNotFound", Message: "Project not found", HTTPStatus: 401}
	ErrAccessKeyNotFound  = WebRPCError{Code: 1101, Name: "AccessKeyNotFound", Message: "Access key not found", HTTPStatus: 401}
	ErrAccessKeyMismatch  = WebRPCError{Code: 1102, Name: "AccessKeyMismatch", Message: "Access key mismatch", HTTPStatus: 409}
	ErrInvalidOrigin      = WebRPCError{Code: 1103, Name: "InvalidOrigin", Message: "Invalid origin for Access Key", HTTPStatus: 403}
	ErrInvalidService     = WebRPCError{Code: 1104, Name: "InvalidService", Message: "Service not enabled for Access key", HTTPStatus: 403}
	ErrUnauthorizedUser   = WebRPCError{Code: 1105, Name: "UnauthorizedUser", Message: "Unauthorized user", HTTPStatus: 403}
	ErrQuotaExceeded      = WebRPCError{Code: 1200, Name: "QuotaExceeded", Message: "Quota request exceeded", HTTPStatus: 429}
	ErrQuotaRateLimit     = WebRPCError{Code: 1201, Name: "QuotaRateLimit", Message: "Quota rate limit exceeded", HTTPStatus: 429}
	ErrNoDefaultKey       = WebRPCError{Code: 1300, Name: "NoDefaultKey", Message: "No default access key found", HTTPStatus: 403}
	ErrMaxAccessKeys      = WebRPCError{Code: 1301, Name: "MaxAccessKeys", Message: "Access keys limit reached", HTTPStatus: 403}
	ErrAtLeastOneKey      = WebRPCError{Code: 1302, Name: "AtLeastOneKey", Message: "You need at least one Access Key", HTTPStatus: 403}
	ErrTimeout            = WebRPCError{Code: 1900, Name: "Timeout", Message: "Request timed out", HTTPStatus: 408}
	ErrInvalidArgument    = WebRPCError{Code: 2000, Name: "InvalidArgument", Message: "Invalid argument", HTTPStatus: 400}
	ErrUnavailable        = WebRPCError{Code: 2002, Name: "Unavailable", Message: "Unavailable resource", HTTPStatus: 400}
	ErrQueryFailed        = WebRPCError{Code: 2003, Name: "QueryFailed", Message: "Query failed", HTTPStatus: 400}
	ErrNotFound           = WebRPCError{Code: 3000, Name: "NotFound", Message: "Resource not found", HTTPStatus: 400}
	ErrUnsupportedNetwork = WebRPCError{Code: 3008, Name: "UnsupportedNetwork", Message: "Unsupported network", HTTPStatus: 422}
)

//
// Webrpc
//

const WebrpcHeader = "Webrpc"

const WebrpcHeaderValue = "webrpc@v0.31.0;gen-golang@v0.23.1;sequence-api@v0.4.0"

type WebrpcGenVersions struct {
	WebrpcGenVersion string
	CodeGenName      string
	CodeGenVersion   string
	SchemaName       string
	SchemaVersion    string
}

func VersionFromHeader(h http.Header) (*WebrpcGenVersions, error) {
	if h.Get(WebrpcHeader) == "" {
		return nil, fmt.Errorf("header is empty or missing")
	}

	versions, err := parseWebrpcGenVersions(h.Get(WebrpcHeader))
	if err != nil {
		return nil, fmt.Errorf("webrpc header is invalid: %w", err)
	}

	return versions, nil
}

func parseWebrpcGenVersions(header string) (*WebrpcGenVersions, error) {
	versions := strings.Split(header, ";")
	if len(versions) < 3 {
		return nil, fmt.Errorf("expected at least 3 parts while parsing webrpc header: %v", header)
	}

	_, webrpcGenVersion, ok := strings.Cut(versions[0], "@")
	if !ok {
		return nil, fmt.Errorf("webrpc gen version could not be parsed from: %s", versions[0])
	}

	tmplTarget, tmplVersion, ok := strings.Cut(versions[1], "@")
	if !ok {
		return nil, fmt.Errorf("tmplTarget and tmplVersion could not be parsed from: %s", versions[1])
	}

	schemaName, schemaVersion, ok := strings.Cut(versions[2], "@")
	if !ok {
		return nil, fmt.Errorf("schema name and schema version could not be parsed from: %s", versions[2])
	}

	return &WebrpcGenVersions{
		WebrpcGenVersion: webrpcGenVersion,
		CodeGenName:      tmplTarget,
		CodeGenVersion:   tmplVersion,
		SchemaName:       schemaName,
		SchemaVersion:    schemaVersion,
	}, nil
}
