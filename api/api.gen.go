// sequence-api v0.4.0 7578ce7543fbe82fa6e423652b4fa3d384362329
// --
// Code generated by webrpc-gen@v0.18.7 with golang generator. DO NOT EDIT.
//
// webrpc-gen -schema=api.ridl -target=golang -pkg=api -client -out=./clients/api.gen.go
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"

	"github.com/0xsequence/go-sequence/lib/prototyp"
)

// WebRPC description and code-gen version
func WebRPCVersion() string {
	return "v1"
}

// Schema version of your RIDL schema
func WebRPCSchemaVersion() string {
	return "v0.4.0"
}

// Schema hash generated from your RIDL schema
func WebRPCSchemaHash() string {
	return "7578ce7543fbe82fa6e423652b4fa3d384362329"
}

//
// Common types
//

type SortOrder uint32

const (
	SortOrder_DESC SortOrder = 0
	SortOrder_ASC  SortOrder = 1
)

var SortOrder_name = map[uint32]string{
	0: "DESC",
	1: "ASC",
}

var SortOrder_value = map[string]uint32{
	"DESC": 0,
	"ASC":  1,
}

func (x SortOrder) String() string {
	return SortOrder_name[uint32(x)]
}

func (x SortOrder) MarshalText() ([]byte, error) {
	return []byte(SortOrder_name[uint32(x)]), nil
}

func (x *SortOrder) UnmarshalText(b []byte) error {
	*x = SortOrder(SortOrder_value[string(b)])
	return nil
}

func (x *SortOrder) Is(values ...SortOrder) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type SardinePaymentType uint32

const (
	SardinePaymentType_ach                  SardinePaymentType = 0
	SardinePaymentType_debit                SardinePaymentType = 1
	SardinePaymentType_credit               SardinePaymentType = 2
	SardinePaymentType_us_debit             SardinePaymentType = 3
	SardinePaymentType_international_debit  SardinePaymentType = 4
	SardinePaymentType_international_credit SardinePaymentType = 5
)

var SardinePaymentType_name = map[uint32]string{
	0: "ach",
	1: "debit",
	2: "credit",
	3: "us_debit",
	4: "international_debit",
	5: "international_credit",
}

var SardinePaymentType_value = map[string]uint32{
	"ach":                  0,
	"debit":                1,
	"credit":               2,
	"us_debit":             3,
	"international_debit":  4,
	"international_credit": 5,
}

func (x SardinePaymentType) String() string {
	return SardinePaymentType_name[uint32(x)]
}

func (x SardinePaymentType) MarshalText() ([]byte, error) {
	return []byte(SardinePaymentType_name[uint32(x)]), nil
}

func (x *SardinePaymentType) UnmarshalText(b []byte) error {
	*x = SardinePaymentType(SardinePaymentType_value[string(b)])
	return nil
}

func (x *SardinePaymentType) Is(values ...SardinePaymentType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type SardineQuoteType uint32

const (
	SardineQuoteType_buy  SardineQuoteType = 0
	SardineQuoteType_sell SardineQuoteType = 1
)

var SardineQuoteType_name = map[uint32]string{
	0: "buy",
	1: "sell",
}

var SardineQuoteType_value = map[string]uint32{
	"buy":  0,
	"sell": 1,
}

func (x SardineQuoteType) String() string {
	return SardineQuoteType_name[uint32(x)]
}

func (x SardineQuoteType) MarshalText() ([]byte, error) {
	return []byte(SardineQuoteType_name[uint32(x)]), nil
}

func (x *SardineQuoteType) UnmarshalText(b []byte) error {
	*x = SardineQuoteType(SardineQuoteType_value[string(b)])
	return nil
}

func (x *SardineQuoteType) Is(values ...SardineQuoteType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TokenType uint8

const (
	TokenType_ERC20   TokenType = 0
	TokenType_ERC721  TokenType = 1
	TokenType_ERC1155 TokenType = 2
)

var TokenType_name = map[uint8]string{
	0: "ERC20",
	1: "ERC721",
	2: "ERC1155",
}

var TokenType_value = map[string]uint8{
	"ERC20":   0,
	"ERC721":  1,
	"ERC1155": 2,
}

func (x TokenType) String() string {
	return TokenType_name[uint8(x)]
}

func (x TokenType) MarshalText() ([]byte, error) {
	return []byte(TokenType_name[uint8(x)]), nil
}

func (x *TokenType) UnmarshalText(b []byte) error {
	*x = TokenType(TokenType_value[string(b)])
	return nil
}

func (x *TokenType) Is(values ...TokenType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type Version struct {
	WebrpcVersion string `json:"webrpcVersion"`
	SchemaVersion string `json:"schemaVersion"`
	SchemaHash    string `json:"schemaHash"`
	AppVersion    string `json:"appVersion"`
}

type RuntimeStatus struct {
	// overall status, true/false
	HealthOK       bool                       `json:"healthOK"`
	StartTime      time.Time                  `json:"startTime"`
	Uptime         uint64                     `json:"uptime"`
	Ver            string                     `json:"ver"`
	Branch         string                     `json:"branch"`
	CommitHash     string                     `json:"commitHash"`
	Checks         *RuntimeChecks             `json:"checks"`
	NumTxnsRelayed map[string]*NumTxnsRelayed `json:"numTxnsRelayed"`
}

type NumTxnsRelayed struct {
	ChainID uint64 `json:"chainID"`
	Prev    uint64 `json:"prev"`
	Current uint64 `json:"current"`
	Period  uint64 `json:"period"`
}

type RuntimeChecks struct {
}

type SequenceContext struct {
	Factory              string `json:"factory"`
	MainModule           string `json:"mainModule"`
	MainModuleUpgradable string `json:"mainModuleUpgradable"`
	GuestModule          string `json:"guestModule"`
	Utils                string `json:"utils"`
}

// Users
type User struct {
	Address            prototyp.Hash `json:"address" db:"address"`
	Username           string        `json:"username" db:"username"`
	NormalizedUsername string        `json:"-" db:"normalized_username"`
	Avatar             string        `json:"avatar" db:"avatar"`
	Bio                string        `json:"bio" db:"bio"`
	Location           string        `json:"location" db:"location"`
	Locale             string        `json:"locale" db:"locale"`
	Backup             *bool         `json:"backup,omitempty" db:"-"`
	BackupConfirmed    *bool         `json:"backupConfirmed,omitempty" db:"-"`
	MaxInvites         *uint32       `json:"maxInvites" db:"max_invites"`
	UpdatedAt          *time.Time    `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt          *time.Time    `json:"createdAt,omitempty" db:"created_at,omitempty"`
	SysAdmin           bool          `json:"-" db:"sys_admin"`
}

// Wallet Backup
type WalletBackup struct {
	AccountAddress  prototyp.Hash `json:"accountAddress" db:"account_address"`
	SecretHash      string        `json:"secretHash" db:"secret_hash"`
	EncryptedWallet string        `json:"encryptedWallet" db:"encrypted_wallet"`
	// userConfirmed is a flag that the user tells us they've backed up
	// their wallet mnemonic for future recovery. It's just a user-experience field
	// so we can nag them if they haven't confirmed yet.
	UserConfirmed bool       `json:"userConfirmed" db:"user_confirmed"`
	UpdatedAt     *time.Time `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt     *time.Time `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// Friends
type Friend struct {
	ID            uint64        `json:"id" db:"id,omitempty"`
	UserAddress   prototyp.Hash `json:"userAddress" db:"user_address"`
	FriendAddress prototyp.Hash `json:"friendAddress" db:"friend_address"`
	// Nickname allows the user to assign a friend a label, useful for the case
	// when that friend doesn't have an arcadeum user account
	Nickname  string     `json:"nickname" db:"nickname"`
	User      *User      `json:"user" db:"-"`
	CreatedAt *time.Time `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// InviteCode
type InviteCode struct {
	Code         string             `json:"-" db:"code"`
	Source       string             `json:"-" db:"source"`
	UsesLeft     uint32             `json:"usesLeft" db:"uses_left"`
	OwnerAccount prototyp.HashMaybe `json:"ownerAccount" db:"owner_account"`
	Email        *string            `json:"email" db:"email"`
	Url          string             `json:"url"`
	CreatedAt    *time.Time         `json:"createdAt,omitempty" db:"created_at,omitempty"`
	ExpiresAt    *time.Time         `json:"expiresAt,omitempty" db:"expires_at,omitempty"`
}

// InviteCode Account
type InviteCodeAccount struct {
	Code                 string        `json:"-" db:"code"`
	ClaimedByUserAddress prototyp.Hash `json:"claimedByUserAddress" db:"claimed_by_user_address"`
	ClaimedAt            *time.Time    `json:"claimedAt,omitempty" db:"claimed_at,omitempty"`
}

// Invite info
type InviteInfo struct {
	ExpiryInHours uint32        `json:"expiryInHours"`
	Max           uint32        `json:"max"`
	Invites       []*InviteCode `json:"invites"`
}

type ContractCall struct {
	Signature string            `json:"signature"`
	Function  string            `json:"function"`
	Args      []*TupleComponent `json:"args"`
}

type TupleComponent struct {
	Name  *string     `json:"name"`
	Type  string      `json:"type"`
	Value interface{} `json:"value"`
}

type Transaction struct {
	DelegateCall  bool            `json:"delegateCall"`
	RevertOnError bool            `json:"revertOnError"`
	GasLimit      prototyp.BigInt `json:"gasLimit"`
	Target        string          `json:"target"`
	Value         prototyp.BigInt `json:"value"`
	Data          string          `json:"data"`
	Call          *ContractCall   `json:"call"`
}

type UserStorage struct {
	UserAddress prototyp.Hash       `json:"userAddress" db:"user_address"`
	Key         string              `json:"key"`
	Value       prototyp.JSONString `json:"value"`
}

type Token struct {
	ChainId         uint64        `json:"chainId"`
	ContractAddress prototyp.Hash `json:"contractAddress"`
	TokenId         *string       `json:"tokenId"`
}

type Price struct {
	Value    float64 `json:"value"`
	Currency string  `json:"currency"`
}

type TokenPrice struct {
	Token          *Token     `json:"token"`
	Price          *Price     `json:"price"`
	Price24hChange *Price     `json:"price24hChange"`
	FloorPrice     *Price     `json:"floorPrice,omitempty"`
	BuyPrice       *Price     `json:"buyPrice,omitempty"`
	SellPrice      *Price     `json:"sellPrice,omitempty"`
	UpdatedAt      *time.Time `json:"updatedAt"`
}

type ExchangeRate struct {
	Name         string  `json:"name"`
	Symbol       string  `json:"symbol"`
	Value        float64 `json:"value"`
	VsCurrency   string  `json:"vsCurrency"`
	CurrencyType string  `json:"currencyType"`
}

type LinkedWallet struct {
	ID                  uint64        `json:"id" db:"id,omitempty"`
	WalletAddress       prototyp.Hash `json:"walletAddress" db:"wallet_address"`
	LinkedWalletAddress prototyp.Hash `json:"linkedWalletAddress" db:"linked_wallet_address"`
	CreatedAt           *time.Time    `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// TOOD: refactor, we should be returning a cursor always..
// see indexer/indexer.ridl Page object..
//
// ---
//
// Page represents a results page. This can be used both to request a page and
// to store the state of a page.
type Page struct {
	// Common for both numbered pages and cursor: Number of items per page
	// TODO: REMOVE..
	PageSize *uint32 `json:"pageSize"`
	// Numbered pages: Page number, this is multiplied by the value of the <pageSize> parameter.
	// TODO: REMOVE..
	Page *uint32 `json:"page"`
	// Number of total items on this query.
	// TODO: REMOVE..
	TotalRecords *uint64 `json:"totalRecords"`
	// Cursor: column to compare before/after to
	Column *string `json:"column"`
	// Cursor: return column < before - include to get previous page
	Before *interface{} `json:"before"`
	// Cursor: return column > after - include to get next page
	After *interface{} `json:"after"`
	// Sorting filter
	Sort []*SortBy `json:"sort"`
	// Indicates if there are more results available
	More *bool `json:"more,omitempty"`
}

type SortBy struct {
	Column string    `json:"column"`
	Order  SortOrder `json:"order"`
}

type SardineNFTCheckoutParams struct {
	Name                   string  `json:"name"`
	ImageURL               string  `json:"imageUrl"`
	Network                string  `json:"network"`
	RecipientAddress       string  `json:"recipientAddress"`
	BlockchainNFTID        string  `json:"blockchainNftId"`
	ContractAddress        string  `json:"contractAddress"`
	Quantity               int     `json:"quantity"`
	Decimals               *int    `json:"decimals"`
	TokenAmount            string  `json:"tokenAmount"`
	TokenAddress           string  `json:"tokenAddress"`
	TokenSymbol            string  `json:"tokenSymbol"`
	TokenDecimals          *int    `json:"tokenDecimals"`
	Calldata               string  `json:"calldata"`
	Platform               string  `json:"platform"`
	ApprovedSpenderAddress *string `json:"approvedSpenderAddress"`
}

type SardineNFTCheckout struct {
	Token     string `json:"token"`
	ExpiresAt string `json:"expiresAt"`
	OrderID   string `json:"orderId"`
}

type SardineOrder struct {
	ID                  string     `json:"id"`
	CreatedAt           *time.Time `json:"createdAt"`
	ReferenceID         string     `json:"referenceId"`
	Status              string     `json:"status"`
	FiatCurrency        string     `json:"fiatCurrency"`
	FiatExchangeRateUSD float64    `json:"fiatExchangeRateUSD"`
	TransactionID       string     `json:"transactionId"`
	ExpiresAt           *time.Time `json:"expiresAt"`
	Total               float64    `json:"total"`
	SubTotal            float64    `json:"subTotal"`
	TransactionFee      float64    `json:"transactionFee"`
	NetworkFee          float64    `json:"networkFee"`
	PaymentCurrency     *string    `json:"paymentCurrency"`
	PaymentMethodType   *string    `json:"paymentMethodType"`
	TransactionType     string     `json:"transactionType"`
	Name                string     `json:"name"`
	Price               int        `json:"price"`
	ImageURL            string     `json:"imageUrl"`
	ContractAddress     *string    `json:"contractAddress"`
	TransactionHash     *string    `json:"transactionHash"`
	RecipientAddress    string     `json:"recipientAddress"`
}

type SardineRegion struct {
	CountryCode        string                        `json:"countryCode"`
	IsAllowedOnRamp    bool                          `json:"isAllowedOnRamp"`
	IsAllowedOnNFT     bool                          `json:"isAllowedOnNFT"`
	IsBasicKycRequired []string                      `json:"isBasicKycRequired"`
	IsSsnRequired      []string                      `json:"isSsnRequired"`
	Name               string                        `json:"name"`
	CurrencyCode       string                        `json:"currencyCode"`
	IsPayrollSupported bool                          `json:"isPayrollSupported"`
	SupportedDocuments []string                      `json:"supportedDocuments"`
	PaymentMethods     []*SardineRegionPaymentMethod `json:"paymentMethods"`
	States             []*SardineRegionState         `json:"states"`
}

type SardineRegionPaymentMethod struct {
	Name            string   `json:"name"`
	IsAllowedOnRamp bool     `json:"isAllowedOnRamp"`
	IsAllowedOnNFT  bool     `json:"isAllowedOnNFT"`
	SubTypes        []string `json:"subTypes"`
	Type            string   `json:"type"`
	SubType         string   `json:"subType"`
}

type SardineRegionState struct {
	Code            string `json:"code"`
	Name            string `json:"name"`
	IsAllowedOnRamp bool   `json:"isAllowedOnRamp"`
	IsAllowedOnNFT  bool   `json:"isAllowedOnNFT"`
}

type SardineSupportedToken struct {
	Network      string `json:"network,omitempty"`
	AssetSymbol  string `json:"assetSymbol,omitempty"`
	AssetName    string `json:"assetName,omitempty"`
	ChainID      string `json:"chainId,omitempty"`
	TokenName    string `json:"tokenName,omitempty"`
	Token        string `json:"token,omitempty"`
	TokenAddress string `json:"tokenAddress,omitempty"`
}

type SardineEnabledToken struct {
	Network      string `json:"network,omitempty"`
	AssetSymbol  string `json:"assetSymbol,omitempty"`
	AssetName    string `json:"assetName,omitempty"`
	ChainID      string `json:"chainId,omitempty"`
	TokenName    string `json:"tokenName,omitempty"`
	Token        string `json:"token,omitempty"`
	TokenAddress string `json:"tokenAddress,omitempty"`
}

type SardineGetQuoteParams struct {
	// Cryptocurrency asset user wants to purchase
	AssetType string `json:"assetType"`
	// Blockchain on which the asset_type is present
	Network string `json:"network"`
	// Amount the user wants to buy or sell.
	Total uint64 `json:"total"`
	// The currency type in which the quote is supplied. Default 'USD'
	Currency *string `json:"currency"`
	// The payment method that the user will use for the transaction
	PaymentType *SardinePaymentType `json:"paymentType"`
	// Select for the required activity buy for on ramp and sell for off ramp. Default 'buy'
	QuoteType *SardineQuoteType `json:"quoteType"`
	// Wallet address of User. This is used to calculate if User has previously used Sardine, and provide them with a more accurate quote.
	WalletAddress *string `json:"walletAddress"`
}

type SardineQuote struct {
	Quantity            float64 `json:"quantity"`
	Network             string  `json:"network"`
	AssetType           string  `json:"assetType"`
	Total               float64 `json:"total"`
	Currency            string  `json:"currency"`
	ExpiresAt           string  `json:"expiresAt"`
	PaymentType         string  `json:"paymentType"`
	Price               float64 `json:"price"`
	Subtotal            float64 `json:"subtotal"`
	TransactionFee      float64 `json:"transactionFee"`
	NetworkFee          float64 `json:"networkFee"`
	HighNetworkFee      bool    `json:"highNetworkFee"`
	MinTransactionValue float64 `json:"minTransactionValue"`
	MaxTransactionValue float64 `json:"maxTransactionValue"`
	LiquidityProvider   string  `json:"liquidityProvider"`
}

type SardineFiatCurrency struct {
	CurrencyCode        string                  `json:"currencyCode"`
	Name                string                  `json:"name"`
	CurrencySymbol      string                  `json:"currencySymbol"`
	PaymentOptions      []*SardinePaymentOption `json:"paymentOptions"`
	SupportingCountries []string                `json:"supportingCountries"`
}

type SardinePaymentOption struct {
	Name           string   `json:"name"`
	DailyLimit     float64  `json:"dailyLimit"`
	WeeklyLimit    float64  `json:"weeklyLimit"`
	MonthlyLimit   float64  `json:"monthlyLimit"`
	MaxAmount      float64  `json:"maxAmount"`
	MinAmount      float64  `json:"minAmount"`
	SubTypes       []string `json:"subTypes"`
	Type           string   `json:"type"`
	SubType        string   `json:"subType"`
	ProcessingTime string   `json:"processingTime"`
}

type SwapQuote struct {
	CurrencyAddress string          `json:"currencyAddress"`
	CurrencyBalance prototyp.BigInt `json:"currencyBalance"`
	Price           prototyp.BigInt `json:"price"`
	// Guaranteed price for the swap.
	MaxPrice prototyp.BigInt `json:"maxPrice"`
	// to must be approved to access maxPrice of currencyAddress for the sender
	To               string          `json:"to"`
	TransactionData  string          `json:"transactionData"`
	TransactionValue prototyp.BigInt `json:"transactionValue"`
	// Supplied when includeApprove is true
	ApproveData string `json:"approveData"`
}

// Cross chain matching tokens
type CurrencyGroup struct {
	ID     uint64                `json:"id" db:"id,omitempty"`
	Name   string                `json:"name" db:"name"`
	Tokens []*CurrencyGroupToken `json:"tokens"`
}

type CurrencyGroupToken struct {
	ID              uint64        `json:"id" db:"id,omitempty"`
	CurrencyGroupID uint64        `json:"currencyGroupId" db:"currency_group_id"`
	ChainID         uint64        `json:"chainId" db:"chain_id"`
	TokenAddress    prototyp.Hash `json:"tokenAddress" db:"token_address"`
}

type InventoryPaymentConfig struct {
	ID                  uint64        `json:"id" db:"id,omitempty"`
	ProjectID           uint64        `json:"projectId" db:"project_id"`
	ChainID             uint64        `json:"chainId" db:"chain_id"`
	ExternalProductID   string        `json:"externalProductId" db:"external_product_id"`
	PaymentTokenAddress prototyp.Hash `json:"paymentTokenAddress" db:"payment_token_address"`
	PaymentTokenType    TokenType     `json:"paymentTokenType" db:"payment_token_type"`
	PaymentTokenID      uint64        `json:"paymentTokenId" db:"payment_token_id"`
	PaymentAmount       uint64        `json:"paymentAmount" db:"payment_amount"`
	PaymentRecipient    prototyp.Hash `json:"paymentRecipient" db:"payment_recipient"`
	ChainedCallAddress  prototyp.Hash `json:"chainedCallAddress" db:"chained_call_address"`
	// product recipient address is added as the first argument (after selector)
	ChainedCallData         *string    `json:"chainedCallData" db:"chained_call_data"`
	AllowCrossChainPayments *bool      `json:"allowCrossChainPayments" db:"allow_cross_chain_payments"`
	CallbackURL             *string    `json:"callbackURL" db:"callback_url,omitempty"`
	CreatedAt               *time.Time `json:"createdAt" db:"created_at,omitempty"`
	DeletedAt               *time.Time `json:"-" db:"deleted_at,omitempty"`
}

type InventoryPayment struct {
	ID                       uint64        `json:"id" db:"id,omitempty"`
	InventoryPaymentConfigID uint64        `json:"inventoryPaymentConfigId" db:"inventory_payment_config_id"`
	ProductRecipient         prototyp.Hash `json:"productRecipient" db:"product_recipient"`
	PaymentChainID           uint64        `json:"paymentChainId" db:"payment_chain_id"`
	PaymentTokenAddress      prototyp.Hash `json:"paymentTokenAddress" db:"payment_token_address"`
	Expiration               *time.Time    `json:"expiration" db:"expiration"`
	CreatedAt                *time.Time    `json:"createdAt" db:"created_at"`
	CompletedAt              *time.Time    `json:"completedAt" db:"completed_at"`
	ProcessedAt              *time.Time    `json:"processedAt" db:"processed_at"`
}

type InventoryPaymentResponse struct {
	PaymentID                uint64        `json:"paymentId"`
	InventoryPaymentConfigID uint64        `json:"inventoryPaymentConfigId"`
	ChainID                  uint64        `json:"chainId"`
	ExternalProductID        string        `json:"externalProductId"`
	PaymentTokenAddress      prototyp.Hash `json:"paymentTokenAddress"`
	PaymentTokenType         TokenType     `json:"paymentTokenType"`
	PaymentTokenID           uint64        `json:"paymentTokenId"`
	PaymentTotal             uint64        `json:"paymentTotal"`
	Expiration               *time.Time    `json:"expiration"`
	Signature                string        `json:"signature"`
	TxTo                     prototyp.Hash `json:"txTo"`
	TxData                   string        `json:"txData"`
}

var WebRPCServices = map[string][]string{
	"API": {
		"Ping",
		"Version",
		"RuntimeStatus",
		"Clock",
		"GetSequenceContext",
		"GetAuthToken",
		"GetAuthToken2",
		"SendPasswordlessLink",
		"FriendList",
		"GetFriendByAddress",
		"SearchFriends",
		"AddFriend",
		"UpdateFriendNickname",
		"RemoveFriend",
		"ContractCall",
		"DecodeContractCall",
		"LookupContractCallSelectors",
		"UserStorageFetch",
		"UserStorageSave",
		"UserStorageDelete",
		"UserStorageFetchAll",
		"GetMoonpayLink",
		"ResolveENSAddress",
		"IsValidSignature",
		"IsValidMessageSignature",
		"IsValidTypedDataSignature",
		"IsValidETHAuthProof",
		"SardineGetClientToken",
		"SardineGetNFTCheckoutToken",
		"SardineGetNFTCheckoutOrderStatus",
		"SardineGetSupportedRegions",
		"SardineGetSupportedFiatCurrencies",
		"SardineGetSupportedTokens",
		"SardineGetEnabledTokens",
		"SardineGetQuote",
		"GetSardineClientToken",
		"GetSardineNFTCheckoutToken",
		"GetSardineNFTCheckoutOrderStatus",
		"GetCoinPrices",
		"GetCollectiblePrices",
		"GetExchangeRate",
		"MemoryStore",
		"MemoryLoad",
		"GetInviteInfo",
		"IsValidAccessCode",
		"InternalClaimAccessCode",
		"BlockNumberAtTime",
		"PaperSessionSecret",
		"PaperSessionSecret2",
		"LinkWallet",
		"GetLinkedWallets",
		"RemoveLinkedWallet",
		"GenerateWaaSVerificationURL",
		"ValidateWaaSVerificationNonce",
		"GetSwapQuotes",
		"AddCurrencyGroup",
		"UpdateCurrencyGroup",
		"ListCurrencyGroups",
		"DeleteCurrencyGroup",
		"AddInventoryPaymentConfig",
		"GetInventoryPaymentConfig",
		"ListInventoryPaymentConfigs",
		"UpdateInventoryPaymentConfig",
		"DeleteInventoryPaymentConfig",
		"RequestInventoryPayment",
	},
}

//
// Server types
//

type API interface {
	//
	// Runtime
	//
	Ping(ctx context.Context) (bool, error)
	Version(ctx context.Context) (*Version, error)
	RuntimeStatus(ctx context.Context) (*RuntimeStatus, error)
	Clock(ctx context.Context) (time.Time, error)
	GetSequenceContext(ctx context.Context) (*SequenceContext, error)
	//
	// Auth
	//
	// TODO: rename 'ewtString' arg to 'ethauthProof'
	GetAuthToken(ctx context.Context, ewtString string, testnetMode *bool) (bool, string, string, *User, error)
	GetAuthToken2(ctx context.Context, ewtString string, chainID string) (bool, string, string, *User, error)
	SendPasswordlessLink(ctx context.Context, email string, redirectUri string, intent string) (bool, error)
	//
	// Contacts / Friends
	//
	FriendList(ctx context.Context, nickname *string, page *Page) (*Page, []*Friend, error)
	GetFriendByAddress(ctx context.Context, friendAddress string) (bool, *Friend, error)
	SearchFriends(ctx context.Context, filterUsername string, page *Page) ([]*Friend, error)
	AddFriend(ctx context.Context, friendAddress string, optionalNickname *string) (bool, *Friend, error)
	UpdateFriendNickname(ctx context.Context, friendAddress string, nickname string) (bool, *Friend, error)
	RemoveFriend(ctx context.Context, friendAddress string) (bool, error)
	//
	// Chain-Utils
	//
	ContractCall(ctx context.Context, chainID string, contract string, inputExpr string, outputExpr string, args []string) ([]string, error)
	DecodeContractCall(ctx context.Context, callData string) (*ContractCall, error)
	LookupContractCallSelectors(ctx context.Context, selectors []string) ([][]string, error)
	//
	// User Storage
	//
	UserStorageFetch(ctx context.Context, key string) (interface{}, error)
	UserStorageSave(ctx context.Context, key string, object interface{}) (bool, error)
	UserStorageDelete(ctx context.Context, key string) (bool, error)
	UserStorageFetchAll(ctx context.Context, keys []string) (map[string]interface{}, error)
	//
	// Wallet utils
	//
	GetMoonpayLink(ctx context.Context, url string) (string, error)
	// - IsUsingGoogleMail(domain: string) => (yes: bool)
	ResolveENSAddress(ctx context.Context, ens string) (string, bool, error)
	// TODO: we can add walletContext optional in the future when we need it
	// NOTE: chainId can be either a number or canonical name
	IsValidSignature(ctx context.Context, chainId string, walletAddress string, digest string, signature string) (bool, error)
	IsValidMessageSignature(ctx context.Context, chainId string, walletAddress string, message string, signature string) (bool, error)
	IsValidTypedDataSignature(ctx context.Context, chainId string, walletAddress string, typedData interface{}, signature string) (bool, error)
	IsValidETHAuthProof(ctx context.Context, chainId string, walletAddress string, ethAuthProofString string) (bool, error)
	SardineGetClientToken(ctx context.Context) (string, error)
	SardineGetNFTCheckoutToken(ctx context.Context, params *SardineNFTCheckoutParams) (*SardineNFTCheckout, error)
	SardineGetNFTCheckoutOrderStatus(ctx context.Context, orderId string) (*SardineOrder, error)
	SardineGetSupportedRegions(ctx context.Context) ([]*SardineRegion, error)
	SardineGetSupportedFiatCurrencies(ctx context.Context) ([]*SardineFiatCurrency, error)
	SardineGetSupportedTokens(ctx context.Context) ([]*SardineSupportedToken, error)
	SardineGetEnabledTokens(ctx context.Context) ([]*SardineEnabledToken, error)
	SardineGetQuote(ctx context.Context, params *SardineGetQuoteParams) (*SardineQuote, error)
	// Deprecated use SardineGetClientToken()
	GetSardineClientToken(ctx context.Context) (string, error)
	// Deprecated use SardineGetNFTCheckoutToken()
	GetSardineNFTCheckoutToken(ctx context.Context, params *SardineNFTCheckoutParams) (*SardineNFTCheckout, error)
	// Deprecated use SardineGetNFTCheckoutOrderStatus()
	GetSardineNFTCheckoutOrderStatus(ctx context.Context, orderId string) (*SardineOrder, error)
	//
	// Price Feed
	//
	GetCoinPrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
	GetCollectiblePrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
	//
	// Price Feed utils
	//
	GetExchangeRate(ctx context.Context, toCurrency string) (*ExchangeRate, error)
	//
	// Util / misc
	//
	MemoryStore(ctx context.Context, key string, value string) (bool, error)
	MemoryLoad(ctx context.Context, key string) (string, error)
	//
	// Legacy
	//
	GetInviteInfo(ctx context.Context) (*InviteInfo, error)
	// NOTE: we're still using this from SW-API to Sequence-API to claim invite code
	IsValidAccessCode(ctx context.Context, accessCode string) (bool, error)
	InternalClaimAccessCode(ctx context.Context, address string, accessCode string) (bool, error)
	// Utils
	BlockNumberAtTime(ctx context.Context, chainId uint64, timestamps []uint64) ([]uint64, error)
	//
	// Paper
	// TODO: deprecate in the future
	//
	PaperSessionSecret(ctx context.Context, chainName string, contractAddress string, paramsJson string, contractType string) (string, error)
	PaperSessionSecret2(ctx context.Context, chainName string, contractAddress string, paramsJson string, abi string) (string, error)
	//
	// Linked wallets (v0 -- simple support)
	//
	LinkWallet(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, linkedWalletAddress string, linkedWalletMessage string, linkedWalletSignature string, signatureChainId string) (bool, error)
	GetLinkedWallets(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, signatureChainId string) ([]string, error)
	RemoveLinkedWallet(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, linkedWalletAddress string, linkedWalletMessage string, linkedWalletSignature string, signatureChainId string) (bool, error)
	// NOTE: these methods are deprecated, please do not use them. We may resurface them in the future, but just wanted
	// to be clear, they are not necessary for our linked wallets.
	GenerateWaaSVerificationURL(ctx context.Context, walletAddress string) (string, string, error)
	ValidateWaaSVerificationNonce(ctx context.Context, nonce string, signature string, sessionId string, chainId string) (string, error)
	//
	// Currency abstraction
	//
	GetSwapQuotes(ctx context.Context, userAddress string, currencyAddress string, currencyAmount string, chainId uint64, includeApprove bool) ([]*SwapQuote, error)
	//
	// Inventory, payments and management
	//
	AddCurrencyGroup(ctx context.Context, currencyGroup *CurrencyGroup) (uint64, error)
	UpdateCurrencyGroup(ctx context.Context, currencyGroup *CurrencyGroup) error
	ListCurrencyGroups(ctx context.Context) ([]*CurrencyGroup, error)
	DeleteCurrencyGroup(ctx context.Context, groupId uint64) (bool, error)
	AddInventoryPaymentConfig(ctx context.Context, config *InventoryPaymentConfig) (uint64, error)
	GetInventoryPaymentConfig(ctx context.Context, configId uint64) (*InventoryPaymentConfig, error)
	ListInventoryPaymentConfigs(ctx context.Context, projectId uint64) ([]*InventoryPaymentConfig, error)
	UpdateInventoryPaymentConfig(ctx context.Context, config *InventoryPaymentConfig) error
	DeleteInventoryPaymentConfig(ctx context.Context, configId uint64) (bool, error)
	RequestInventoryPayment(ctx context.Context, configId uint64, recipient string, chainId *uint64, tokenAddress *string) (*InventoryPaymentResponse, error)
}

//
// Client types
//

type APIClient interface {
	//
	// Runtime
	//
	Ping(ctx context.Context) (bool, error)
	Version(ctx context.Context) (*Version, error)
	RuntimeStatus(ctx context.Context) (*RuntimeStatus, error)
	Clock(ctx context.Context) (time.Time, error)
	GetSequenceContext(ctx context.Context) (*SequenceContext, error)
	//
	// Auth
	//
	// TODO: rename 'ewtString' arg to 'ethauthProof'
	GetAuthToken(ctx context.Context, ewtString string, testnetMode *bool) (bool, string, string, *User, error)
	GetAuthToken2(ctx context.Context, ewtString string, chainID string) (bool, string, string, *User, error)
	SendPasswordlessLink(ctx context.Context, email string, redirectUri string, intent string) (bool, error)
	//
	// Contacts / Friends
	//
	FriendList(ctx context.Context, nickname *string, page *Page) (*Page, []*Friend, error)
	GetFriendByAddress(ctx context.Context, friendAddress string) (bool, *Friend, error)
	SearchFriends(ctx context.Context, filterUsername string, page *Page) ([]*Friend, error)
	AddFriend(ctx context.Context, friendAddress string, optionalNickname *string) (bool, *Friend, error)
	UpdateFriendNickname(ctx context.Context, friendAddress string, nickname string) (bool, *Friend, error)
	RemoveFriend(ctx context.Context, friendAddress string) (bool, error)
	//
	// Chain-Utils
	//
	ContractCall(ctx context.Context, chainID string, contract string, inputExpr string, outputExpr string, args []string) ([]string, error)
	DecodeContractCall(ctx context.Context, callData string) (*ContractCall, error)
	LookupContractCallSelectors(ctx context.Context, selectors []string) ([][]string, error)
	//
	// User Storage
	//
	UserStorageFetch(ctx context.Context, key string) (interface{}, error)
	UserStorageSave(ctx context.Context, key string, object interface{}) (bool, error)
	UserStorageDelete(ctx context.Context, key string) (bool, error)
	UserStorageFetchAll(ctx context.Context, keys []string) (map[string]interface{}, error)
	//
	// Wallet utils
	//
	GetMoonpayLink(ctx context.Context, url string) (string, error)
	// - IsUsingGoogleMail(domain: string) => (yes: bool)
	ResolveENSAddress(ctx context.Context, ens string) (string, bool, error)
	// TODO: we can add walletContext optional in the future when we need it
	// NOTE: chainId can be either a number or canonical name
	IsValidSignature(ctx context.Context, chainId string, walletAddress string, digest string, signature string) (bool, error)
	IsValidMessageSignature(ctx context.Context, chainId string, walletAddress string, message string, signature string) (bool, error)
	IsValidTypedDataSignature(ctx context.Context, chainId string, walletAddress string, typedData interface{}, signature string) (bool, error)
	IsValidETHAuthProof(ctx context.Context, chainId string, walletAddress string, ethAuthProofString string) (bool, error)
	SardineGetClientToken(ctx context.Context) (string, error)
	SardineGetNFTCheckoutToken(ctx context.Context, params *SardineNFTCheckoutParams) (*SardineNFTCheckout, error)
	SardineGetNFTCheckoutOrderStatus(ctx context.Context, orderId string) (*SardineOrder, error)
	SardineGetSupportedRegions(ctx context.Context) ([]*SardineRegion, error)
	SardineGetSupportedFiatCurrencies(ctx context.Context) ([]*SardineFiatCurrency, error)
	SardineGetSupportedTokens(ctx context.Context) ([]*SardineSupportedToken, error)
	SardineGetEnabledTokens(ctx context.Context) ([]*SardineEnabledToken, error)
	SardineGetQuote(ctx context.Context, params *SardineGetQuoteParams) (*SardineQuote, error)
	// Deprecated use SardineGetClientToken()
	GetSardineClientToken(ctx context.Context) (string, error)
	// Deprecated use SardineGetNFTCheckoutToken()
	GetSardineNFTCheckoutToken(ctx context.Context, params *SardineNFTCheckoutParams) (*SardineNFTCheckout, error)
	// Deprecated use SardineGetNFTCheckoutOrderStatus()
	GetSardineNFTCheckoutOrderStatus(ctx context.Context, orderId string) (*SardineOrder, error)
	//
	// Price Feed
	//
	GetCoinPrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
	GetCollectiblePrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
	//
	// Price Feed utils
	//
	GetExchangeRate(ctx context.Context, toCurrency string) (*ExchangeRate, error)
	//
	// Util / misc
	//
	MemoryStore(ctx context.Context, key string, value string) (bool, error)
	MemoryLoad(ctx context.Context, key string) (string, error)
	//
	// Legacy
	//
	GetInviteInfo(ctx context.Context) (*InviteInfo, error)
	// NOTE: we're still using this from SW-API to Sequence-API to claim invite code
	IsValidAccessCode(ctx context.Context, accessCode string) (bool, error)
	InternalClaimAccessCode(ctx context.Context, address string, accessCode string) (bool, error)
	// Utils
	BlockNumberAtTime(ctx context.Context, chainId uint64, timestamps []uint64) ([]uint64, error)
	//
	// Paper
	// TODO: deprecate in the future
	//
	PaperSessionSecret(ctx context.Context, chainName string, contractAddress string, paramsJson string, contractType string) (string, error)
	PaperSessionSecret2(ctx context.Context, chainName string, contractAddress string, paramsJson string, abi string) (string, error)
	//
	// Linked wallets (v0 -- simple support)
	//
	LinkWallet(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, linkedWalletAddress string, linkedWalletMessage string, linkedWalletSignature string, signatureChainId string) (bool, error)
	GetLinkedWallets(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, signatureChainId string) ([]string, error)
	RemoveLinkedWallet(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, linkedWalletAddress string, linkedWalletMessage string, linkedWalletSignature string, signatureChainId string) (bool, error)
	// NOTE: these methods are deprecated, please do not use them. We may resurface them in the future, but just wanted
	// to be clear, they are not necessary for our linked wallets.
	GenerateWaaSVerificationURL(ctx context.Context, walletAddress string) (string, string, error)
	ValidateWaaSVerificationNonce(ctx context.Context, nonce string, signature string, sessionId string, chainId string) (string, error)
	//
	// Currency abstraction
	//
	GetSwapQuotes(ctx context.Context, userAddress string, currencyAddress string, currencyAmount string, chainId uint64, includeApprove bool) ([]*SwapQuote, error)
	//
	// Inventory, payments and management
	//
	AddCurrencyGroup(ctx context.Context, currencyGroup *CurrencyGroup) (uint64, error)
	UpdateCurrencyGroup(ctx context.Context, currencyGroup *CurrencyGroup) error
	ListCurrencyGroups(ctx context.Context) ([]*CurrencyGroup, error)
	DeleteCurrencyGroup(ctx context.Context, groupId uint64) (bool, error)
	AddInventoryPaymentConfig(ctx context.Context, config *InventoryPaymentConfig) (uint64, error)
	GetInventoryPaymentConfig(ctx context.Context, configId uint64) (*InventoryPaymentConfig, error)
	ListInventoryPaymentConfigs(ctx context.Context, projectId uint64) ([]*InventoryPaymentConfig, error)
	UpdateInventoryPaymentConfig(ctx context.Context, config *InventoryPaymentConfig) error
	DeleteInventoryPaymentConfig(ctx context.Context, configId uint64) (bool, error)
	RequestInventoryPayment(ctx context.Context, configId uint64, recipient string, chainId *uint64, tokenAddress *string) (*InventoryPaymentResponse, error)
}

//
// Client
//

const APIPathPrefix = "/rpc/API/"

type aPIClient struct {
	client HTTPClient
	urls   [65]string
}

func NewAPIClient(addr string, client HTTPClient) APIClient {
	prefix := urlBase(addr) + APIPathPrefix
	urls := [65]string{
		prefix + "Ping",
		prefix + "Version",
		prefix + "RuntimeStatus",
		prefix + "Clock",
		prefix + "GetSequenceContext",
		prefix + "GetAuthToken",
		prefix + "GetAuthToken2",
		prefix + "SendPasswordlessLink",
		prefix + "FriendList",
		prefix + "GetFriendByAddress",
		prefix + "SearchFriends",
		prefix + "AddFriend",
		prefix + "UpdateFriendNickname",
		prefix + "RemoveFriend",
		prefix + "ContractCall",
		prefix + "DecodeContractCall",
		prefix + "LookupContractCallSelectors",
		prefix + "UserStorageFetch",
		prefix + "UserStorageSave",
		prefix + "UserStorageDelete",
		prefix + "UserStorageFetchAll",
		prefix + "GetMoonpayLink",
		prefix + "ResolveENSAddress",
		prefix + "IsValidSignature",
		prefix + "IsValidMessageSignature",
		prefix + "IsValidTypedDataSignature",
		prefix + "IsValidETHAuthProof",
		prefix + "SardineGetClientToken",
		prefix + "SardineGetNFTCheckoutToken",
		prefix + "SardineGetNFTCheckoutOrderStatus",
		prefix + "SardineGetSupportedRegions",
		prefix + "SardineGetSupportedFiatCurrencies",
		prefix + "SardineGetSupportedTokens",
		prefix + "SardineGetEnabledTokens",
		prefix + "SardineGetQuote",
		prefix + "GetSardineClientToken",
		prefix + "GetSardineNFTCheckoutToken",
		prefix + "GetSardineNFTCheckoutOrderStatus",
		prefix + "GetCoinPrices",
		prefix + "GetCollectiblePrices",
		prefix + "GetExchangeRate",
		prefix + "MemoryStore",
		prefix + "MemoryLoad",
		prefix + "GetInviteInfo",
		prefix + "IsValidAccessCode",
		prefix + "InternalClaimAccessCode",
		prefix + "BlockNumberAtTime",
		prefix + "PaperSessionSecret",
		prefix + "PaperSessionSecret2",
		prefix + "LinkWallet",
		prefix + "GetLinkedWallets",
		prefix + "RemoveLinkedWallet",
		prefix + "GenerateWaaSVerificationURL",
		prefix + "ValidateWaaSVerificationNonce",
		prefix + "GetSwapQuotes",
		prefix + "AddCurrencyGroup",
		prefix + "UpdateCurrencyGroup",
		prefix + "ListCurrencyGroups",
		prefix + "DeleteCurrencyGroup",
		prefix + "AddInventoryPaymentConfig",
		prefix + "GetInventoryPaymentConfig",
		prefix + "ListInventoryPaymentConfigs",
		prefix + "UpdateInventoryPaymentConfig",
		prefix + "DeleteInventoryPaymentConfig",
		prefix + "RequestInventoryPayment",
	}
	return &aPIClient{
		client: client,
		urls:   urls,
	}
}

func (c *aPIClient) Ping(ctx context.Context) (bool, error) {
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) Version(ctx context.Context) (*Version, error) {
	out := struct {
		Ret0 *Version `json:"version"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) RuntimeStatus(ctx context.Context) (*RuntimeStatus, error) {
	out := struct {
		Ret0 *RuntimeStatus `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) Clock(ctx context.Context) (time.Time, error) {
	out := struct {
		Ret0 time.Time `json:"serverTime"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSequenceContext(ctx context.Context) (*SequenceContext, error) {
	out := struct {
		Ret0 *SequenceContext `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetAuthToken(ctx context.Context, ewtString string, testnetMode *bool) (bool, string, string, *User, error) {
	in := struct {
		Arg0 string `json:"ewtString"`
		Arg1 *bool  `json:"testnetMode"`
	}{ewtString, testnetMode}
	out := struct {
		Ret0 bool   `json:"status"`
		Ret1 string `json:"jwtToken"`
		Ret2 string `json:"address"`
		Ret3 *User  `json:"user"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[5], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, out.Ret1, out.Ret2, out.Ret3, err
}

func (c *aPIClient) GetAuthToken2(ctx context.Context, ewtString string, chainID string) (bool, string, string, *User, error) {
	in := struct {
		Arg0 string `json:"ewtString"`
		Arg1 string `json:"chainID"`
	}{ewtString, chainID}
	out := struct {
		Ret0 bool   `json:"status"`
		Ret1 string `json:"jwtToken"`
		Ret2 string `json:"address"`
		Ret3 *User  `json:"user"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[6], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, out.Ret1, out.Ret2, out.Ret3, err
}

func (c *aPIClient) SendPasswordlessLink(ctx context.Context, email string, redirectUri string, intent string) (bool, error) {
	in := struct {
		Arg0 string `json:"email"`
		Arg1 string `json:"redirectUri"`
		Arg2 string `json:"intent"`
	}{email, redirectUri, intent}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[7], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) FriendList(ctx context.Context, nickname *string, page *Page) (*Page, []*Friend, error) {
	in := struct {
		Arg0 *string `json:"nickname"`
		Arg1 *Page   `json:"page"`
	}{nickname, page}
	out := struct {
		Ret0 *Page     `json:"page"`
		Ret1 []*Friend `json:"friends"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[8], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) GetFriendByAddress(ctx context.Context, friendAddress string) (bool, *Friend, error) {
	in := struct {
		Arg0 string `json:"friendAddress"`
	}{friendAddress}
	out := struct {
		Ret0 bool    `json:"status"`
		Ret1 *Friend `json:"friend"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[9], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) SearchFriends(ctx context.Context, filterUsername string, page *Page) ([]*Friend, error) {
	in := struct {
		Arg0 string `json:"filterUsername"`
		Arg1 *Page  `json:"page"`
	}{filterUsername, page}
	out := struct {
		Ret0 []*Friend `json:"friends"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[10], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) AddFriend(ctx context.Context, friendAddress string, optionalNickname *string) (bool, *Friend, error) {
	in := struct {
		Arg0 string  `json:"friendAddress"`
		Arg1 *string `json:"optionalNickname"`
	}{friendAddress, optionalNickname}
	out := struct {
		Ret0 bool    `json:"status"`
		Ret1 *Friend `json:"friend"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[11], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) UpdateFriendNickname(ctx context.Context, friendAddress string, nickname string) (bool, *Friend, error) {
	in := struct {
		Arg0 string `json:"friendAddress"`
		Arg1 string `json:"nickname"`
	}{friendAddress, nickname}
	out := struct {
		Ret0 bool    `json:"status"`
		Ret1 *Friend `json:"friend"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[12], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) RemoveFriend(ctx context.Context, friendAddress string) (bool, error) {
	in := struct {
		Arg0 string `json:"friendAddress"`
	}{friendAddress}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[13], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) ContractCall(ctx context.Context, chainID string, contract string, inputExpr string, outputExpr string, args []string) ([]string, error) {
	in := struct {
		Arg0 string   `json:"chainID"`
		Arg1 string   `json:"contract"`
		Arg2 string   `json:"inputExpr"`
		Arg3 string   `json:"outputExpr"`
		Arg4 []string `json:"args"`
	}{chainID, contract, inputExpr, outputExpr, args}
	out := struct {
		Ret0 []string `json:"returns"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[14], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) DecodeContractCall(ctx context.Context, callData string) (*ContractCall, error) {
	in := struct {
		Arg0 string `json:"callData"`
	}{callData}
	out := struct {
		Ret0 *ContractCall `json:"call"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[15], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) LookupContractCallSelectors(ctx context.Context, selectors []string) ([][]string, error) {
	in := struct {
		Arg0 []string `json:"selectors"`
	}{selectors}
	out := struct {
		Ret0 [][]string `json:"signatures"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[16], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) UserStorageFetch(ctx context.Context, key string) (interface{}, error) {
	in := struct {
		Arg0 string `json:"key"`
	}{key}
	out := struct {
		Ret0 interface{} `json:"object"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[17], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) UserStorageSave(ctx context.Context, key string, object interface{}) (bool, error) {
	in := struct {
		Arg0 string      `json:"key"`
		Arg1 interface{} `json:"object"`
	}{key, object}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[18], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) UserStorageDelete(ctx context.Context, key string) (bool, error) {
	in := struct {
		Arg0 string `json:"key"`
	}{key}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[19], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) UserStorageFetchAll(ctx context.Context, keys []string) (map[string]interface{}, error) {
	in := struct {
		Arg0 []string `json:"keys"`
	}{keys}
	out := struct {
		Ret0 map[string]interface{} `json:"objects"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[20], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetMoonpayLink(ctx context.Context, url string) (string, error) {
	in := struct {
		Arg0 string `json:"url"`
	}{url}
	out := struct {
		Ret0 string `json:"signedUrl"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[21], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) ResolveENSAddress(ctx context.Context, ens string) (string, bool, error) {
	in := struct {
		Arg0 string `json:"ens"`
	}{ens}
	out := struct {
		Ret0 string `json:"address"`
		Ret1 bool   `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[22], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) IsValidSignature(ctx context.Context, chainId string, walletAddress string, digest string, signature string) (bool, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"walletAddress"`
		Arg2 string `json:"digest"`
		Arg3 string `json:"signature"`
	}{chainId, walletAddress, digest, signature}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[23], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) IsValidMessageSignature(ctx context.Context, chainId string, walletAddress string, message string, signature string) (bool, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"walletAddress"`
		Arg2 string `json:"message"`
		Arg3 string `json:"signature"`
	}{chainId, walletAddress, message, signature}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[24], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) IsValidTypedDataSignature(ctx context.Context, chainId string, walletAddress string, typedData interface{}, signature string) (bool, error) {
	in := struct {
		Arg0 string      `json:"chainId"`
		Arg1 string      `json:"walletAddress"`
		Arg2 interface{} `json:"typedData"`
		Arg3 string      `json:"signature"`
	}{chainId, walletAddress, typedData, signature}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[25], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) IsValidETHAuthProof(ctx context.Context, chainId string, walletAddress string, ethAuthProofString string) (bool, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"walletAddress"`
		Arg2 string `json:"ethAuthProofString"`
	}{chainId, walletAddress, ethAuthProofString}
	out := struct {
		Ret0 bool `json:"isValid"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[26], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetClientToken(ctx context.Context) (string, error) {
	out := struct {
		Ret0 string `json:"token"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[27], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetNFTCheckoutToken(ctx context.Context, params *SardineNFTCheckoutParams) (*SardineNFTCheckout, error) {
	in := struct {
		Arg0 *SardineNFTCheckoutParams `json:"params"`
	}{params}
	out := struct {
		Ret0 *SardineNFTCheckout `json:"resp"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[28], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetNFTCheckoutOrderStatus(ctx context.Context, orderId string) (*SardineOrder, error) {
	in := struct {
		Arg0 string `json:"orderId"`
	}{orderId}
	out := struct {
		Ret0 *SardineOrder `json:"resp"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[29], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetSupportedRegions(ctx context.Context) ([]*SardineRegion, error) {
	out := struct {
		Ret0 []*SardineRegion `json:"regions"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[30], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetSupportedFiatCurrencies(ctx context.Context) ([]*SardineFiatCurrency, error) {
	out := struct {
		Ret0 []*SardineFiatCurrency `json:"tokens"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[31], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetSupportedTokens(ctx context.Context) ([]*SardineSupportedToken, error) {
	out := struct {
		Ret0 []*SardineSupportedToken `json:"tokens"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[32], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetEnabledTokens(ctx context.Context) ([]*SardineEnabledToken, error) {
	out := struct {
		Ret0 []*SardineEnabledToken `json:"tokens"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[33], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) SardineGetQuote(ctx context.Context, params *SardineGetQuoteParams) (*SardineQuote, error) {
	in := struct {
		Arg0 *SardineGetQuoteParams `json:"params"`
	}{params}
	out := struct {
		Ret0 *SardineQuote `json:"quote"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[34], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSardineClientToken(ctx context.Context) (string, error) {
	out := struct {
		Ret0 string `json:"token"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[35], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSardineNFTCheckoutToken(ctx context.Context, params *SardineNFTCheckoutParams) (*SardineNFTCheckout, error) {
	in := struct {
		Arg0 *SardineNFTCheckoutParams `json:"params"`
	}{params}
	out := struct {
		Ret0 *SardineNFTCheckout `json:"resp"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[36], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSardineNFTCheckoutOrderStatus(ctx context.Context, orderId string) (*SardineOrder, error) {
	in := struct {
		Arg0 string `json:"orderId"`
	}{orderId}
	out := struct {
		Ret0 *SardineOrder `json:"resp"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[37], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetCoinPrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error) {
	in := struct {
		Arg0 []*Token `json:"tokens"`
	}{tokens}
	out := struct {
		Ret0 []*TokenPrice `json:"tokenPrices"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[38], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetCollectiblePrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error) {
	in := struct {
		Arg0 []*Token `json:"tokens"`
	}{tokens}
	out := struct {
		Ret0 []*TokenPrice `json:"tokenPrices"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[39], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetExchangeRate(ctx context.Context, toCurrency string) (*ExchangeRate, error) {
	in := struct {
		Arg0 string `json:"toCurrency"`
	}{toCurrency}
	out := struct {
		Ret0 *ExchangeRate `json:"exchangeRate"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[40], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) MemoryStore(ctx context.Context, key string, value string) (bool, error) {
	in := struct {
		Arg0 string `json:"key"`
		Arg1 string `json:"value"`
	}{key, value}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[41], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) MemoryLoad(ctx context.Context, key string) (string, error) {
	in := struct {
		Arg0 string `json:"key"`
	}{key}
	out := struct {
		Ret0 string `json:"value"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[42], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetInviteInfo(ctx context.Context) (*InviteInfo, error) {
	out := struct {
		Ret0 *InviteInfo `json:"inviteInfo"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[43], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) IsValidAccessCode(ctx context.Context, accessCode string) (bool, error) {
	in := struct {
		Arg0 string `json:"accessCode"`
	}{accessCode}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[44], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) InternalClaimAccessCode(ctx context.Context, address string, accessCode string) (bool, error) {
	in := struct {
		Arg0 string `json:"address"`
		Arg1 string `json:"accessCode"`
	}{address, accessCode}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[45], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) BlockNumberAtTime(ctx context.Context, chainId uint64, timestamps []uint64) ([]uint64, error) {
	in := struct {
		Arg0 uint64   `json:"chainId"`
		Arg1 []uint64 `json:"timestamps"`
	}{chainId, timestamps}
	out := struct {
		Ret0 []uint64 `json:"blocks"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[46], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) PaperSessionSecret(ctx context.Context, chainName string, contractAddress string, paramsJson string, contractType string) (string, error) {
	in := struct {
		Arg0 string `json:"chainName"`
		Arg1 string `json:"contractAddress"`
		Arg2 string `json:"paramsJson"`
		Arg3 string `json:"contractType"`
	}{chainName, contractAddress, paramsJson, contractType}
	out := struct {
		Ret0 string `json:"secret"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[47], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) PaperSessionSecret2(ctx context.Context, chainName string, contractAddress string, paramsJson string, abi string) (string, error) {
	in := struct {
		Arg0 string `json:"chainName"`
		Arg1 string `json:"contractAddress"`
		Arg2 string `json:"paramsJson"`
		Arg3 string `json:"abi"`
	}{chainName, contractAddress, paramsJson, abi}
	out := struct {
		Ret0 string `json:"secret"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[48], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) LinkWallet(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, linkedWalletAddress string, linkedWalletMessage string, linkedWalletSignature string, signatureChainId string) (bool, error) {
	in := struct {
		Arg0 string `json:"parentWalletAddress"`
		Arg1 string `json:"parentWalletMessage"`
		Arg2 string `json:"parentWalletSignature"`
		Arg3 string `json:"linkedWalletAddress"`
		Arg4 string `json:"linkedWalletMessage"`
		Arg5 string `json:"linkedWalletSignature"`
		Arg6 string `json:"signatureChainId"`
	}{parentWalletAddress, parentWalletMessage, parentWalletSignature, linkedWalletAddress, linkedWalletMessage, linkedWalletSignature, signatureChainId}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[49], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetLinkedWallets(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, signatureChainId string) ([]string, error) {
	in := struct {
		Arg0 string `json:"parentWalletAddress"`
		Arg1 string `json:"parentWalletMessage"`
		Arg2 string `json:"parentWalletSignature"`
		Arg3 string `json:"signatureChainId"`
	}{parentWalletAddress, parentWalletMessage, parentWalletSignature, signatureChainId}
	out := struct {
		Ret0 []string `json:"linkedWallets"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[50], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) RemoveLinkedWallet(ctx context.Context, parentWalletAddress string, parentWalletMessage string, parentWalletSignature string, linkedWalletAddress string, linkedWalletMessage string, linkedWalletSignature string, signatureChainId string) (bool, error) {
	in := struct {
		Arg0 string `json:"parentWalletAddress"`
		Arg1 string `json:"parentWalletMessage"`
		Arg2 string `json:"parentWalletSignature"`
		Arg3 string `json:"linkedWalletAddress"`
		Arg4 string `json:"linkedWalletMessage"`
		Arg5 string `json:"linkedWalletSignature"`
		Arg6 string `json:"signatureChainId"`
	}{parentWalletAddress, parentWalletMessage, parentWalletSignature, linkedWalletAddress, linkedWalletMessage, linkedWalletSignature, signatureChainId}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[51], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GenerateWaaSVerificationURL(ctx context.Context, walletAddress string) (string, string, error) {
	in := struct {
		Arg0 string `json:"walletAddress"`
	}{walletAddress}
	out := struct {
		Ret0 string `json:"nonce"`
		Ret1 string `json:"verificationURL"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[52], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) ValidateWaaSVerificationNonce(ctx context.Context, nonce string, signature string, sessionId string, chainId string) (string, error) {
	in := struct {
		Arg0 string `json:"nonce"`
		Arg1 string `json:"signature"`
		Arg2 string `json:"sessionId"`
		Arg3 string `json:"chainId"`
	}{nonce, signature, sessionId, chainId}
	out := struct {
		Ret0 string `json:"walletAddress"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[53], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetSwapQuotes(ctx context.Context, userAddress string, currencyAddress string, currencyAmount string, chainId uint64, includeApprove bool) ([]*SwapQuote, error) {
	in := struct {
		Arg0 string `json:"userAddress"`
		Arg1 string `json:"currencyAddress"`
		Arg2 string `json:"currencyAmount"`
		Arg3 uint64 `json:"chainId"`
		Arg4 bool   `json:"includeApprove"`
	}{userAddress, currencyAddress, currencyAmount, chainId, includeApprove}
	out := struct {
		Ret0 []*SwapQuote `json:"swapQuotes"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[54], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) AddCurrencyGroup(ctx context.Context, currencyGroup *CurrencyGroup) (uint64, error) {
	in := struct {
		Arg0 *CurrencyGroup `json:"currencyGroup"`
	}{currencyGroup}
	out := struct {
		Ret0 uint64 `json:"groupId"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[55], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) UpdateCurrencyGroup(ctx context.Context, currencyGroup *CurrencyGroup) error {
	in := struct {
		Arg0 *CurrencyGroup `json:"currencyGroup"`
	}{currencyGroup}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[56], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return err
}

func (c *aPIClient) ListCurrencyGroups(ctx context.Context) ([]*CurrencyGroup, error) {
	out := struct {
		Ret0 []*CurrencyGroup `json:"currencyGroups"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[57], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) DeleteCurrencyGroup(ctx context.Context, groupId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"groupId"`
	}{groupId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[58], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) AddInventoryPaymentConfig(ctx context.Context, config *InventoryPaymentConfig) (uint64, error) {
	in := struct {
		Arg0 *InventoryPaymentConfig `json:"config"`
	}{config}
	out := struct {
		Ret0 uint64 `json:"configId"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[59], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetInventoryPaymentConfig(ctx context.Context, configId uint64) (*InventoryPaymentConfig, error) {
	in := struct {
		Arg0 uint64 `json:"configId"`
	}{configId}
	out := struct {
		Ret0 *InventoryPaymentConfig `json:"config"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[60], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) ListInventoryPaymentConfigs(ctx context.Context, projectId uint64) ([]*InventoryPaymentConfig, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 []*InventoryPaymentConfig `json:"configs"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[61], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) UpdateInventoryPaymentConfig(ctx context.Context, config *InventoryPaymentConfig) error {
	in := struct {
		Arg0 *InventoryPaymentConfig `json:"config"`
	}{config}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[62], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return err
}

func (c *aPIClient) DeleteInventoryPaymentConfig(ctx context.Context, configId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"configId"`
	}{configId}
	out := struct {
		Ret0 bool `json:"ok"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[63], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) RequestInventoryPayment(ctx context.Context, configId uint64, recipient string, chainId *uint64, tokenAddress *string) (*InventoryPaymentResponse, error) {
	in := struct {
		Arg0 uint64  `json:"configId"`
		Arg1 string  `json:"recipient"`
		Arg2 *uint64 `json:"chainId"`
		Arg3 *string `json:"tokenAddress"`
	}{configId, recipient, chainId, tokenAddress}
	out := struct {
		Ret0 *InventoryPaymentResponse `json:"payment"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[64], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to close response body: %w", cerr))
		}
	}

	return out.Ret0, err
}

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// urlBase helps ensure that addr specifies a scheme. If it is unparsable
// as a URL, it returns addr unchanged.
func urlBase(addr string) string {
	// If the addr specifies a scheme, use it. If not, default to
	// http. If url.Parse fails on it, return it unchanged.
	url, err := url.Parse(addr)
	if err != nil {
		return addr
	}
	if url.Scheme == "" {
		url.Scheme = "http"
	}
	return url.String()
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) {
	req, err := http.NewRequestWithContext(ctx, "POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", contentType)
	req.Header.Set("Content-Type", contentType)
	if headers, ok := HTTPRequestHeaders(ctx); ok {
		for k := range headers {
			for _, v := range headers[k] {
				req.Header.Add(k, v)
			}
		}
	}
	return req, nil
}

// doHTTPRequest is common code to make a request to the remote service.
func doHTTPRequest(ctx context.Context, client HTTPClient, url string, in, out interface{}) (*http.Response, error) {
	reqBody, err := json.Marshal(in)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(fmt.Errorf("failed to marshal JSON body: %w", err))
	}
	if err = ctx.Err(); err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(fmt.Errorf("aborted because context was done: %w", err))
	}

	req, err := newRequest(ctx, url, bytes.NewBuffer(reqBody), "application/json")
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(fmt.Errorf("could not build request: %w", err))
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(err)
	}

	if resp.StatusCode != 200 {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to read server error response body: %w", err))
		}

		var rpcErr WebRPCError
		if err := json.Unmarshal(respBody, &rpcErr); err != nil {
			return nil, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to unmarshal server error: %w", err))
		}
		if rpcErr.Cause != "" {
			rpcErr.cause = errors.New(rpcErr.Cause)
		}
		return nil, rpcErr
	}

	if out != nil {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to read response body: %w", err))
		}

		err = json.Unmarshal(respBody, &out)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to unmarshal JSON response body: %w", err))
		}
	}

	return resp, nil
}

func WithHTTPRequestHeaders(ctx context.Context, h http.Header) (context.Context, error) {
	if _, ok := h["Accept"]; ok {
		return nil, errors.New("provided header cannot set Accept")
	}
	if _, ok := h["Content-Type"]; ok {
		return nil, errors.New("provided header cannot set Content-Type")
	}

	copied := make(http.Header, len(h))
	for k, vv := range h {
		if vv == nil {
			copied[k] = nil
			continue
		}
		copied[k] = make([]string, len(vv))
		copy(copied[k], vv)
	}

	return context.WithValue(ctx, HTTPClientRequestHeadersCtxKey, copied), nil
}

func HTTPRequestHeaders(ctx context.Context) (http.Header, bool) {
	h, ok := ctx.Value(HTTPClientRequestHeadersCtxKey).(http.Header)
	return h, ok
}

//
// Helpers
//

type contextKey struct {
	name string
}

func (k *contextKey) String() string {
	return "webrpc context value " + k.name
}

var (
	HTTPClientRequestHeadersCtxKey = &contextKey{"HTTPClientRequestHeaders"}
	HTTPRequestCtxKey              = &contextKey{"HTTPRequest"}

	ServiceNameCtxKey = &contextKey{"ServiceName"}

	MethodNameCtxKey = &contextKey{"MethodName"}
)

func ServiceNameFromContext(ctx context.Context) string {
	service, _ := ctx.Value(ServiceNameCtxKey).(string)
	return service
}

func MethodNameFromContext(ctx context.Context) string {
	method, _ := ctx.Value(MethodNameCtxKey).(string)
	return method
}

func RequestFromContext(ctx context.Context) *http.Request {
	r, _ := ctx.Value(HTTPRequestCtxKey).(*http.Request)
	return r
}

//
// Errors
//

type WebRPCError struct {
	Name       string `json:"error"`
	Code       int    `json:"code"`
	Message    string `json:"msg"`
	Cause      string `json:"cause,omitempty"`
	HTTPStatus int    `json:"status"`
	cause      error
}

var _ error = WebRPCError{}

func (e WebRPCError) Error() string {
	if e.cause != nil {
		return fmt.Sprintf("%s %d: %s: %v", e.Name, e.Code, e.Message, e.cause)
	}
	return fmt.Sprintf("%s %d: %s", e.Name, e.Code, e.Message)
}

func (e WebRPCError) Is(target error) bool {
	if target == nil {
		return false
	}
	if rpcErr, ok := target.(WebRPCError); ok {
		return rpcErr.Code == e.Code
	}
	return errors.Is(e.cause, target)
}

func (e WebRPCError) Unwrap() error {
	return e.cause
}

func (e WebRPCError) WithCause(cause error) WebRPCError {
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

func (e WebRPCError) WithCausef(format string, args ...interface{}) WebRPCError {
	cause := fmt.Errorf(format, args...)
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

// Deprecated: Use .WithCause() method on WebRPCError.
func ErrorWithCause(rpcErr WebRPCError, cause error) WebRPCError {
	return rpcErr.WithCause(cause)
}

// Webrpc errors
var (
	ErrWebrpcEndpoint           = WebRPCError{Code: 0, Name: "WebrpcEndpoint", Message: "endpoint error", HTTPStatus: 400}
	ErrWebrpcRequestFailed      = WebRPCError{Code: -1, Name: "WebrpcRequestFailed", Message: "request failed", HTTPStatus: 400}
	ErrWebrpcBadRoute           = WebRPCError{Code: -2, Name: "WebrpcBadRoute", Message: "bad route", HTTPStatus: 404}
	ErrWebrpcBadMethod          = WebRPCError{Code: -3, Name: "WebrpcBadMethod", Message: "bad method", HTTPStatus: 405}
	ErrWebrpcBadRequest         = WebRPCError{Code: -4, Name: "WebrpcBadRequest", Message: "bad request", HTTPStatus: 400}
	ErrWebrpcBadResponse        = WebRPCError{Code: -5, Name: "WebrpcBadResponse", Message: "bad response", HTTPStatus: 500}
	ErrWebrpcServerPanic        = WebRPCError{Code: -6, Name: "WebrpcServerPanic", Message: "server panic", HTTPStatus: 500}
	ErrWebrpcInternalError      = WebRPCError{Code: -7, Name: "WebrpcInternalError", Message: "internal error", HTTPStatus: 500}
	ErrWebrpcClientDisconnected = WebRPCError{Code: -8, Name: "WebrpcClientDisconnected", Message: "client disconnected", HTTPStatus: 400}
	ErrWebrpcStreamLost         = WebRPCError{Code: -9, Name: "WebrpcStreamLost", Message: "stream lost", HTTPStatus: 400}
	ErrWebrpcStreamFinished     = WebRPCError{Code: -10, Name: "WebrpcStreamFinished", Message: "stream finished", HTTPStatus: 200}
)

// Schema errors
var (
	ErrUnauthorized     = WebRPCError{Code: 1000, Name: "Unauthorized", Message: "Unauthorized access", HTTPStatus: 401}
	ErrPermissionDenied = WebRPCError{Code: 1001, Name: "PermissionDenied", Message: "Permission denied", HTTPStatus: 403}
	ErrSessionExpired   = WebRPCError{Code: 1002, Name: "SessionExpired", Message: "Session expired", HTTPStatus: 403}
	ErrAborted          = WebRPCError{Code: 1005, Name: "Aborted", Message: "Request aborted", HTTPStatus: 400}
	ErrGeoblocked       = WebRPCError{Code: 1006, Name: "Geoblocked", Message: "Geoblocked region", HTTPStatus: 451}
	ErrInvalidArgument  = WebRPCError{Code: 2000, Name: "InvalidArgument", Message: "Invalid argument", HTTPStatus: 400}
	ErrUnavailable      = WebRPCError{Code: 2002, Name: "Unavailable", Message: "Unavailable resource", HTTPStatus: 400}
	ErrQueryFailed      = WebRPCError{Code: 2003, Name: "QueryFailed", Message: "Query failed", HTTPStatus: 400}
	ErrNotFound         = WebRPCError{Code: 3000, Name: "NotFound", Message: "Resource not found", HTTPStatus: 400}
)
