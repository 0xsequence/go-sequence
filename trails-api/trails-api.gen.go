// trails-api v1.0.0 fb8c387446f202180d13383089d42cc09891df9e
// --
// Code generated by webrpc-gen@v0.30.2 with golang generator. DO NOT EDIT.
//
// webrpc-gen -schema=trails-api.ridl -target=golang -pkg=api -client -out=./clients/trails-api.gen.go
package api

import (
	"bytes"
	"context"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"math/big"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/0xsequence/go-sequence/lib/prototyp"
)

// WebRPC description and code-gen version
func WebRPCVersion() string {
	return "v1"
}

// Schema version of your RIDL schema
func WebRPCSchemaVersion() string {
	return "v1.0.0"
}

// Schema hash generated from your RIDL schema
func WebRPCSchemaHash() string {
	return "fb8c387446f202180d13383089d42cc09891df9e"
}

//
// Client interface
//

type TrailsClient interface {
	Ping(ctx context.Context) (bool, error)
	Version(ctx context.Context) (*Version, error)
	RuntimeStatus(ctx context.Context) (*RuntimeStatus, error)
	Clock(ctx context.Context) (time.Time, error)
	QuoteIntent(ctx context.Context, quoteIntentRequest QuoteIntentRequest) (*QuoteIntentResponse, error)
	CommitIntent(ctx context.Context, commitIntentRequest CommitIntentRequest) (*CommitIntentResponse, error)
	ExecuteIntent(ctx context.Context, executeIntentRequest ExecuteIntentRequest) (*ExecuteIntentResponse, error)
	WaitIntentReceipt(ctx context.Context, waitIntentReceiptRequest WaitIntentReceiptRequest) (*WaitIntentReceiptResponse, error)
	GetIntentReceipt(ctx context.Context, getIntentReceiptRequest GetIntentReceiptRequest) (*GetIntentReceiptResponse, error)
	GetIntent(ctx context.Context, getIntentRequest GetIntentRequest) (*GetIntentResponse, error)
	SearchIntents(ctx context.Context, searchIntentsRequest SearchIntentsRequest) (*SearchIntentsResponse, error)
	GetIntentTransactionHistory(ctx context.Context, getIntentTransactionHistoryRequest GetIntentTransactionHistoryRequest) (*GetIntentTransactionHistoryResponse, error)
	GetTokenPrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error)
}

//
// Schema types
//

type TradeType string

const (
	TradeType_EXACT_INPUT  TradeType = "EXACT_INPUT"
	TradeType_EXACT_OUTPUT TradeType = "EXACT_OUTPUT"
)

func (x TradeType) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *TradeType) UnmarshalText(b []byte) error {
	*x = TradeType(string(b))
	return nil
}

func (x *TradeType) Is(values ...TradeType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type QuoteProviderType string

const (
	QuoteProviderType_RELAY  QuoteProviderType = "RELAY"
	QuoteProviderType_CCTPV2 QuoteProviderType = "CCTPV2"
	QuoteProviderType_LIFI   QuoteProviderType = "LIFI"
)

func (x QuoteProviderType) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *QuoteProviderType) UnmarshalText(b []byte) error {
	*x = QuoteProviderType(string(b))
	return nil
}

func (x *QuoteProviderType) Is(values ...QuoteProviderType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TransactionStatus uint8

const (
	TransactionStatus_UNKNOWN TransactionStatus = 0
	// Queued.
	TransactionStatus_PENDING TransactionStatus = 1
	// Sending to Relayer.
	TransactionStatus_RELAYING TransactionStatus = 2
	// Sent to Relayer.
	TransactionStatus_RELAYED TransactionStatus = 3
	// Waiting for receipt.
	TransactionStatus_MINING    TransactionStatus = 4
	TransactionStatus_SUCCEEDED TransactionStatus = 5
	TransactionStatus_FAILED    TransactionStatus = 6
)

var TransactionStatus_name = map[uint8]string{
	0: "UNKNOWN",
	1: "PENDING",
	2: "RELAYING",
	3: "RELAYED",
	4: "MINING",
	5: "SUCCEEDED",
	6: "FAILED",
}

var TransactionStatus_value = map[string]uint8{
	"UNKNOWN":   0,
	"PENDING":   1,
	"RELAYING":  2,
	"RELAYED":   3,
	"MINING":    4,
	"SUCCEEDED": 5,
	"FAILED":    6,
}

func (x TransactionStatus) String() string {
	return TransactionStatus_name[uint8(x)]
}

func (x TransactionStatus) MarshalText() ([]byte, error) {
	return []byte(TransactionStatus_name[uint8(x)]), nil
}

func (x *TransactionStatus) UnmarshalText(b []byte) error {
	*x = TransactionStatus(TransactionStatus_value[string(b)])
	return nil
}

func (x *TransactionStatus) Is(values ...TransactionStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type IntentStatus uint8

const (
	IntentStatus_QUOTED    IntentStatus = 0
	IntentStatus_COMMITTED IntentStatus = 1
	IntentStatus_EXECUTING IntentStatus = 2
	IntentStatus_FAILED    IntentStatus = 3
	IntentStatus_SUCCEEDED IntentStatus = 4
)

var IntentStatus_name = map[uint8]string{
	0: "QUOTED",
	1: "COMMITTED",
	2: "EXECUTING",
	3: "FAILED",
	4: "SUCCEEDED",
}

var IntentStatus_value = map[string]uint8{
	"QUOTED":    0,
	"COMMITTED": 1,
	"EXECUTING": 2,
	"FAILED":    3,
	"SUCCEEDED": 4,
}

func (x IntentStatus) String() string {
	return IntentStatus_name[uint8(x)]
}

func (x IntentStatus) MarshalText() ([]byte, error) {
	return []byte(IntentStatus_name[uint8(x)]), nil
}

func (x *IntentStatus) UnmarshalText(b []byte) error {
	*x = IntentStatus(IntentStatus_value[string(b)])
	return nil
}

func (x *IntentStatus) Is(values ...IntentStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type ChainGasUsageStatus string

const (
	ChainGasUsageStatus_NORMAL    ChainGasUsageStatus = "NORMAL"
	ChainGasUsageStatus_BUSY      ChainGasUsageStatus = "BUSY"
	ChainGasUsageStatus_VERY_BUSY ChainGasUsageStatus = "VERY_BUSY"
)

func (x ChainGasUsageStatus) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *ChainGasUsageStatus) UnmarshalText(b []byte) error {
	*x = ChainGasUsageStatus(string(b))
	return nil
}

func (x *ChainGasUsageStatus) Is(values ...ChainGasUsageStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

// User goal prior to solving/quoting, aka the intent request.
//
// NOTE: was previously named GetIntentCallsPayloadParams
//
// ............
type QuoteIntentRequest struct {
	// intent owner, aka the user address processing the quote
	OwnerAddress prototyp.Hash `json:"ownerAddress"`
	// origin chain and token details
	OriginChainID      uint64        `json:"originChainId"`
	OriginTokenAddress prototyp.Hash `json:"originTokenAddress"`
	// destination chain, token, and execution details
	DestinationChainID      uint64        `json:"destinationChainId"`
	DestinationTokenAddress prototyp.Hash `json:"destinationTokenAddress"`
	DestinationToAddress    prototyp.Hash `json:"destinationToAddress"`
	DestinationCallData     *string       `json:"destinationCallData"`
	DestinationCallValue    *string       `json:"destinationCallValue"`
	// originTokenAmount is used with EXACT_INPUT txns
	OriginTokenAmount *prototyp.BigInt `json:"originTokenAmount"`
	// destinationTokenAmount is used with EXACT_OUTPUT txns
	DestinationTokenAmount *prototyp.BigInt `json:"destinationTokenAmount"`
	// tradeType indicates whether the trade is an exact input or exact output trade.
	// EXACT_OUTPUT is the default if unspecified.
	TradeType *TradeType `json:"tradeType,omitempty"`
	// options for additional auxiliary params
	Options *QuoteIntentRequestOptions `json:"options,omitempty"`
}

type QuoteIntentRequestOptions struct {
	QuoteProvider          *QuoteProviderType      `json:"quoteProvider,omitempty"`
	SlippageTolerance      *float64                `json:"slippageTolerance,omitempty"`
	TrailsAddressOverrides *TrailsAddressOverrides `json:"trailsAddressOverrides,omitempty"`
}

// Fully formed/quoted/solved, executable intent.
//
// NOTE: was previously named IntentCallsPayloads, and as well IntentConfig
// was pretty much the same thing too, so consolidated into a single type.
//
// db table: 'intents'
type Intent struct {
	// id is an internal-only sequential primary key.
	ID uint64 `json:"-" db:"id,omitempty"`
	// intentId is a deterministic public intent identifier
	// based on the hash of the origin and destination intent addresses.
	IntentID prototyp.Hash `json:"intentId" db:"intent_id"`
	// intent status of different stages of the intent to keep track.
	// note: we also track status in IntentReceipt for execution status.
	Status       IntentStatus        `json:"status" db:"status,omitempty"`
	QuoteRequest *QuoteIntentRequest `json:"quoteRequest" db:"quote_request"`
	// intent owner / main signer
	OwnerAddress             prototyp.Hash              `json:"ownerAddress" db:"owner_address"`
	OriginIntentAddress      prototyp.Hash              `json:"originIntentAddress" db:"orig_intent_address"`
	DestinationIntentAddress prototyp.Hash              `json:"destinationIntentAddress" db:"dest_intent_address"`
	DestinationSalt          prototyp.BigInt            `json:"destinationSalt" db:"destination_salt"`
	DepositTransaction       *DepositTransaction        `json:"depositTransaction" db:"deposit_txn"`
	Calls                    []*IntentCalls             `json:"calls" db:"calls"`
	Preconditions            []*TransactionPrecondition `json:"preconditions" db:"preconditions"`
	MetaTxns                 []*MetaTxn                 `json:"metaTxns" db:"meta_txns"`
	Quote                    *IntentProviderQuote       `json:"quote" db:"quote"`
	Fees                     *IntentFees                `json:"fees" db:"fees"`
	TrailsVersion            string                     `json:"trailsVersion" db:"trails_version"`
	ExpiresAt                time.Time                  `json:"expiresAt" db:"expires_at"`
	UpdatedAt                *time.Time                 `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt                *time.Time                 `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// DepositTransaction represents a deposit transfer transaction of the token amount
// to the origin intent address.
type DepositTransaction struct {
	// toAddress is the origin intent address where the deposit is sent to.
	ToAddress prototyp.Hash `json:"toAddress"`
	// tokenAddress is the token being deposited.
	TokenAddress prototyp.Hash `json:"tokenAddress"`
	// decimals is the number of decimals for the token. If the value is null, it
	// means we were unable to retrieve the decimals for the token.
	Decimals *uint8 `json:"decimals"`
	// amount is the token amount being deposited.
	Amount prototyp.BigInt `json:"amount"`
}

// NOTE: was previously named IntentCallsPayload
type IntentCalls struct {
	ChainID uint64             `json:"chainId"`
	Space   prototyp.BigInt    `json:"space"`
	Nonce   prototyp.BigInt    `json:"nonce"`
	Calls   []*TransactionCall `json:"calls"`
}

type TransactionCall struct {
	To              prototyp.Hash   `json:"to"`
	Value           prototyp.BigInt `json:"value"`
	Data            prototyp.Hash   `json:"data"`
	GasLimit        prototyp.BigInt `json:"gasLimit"`
	DelegateCall    *bool           `json:"delegateCall"`
	OnlyFallback    *bool           `json:"onlyFallback"`
	BehaviorOnError *uint8          `json:"behaviorOnError"`
}

// TransactionPrecondition preconditions based on https://eips.ethereum.org/EIPS/eip-7795
// NOTE: make sure this struct type matches the relayer TransactionPrecondition type.
type TransactionPrecondition struct {
	// value must be 'tokenMinBalance' or ''
	Type         string          `json:"type"`
	ChainID      uint64          `json:"chainId"`
	OwnerAddress prototyp.Hash   `json:"ownerAddress"`
	TokenAddress prototyp.Hash   `json:"tokenAddress"`
	MinAmount    prototyp.BigInt `json:"minAmount"`
}

// MetaTxn is a meta-transaction to be submitted to Sequence Relayer.
//
// From: `0xsequence/relayer`: https://github.com/0xsequence/relayer/blob/2c695b820970c68c57bfe71810f469412cdec675/proto/relayer.ridl#L502
// TODO: rename this to MetaTxnRaw (eventually), we can leave it for now to not break compat
// or name it, MetaTxnArgs ..?
//
// NOTE: this was previously named MetaTxn
type MetaTxn struct {
	ID      string `json:"id"`
	ChainID uint64 `json:"chainId"`
	// TODO: rename this to 'from: string' ? ... name...?? walletAddress... from..?
	// fromAddress ...?
	WalletAddress string `json:"walletAddress"`
	// TODO (later): rename this to `to: string`
	// TODO: name it.. toAddress ?
	Contract string `json:"contract"`
	// TODO: rename to 'execdata' ?
	Input string `json:"input"`
}

// IntentReceipt represents an intent that went through trails, and fully executed
// as a set of transactions, and is now complete. This method is used to fetch the
// status of an intent, and also used by the GetIntentTransactionHistory endpoint.
//
// NOTE: this was previously named IntentTransaction
//
// db table: 'intent_receipts'
type IntentReceipt struct {
	// id is an internal-only sequential primary key.
	ID uint64 `json:"-" db:"id,omitempty"`
	// intent deterministic id
	IntentID prototyp.Hash `json:"intentId" db:"intent_id"`
	// intent execution status
	Status IntentStatus `json:"status" db:"status,omitempty"`
	// intent owner / main signer
	OwnerAddress prototyp.Hash `json:"ownerAddress" db:"owner_address"`
	// origin chain id where the intent originated from
	OriginChainID uint64 `json:"originChainId" db:"orig_chain_id"`
	// destination chain id where the intent is targetting as final execution
	DestinationChainID uint64 `json:"destinationChainId" db:"dest_chain_id"`
	// deposit transaction transaction is the user-initiated transfer into
	// the origin intent address on the origin chain.
	//
	// also note, that if a user is using the 'gasless' deposit method,
	// then they supply us with an 'intentEntry' signature, and then
	// we relay the deposit as a meta-transaction on their behalf to
	// the intent entrypoint contract.
	//
	// there will also be a deposit transaction to the origin intent address.
	DepositTransactionID uint64             `json:"-" db:"deposit_txn_id"`
	DepositTransaction   *IntentTransaction `json:"depositTransaction" db:"-"`
	// origin intent transaction db reference and runtime type
	OriginTransactionID uint64             `json:"-" db:"orig_txn_id"`
	OriginTransaction   *IntentTransaction `json:"originTransaction" db:"-"`
	// destination intent transaction db reference and runtime type
	DestinationTransactionID uint64             `json:"-" db:"dest_txn_id"`
	DestinationTransaction   *IntentTransaction `json:"destinationTransaction" db:"-"`
	// timestamp when the intent receipt was updated, usually from status change
	UpdatedAt *time.Time `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	// timestamp of when the intent receipt was created
	CreatedAt *time.Time `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// IntentTransaction represents a single transaction within an intent's execution flow.
//
// db table: 'intent_transactions'
type IntentTransaction struct {
	// Auto-incrementing id used for table pk
	ID uint64 `json:"-" db:"id,omitempty"`
	// we don't return it in the json, no need. its internal.
	// Intent id this transaction is associated with
	IntentID prototyp.Hash `json:"intentId" db:"intent_id"`
	// Chain where this transaction executes
	ChainID     uint64        `json:"chainId" db:"chain_id"`
	FromAddress prototyp.Hash `json:"fromAddress" db:"from_address"`
	// ie. originIntentAddress, TrailsRouter, or TrailsIntentEntrypoint
	ToAddress prototyp.Hash `json:"toAddress" db:"to_address"`
	// Token being transferred in this transaction
	TokenAddress prototyp.Hash `json:"tokenAddress" db:"token_address"`
	// Amount transferred in this transaction
	TokenAmount prototyp.BigInt `json:"tokenAmount" db:"token_amount"`
	Calldata    prototyp.Hash   `json:"-" db:"calldata,omitempty"`
	// for user-sent deposit txn, this will be null
	MetaTxnID       prototyp.Hash            `json:"metaTxnId" db:"meta_txn_id,omitempty"`
	MetaTxnFeeQuote *string                  `json:"metaTxnFeeQuote" db:"fee_quote,omitempty"`
	Precondition    *TransactionPrecondition `json:"precondition" db:"precondition,omitempty"`
	// Gasless deposit metadata (nullable)
	DepositIntentEntry *DepositIntentEntry `json:"depositIntentEntry" db:"deposit_intent_entry,omitempty"`
	// Transaction hash received from the relayer after it's mined.
	TxnHash prototyp.Hash `json:"txnHash" db:"txn_hash,omitempty"`
	// Status of this specific transaction
	Status       TransactionStatus `json:"status" db:"status"`
	StatusReason *string           `json:"statusReason" db:"status_reason,omitempty"`
	UpdatedAt    *time.Time        `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt    *time.Time        `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// IntentProviderQuote represents the quotes from the underlining providers for both
// the swap and/or bridge external providers. If we do both a swap and a bridge, then
// the total amount is the sum of both providers. The 'quoteProvider' enum, will indiciate
// multiple providers in that case.
// NOTE: previously named IntentQuote
type IntentProviderQuote struct {
	QuoteProvider          string          `json:"quoteProvider"`
	QuoteProviderRequestID string          `json:"quoteProviderRequestId"`
	QuoteProviderFeeUSD    float64         `json:"quoteProviderFeeUsd"`
	FromAmount             prototyp.BigInt `json:"fromAmount"`
	FromAmountMin          prototyp.BigInt `json:"fromAmountMin"`
	ToAmount               prototyp.BigInt `json:"toAmount"`
	ToAmountMin            prototyp.BigInt `json:"toAmountMin"`
	MaxSlippage            float64         `json:"maxSlippage"`
	PriceImpact            float64         `json:"priceImpact"`
	PriceImpactUSD         float64         `json:"priceImpactUsd"`
}

// NOTE: previously named TrailsFee
type IntentFees struct {
	// gas fees on origin and destination chains
	OriginGas      *IntentTransactionGasFee `json:"originGas"`
	DestinationGas *IntentTransactionGasFee `json:"destinationGas"`
	// provider fees (swap + bridge + trails)
	Provider *IntentProviderFees `json:"provider"`
	// total fees including provider fees + gas fees
	FeeTokenAddress prototyp.Hash   `json:"feeTokenAddress"`
	FeeTokenTotal   prototyp.BigInt `json:"feeTokenTotal"`
	TotalFeeAmount  prototyp.BigInt `json:"totalFeeAmount"`
	TotalFeeUSD     float64         `json:"totalFeeUsd"`
}

// ProviderFees is the swap+bridge provider fee, trails fee summary and totals
// NOTE: previously named the CrossChainFee
type IntentProviderFees struct {
	// quote provider fee component (swap and/or bridge)
	// TODO: what is the providerFee token denomination? is it always origin token..? I think no.
	QuoteProvider       string          `json:"quoteProvider"`
	QuoteProviderFee    prototyp.BigInt `json:"quoteProviderFee"`
	QuoteProviderFeeUSD float64         `json:"quoteProviderFeeUsd"`
	// trails provider fee component, denominated in the origin token
	TrailsFee    prototyp.BigInt `json:"trailsFee"`
	TrailsFeeUSD float64         `json:"trailsFeeUsd"`
	// total provider fees, aka, swap + bridge + trails fees
	// TODO: what is this denomination? is it always origin token..? ...
	// TODO: rename to totalFees ? and totalFeesUsd ? ..
	TotalFeeAmount prototyp.BigInt `json:"totalFeeAmount"`
	TotalFeeUSD    float64         `json:"totalFeeUsd"`
}

// NOTE: previously named ChainExecuteQuote
type IntentTransactionGasFee struct {
	ChainID             uint64              `json:"chainId"`
	TotalGasLimit       prototyp.BigInt     `json:"totalGasLimit"`
	GasPrice            prototyp.BigInt     `json:"gasPrice"`
	NativeTokenSymbol   string              `json:"nativeTokenSymbol"`
	NativeTokenPriceUSD *float64            `json:"nativeTokenPriceUsd"`
	ChainGasUsageStatus ChainGasUsageStatus `json:"chainGasUsageStatus"`
	TotalFeeAmount      prototyp.BigInt     `json:"totalFeeAmount"`
	TotalFeeUSD         float64             `json:"totalFeeUsd"`
	// sequence relayer gas fee quotes
	// AKA, meta transaction gas fee quotes for pre-sponsored
	MetaTxnFeeDetails *MetaTxnFeeDetails `json:"metaTxnFeeDetails"`
	// metaTxnGasQuote is like a voucher for gas sponsorship from the relayer
	MetaTxnGasQuote string `json:"metaTxnGasQuote"`
}

type MetaTxnFeeDetails struct {
	MetaTxnID         string          `json:"metaTxnId"`
	EstimatedGasLimit prototyp.BigInt `json:"estimatedGasLimit"`
	// TODO: whats up with this name?
	FeeNative prototyp.BigInt `json:"feeNative"`
}

// IntentSummary represents a summary view of an intent for listing purposes.
type IntentSummary struct {
	ID uint64 `json:"-"`
	// intent deterministic id
	IntentID prototyp.Hash `json:"intentId"`
	// intent status
	Status IntentStatus `json:"status"`
	// intent owner / main signer
	OwnerAddress prototyp.Hash `json:"ownerAddress"`
	// origin and destination chain ids
	OriginChainID uint64 `json:"originChainId"`
	// - originChainMetadata: ChainMetadata
	DestinationChainID uint64 `json:"destinationChainId"`
	// origin and destination intent addresses
	OriginIntentAddress      prototyp.Hash `json:"originIntentAddress"`
	DestinationIntentAddress prototyp.Hash `json:"destinationIntentAddress"`
	// deposit transfer transaction hash and status, which is the init
	// transfer from the owner / main signer into the origin intent
	// address on the origin chain id
	DepositTransactionHash   *prototyp.Hash    `json:"depositTransactionHash"`
	DepositTransactionStatus TransactionStatus `json:"depositTransactionStatus"`
	// origin and destination execution transaction hashes and statuses
	OriginTransactionHash        *prototyp.Hash    `json:"originTransactionHash"`
	OriginTransactionStatus      TransactionStatus `json:"originTransactionStatus"`
	DestinationTransactionHash   *prototyp.Hash    `json:"destinationTransactionHash"`
	DestinationTransactionStatus TransactionStatus `json:"destinationTransactionStatus"`
	OriginTokenAddress           prototyp.Hash     `json:"originTokenAddress"`
	OriginTokenAmount            prototyp.BigInt   `json:"originTokenAmount"`
	OriginTokenMetadata          *TokenMetadata    `json:"originTokenMetadata"`
	DestinationTokenAddress      prototyp.Hash     `json:"destinationTokenAddress"`
	DestinationTokenAmount       prototyp.BigInt   `json:"destinationTokenAmount"`
	DestinationTokenMetadata     *TokenMetadata    `json:"destinationTokenMetadata"`
	// timestamp when the intent receipt was updated, usually from status change
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	// timestamp of when the intent receipt was created
	CreatedAt time.Time `json:"createdAt"`
}

type ChainMetadata struct {
	ChainID uint64 `json:"chainId"`
	Name    string `json:"name"`
	LogoURI string `json:"logoUri,omitempty"`
	Testnet *bool  `json:"testnet,omitempty"`
}

type TokenMetadata struct {
	ChainID      uint64        `json:"chainId"`
	TokenAddress prototyp.Hash `json:"tokenAddress"`
	Name         string        `json:"name"`
	Symbol       string        `json:"symbol"`
	Decimals     *uint8        `json:"decimals,omitempty"`
	LogoURI      string        `json:"logoUri,omitempty"`
}

type Token struct {
	ChainID      uint64        `json:"chainId"`
	TokenAddress prototyp.Hash `json:"tokenAddress"`
	TokenSymbol  *string       `json:"tokenSymbol,omitempty"`
}

type TokenPrice struct {
	Token    *Token   `json:"token"`
	PriceUSD *float64 `json:"priceUsd"`
	// - price?: float64
	// - currency: string
	UpdatedAt time.Time `json:"updatedAt"`
}

type CCTPTransfer struct {
	ID                 string `json:"id"`
	SourceTxHash       string `json:"sourceTxHash"`
	SourceChainID      uint64 `json:"sourceChainId"`
	DestinationChainID uint64 `json:"destinationChainId"`
	Message            string `json:"message"`
	Attestation        string `json:"attestation"`
	// TODO use an enum instead?
	Status    string     `json:"status"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt *time.Time `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

type GasFeeOptions struct {
	GasEstimate         *GasEstimate  `json:"gasEstimate"`
	FeeOptions          []*FeeOption  `json:"feeOptions"`
	ExpiresAt           time.Time     `json:"expiresAt"`
	FeeCollectorAddress prototyp.Hash `json:"feeCollectorAddress"`
}

type GasEstimate struct {
	TotalGas      uint64  `json:"totalGas"`
	GasPrice      string  `json:"gasPrice"`
	NativeCost    string  `json:"nativeCost"`
	NativeCostUSD float64 `json:"nativeCostUsd"`
}

type FeeOption struct {
	// if value is 0x000...000 or 0xeee...eeee, it is native token
	TokenAddress        prototyp.Hash   `json:"tokenAddress"`
	TokenSymbol         string          `json:"tokenSymbol"`
	TokenDecimals       uint8           `json:"tokenDecimals"`
	Amount              prototyp.BigInt `json:"amount"`
	AmountUSD           float64         `json:"amountUsd"`
	FeeCollectorAddress prototyp.Hash   `json:"feeCollectorAddress"`
}

// DepositSignature contains all gasless deposit signature parameters for ExecuteIntent
type DepositSignature struct {
	// Required: EIP-712 TrailsIntent signature (hex)
	IntentSignature prototyp.Hash `json:"intentSignature"`
	// Optional: EIP-2612 permit signature (hex, if token approval needed)
	PermitSignature *prototyp.Hash `json:"permitSignature"`
	// Optional: Permit expiration timestamp
	PermitDeadline *uint64 `json:"permitDeadline"`
	// Optional: Permit amount (usually max uint256)
	PermitAmount prototyp.BigInt `json:"permitAmount"`
	// Required: Selected fee option from gasFeeOptions
	SelectedGasFeeOption *FeeOption `json:"selectedGasFeeOption"`
	// Required: User nonce from Intent Entrypoint contract (fetched fresh at execute time)
	UserNonce uint64 `json:"userNonce"`
	// Required: Intent deadline timestamp
	Deadline uint64 `json:"deadline"`
}

// DepositIntentEntry contains gasless deposit metadata stored in JSONB
type DepositIntentEntry struct {
	// EIP-712 TrailsIntent signature (hex)
	IntentSignature prototyp.Hash `json:"intentSignature"`
	// EIP-2612 permit signature (hex, if approval needed)
	PermitSignature *prototyp.Hash `json:"permitSignature"`
	// Permit expiration timestamp
	PermitDeadline *uint64 `json:"permitDeadline"`
	// Permit amount (usually max uint256)
	PermitAmount prototyp.BigInt `json:"permitAmount"`
	// Fee amount in deposit token
	FeeAmount prototyp.BigInt `json:"feeAmount"`
	// Fee token address (same as deposit token)
	FeeToken prototyp.Hash `json:"feeToken"`
	// Address that receives the fee
	FeeCollector prototyp.Hash `json:"feeCollector"`
	// User nonce from Intent Entrypoint contract (provided by client)
	UserNonce uint64 `json:"userNonce"`
	// Intent deadline timestamp
	Deadline uint64 `json:"deadline"`
}

type TrailsAddressOverrides struct {
	SequenceWalletFactoryAddress              *string `json:"sequenceWalletFactoryAddress"`
	SequenceWalletMainModuleAddress           *string `json:"sequenceWalletMainModuleAddress"`
	SequenceWalletMainModuleUpgradableAddress *string `json:"sequenceWalletMainModuleUpgradableAddress"`
	SequenceWalletGuestModuleAddress          *string `json:"sequenceWalletGuestModuleAddress"`
	SequenceWalletUtilsAddress                *string `json:"sequenceWalletUtilsAddress"`
}

type SortOrder uint32

const (
	SortOrder_DESC SortOrder = 0
	SortOrder_ASC  SortOrder = 1
)

var SortOrder_name = map[uint32]string{
	0: "DESC",
	1: "ASC",
}

var SortOrder_value = map[string]uint32{
	"DESC": 0,
	"ASC":  1,
}

func (x SortOrder) String() string {
	return SortOrder_name[uint32(x)]
}

func (x SortOrder) MarshalText() ([]byte, error) {
	return []byte(SortOrder_name[uint32(x)]), nil
}

func (x *SortOrder) UnmarshalText(b []byte) error {
	*x = SortOrder(SortOrder_value[string(b)])
	return nil
}

func (x *SortOrder) Is(values ...SortOrder) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type Version struct {
	WebrpcVersion string `json:"webrpcVersion"`
	SchemaVersion string `json:"schemaVersion"`
	SchemaHash    string `json:"schemaHash"`
	AppVersion    string `json:"appVersion"`
}

type RuntimeStatus struct {
	// overall status, true/false
	HealthOK   bool        `json:"healthOK"`
	StartTime  time.Time   `json:"startTime"`
	Uptime     uint64      `json:"uptime"`
	Ver        string      `json:"ver"`
	Branch     string      `json:"branch"`
	CommitHash string      `json:"commitHash"`
	Runnables  interface{} `json:"runnables"`
}

// QuoteIntent accepts an intent request from the user/app and returns
// a fully formed/quoted/solved and executable Intent.
//
// NOTE: we use the IntentRequest directly for the QuoteIntent request type.
// And do not create a QuoteIntentRequest additional type, as its unnecessary.
type QuoteIntentResponse struct {
	Intent        *Intent        `json:"intent"`
	GasFeeOptions *GasFeeOptions `json:"gasFeeOptions"`
}

// CommitIntent accepts a fully formed Intent and commits it for execution. CommitIntent
// is called by clients to confirm they wish to commit to the intent and will execute it.
// We return the intent ID for tracking.
type CommitIntentRequest struct {
	Intent *Intent `json:"intent"`
}

type CommitIntentResponse struct {
	IntentID prototyp.Hash `json:"intentId"`
}

// ExecuteIntent relays the intent execution request to the intent execution engine.
// Clients provide the transfer transaction hash that executed the transfer to the
// intent origin address.
type ExecuteIntentRequest struct {
	IntentID prototyp.Hash `json:"intentId"`
	// Traditional deposit: provide transaction hash
	DepositTransactionHash prototyp.Hash `json:"depositTransactionHash"`
	// Gasless deposit: provide signatures (mutually exclusive with depositTransactionHash)
	DepositSignature *DepositSignature `json:"depositSignature"`
}

type ExecuteIntentResponse struct {
	IntentID     prototyp.Hash `json:"intentId"`
	IntentStatus IntentStatus  `json:"intentStatus"`
}

// GetIntentReceipt returns the current receipt/status of an intent immediately.
// If you are waiting for a intent to complete, use WaitIntentReceipt.
type GetIntentReceiptRequest struct {
	IntentID prototyp.Hash `json:"intentId"`
}

type GetIntentReceiptResponse struct {
	IntentReceipt *IntentReceipt `json:"intentReceipt"`
}

// WaitIntentReceipt will block until the intent reaches a terminal status or timeout.
type WaitIntentReceiptRequest struct {
	IntentID prototyp.Hash `json:"intentId"`
}

type WaitIntentReceiptResponse struct {
	IntentReceipt *IntentReceipt `json:"intentReceipt"`
	// done flag informs a client whether the wait completed successfully (true) or timed out (false).
	// as the clients will keep polling until done is true. NOTE: done does not indicate success,
	// it just indicates the execution is done, to check status see intentReceipt.status.
	Done bool `json:"done"`
}

// GetIntent queries the database for solved and committed 'intents'
type GetIntentRequest struct {
	IntentID prototyp.Hash `json:"intentId"`
}

type GetIntentResponse struct {
	Intent *Intent `json:"intent"`
}

// SearchIntents searches past intents based on filters.
// We do not return 'solved' status intents here, only committed/executed/failed/succeeded.
type SearchIntentsRequest struct {
	ByOriginIntentAddress    prototyp.Hash `json:"byOriginIntentAddress"`
	ByDepositTransactionHash prototyp.Hash `json:"byDepositTransactionHash"`
	ByOwnerAddress           prototyp.Hash `json:"byOwnerAddress"`
}

type SearchIntentsResponse struct {
	// NOTE: we intentionally do not return a page here, and limit it to 10 latest results
	Intents []*Intent `json:"intents"`
}

// GetIntentTransactionHistory returns the discrete transactions related to an intent.
type GetIntentTransactionHistoryRequest struct {
	// cursor paging parameters
	Page *Page `json:"page"`
}

type GetIntentTransactionHistoryResponse struct {
	Intents  []*IntentSummary `json:"intents"`
	NextPage *Page            `json:"nextPage"`
}

// Page represents a results page. This can be used both to request a page and
// to store the state of a page.
type Page struct {
	// Cursor: column to compare before/after to
	Column *string `json:"column,omitempty"`
	// Cursor: return column < before - include to get previous page
	Before *interface{} `json:"before,omitempty"`
	// Cursor: return column > after - include to get next page
	After *interface{} `json:"after,omitempty"`
	// Sorting filter
	Sort []*SortBy `json:"sort,omitempty"`
	// Number of items per page
	PageSize *uint32 `json:"pageSize,omitempty"`
	// Indicates if there are more results available
	More *bool `json:"more,omitempty"`
}

type SortBy struct {
	Column string    `json:"column"`
	Order  SortOrder `json:"order"`
}

var methods = map[string]method{
	"/rpc/Trails/Ping": {
		name:        "Ping",
		service:     "Trails",
		annotations: map[string]string{},
	},
	"/rpc/Trails/Version": {
		name:        "Version",
		service:     "Trails",
		annotations: map[string]string{},
	},
	"/rpc/Trails/RuntimeStatus": {
		name:        "RuntimeStatus",
		service:     "Trails",
		annotations: map[string]string{},
	},
	"/rpc/Trails/Clock": {
		name:        "Clock",
		service:     "Trails",
		annotations: map[string]string{},
	},
	"/rpc/Trails/QuoteIntent": {
		name:        "QuoteIntent",
		service:     "Trails",
		annotations: map[string]string{},
	},
	"/rpc/Trails/CommitIntent": {
		name:        "CommitIntent",
		service:     "Trails",
		annotations: map[string]string{},
	},
	"/rpc/Trails/ExecuteIntent": {
		name:        "ExecuteIntent",
		service:     "Trails",
		annotations: map[string]string{},
	},
	"/rpc/Trails/WaitIntentReceipt": {
		name:        "WaitIntentReceipt",
		service:     "Trails",
		annotations: map[string]string{},
	},
	"/rpc/Trails/GetIntentReceipt": {
		name:        "GetIntentReceipt",
		service:     "Trails",
		annotations: map[string]string{},
	},
	"/rpc/Trails/GetIntent": {
		name:        "GetIntent",
		service:     "Trails",
		annotations: map[string]string{},
	},
	"/rpc/Trails/SearchIntents": {
		name:        "SearchIntents",
		service:     "Trails",
		annotations: map[string]string{},
	},
	"/rpc/Trails/GetIntentTransactionHistory": {
		name:        "GetIntentTransactionHistory",
		service:     "Trails",
		annotations: map[string]string{},
	},
	"/rpc/Trails/GetTokenPrices": {
		name:        "GetTokenPrices",
		service:     "Trails",
		annotations: map[string]string{},
	},
}

func WebrpcMethods() map[string]method {
	res := make(map[string]method, len(methods))
	for k, v := range methods {
		res[k] = v
	}

	return res
}

var WebRPCServices = map[string][]string{
	"Trails": {
		"Ping",
		"Version",
		"RuntimeStatus",
		"Clock",
		"QuoteIntent",
		"CommitIntent",
		"ExecuteIntent",
		"WaitIntentReceipt",
		"GetIntentReceipt",
		"GetIntent",
		"SearchIntents",
		"GetIntentTransactionHistory",
		"GetTokenPrices",
	},
}

//
// Client
//

const TrailsPathPrefix = "/rpc/Trails/"

type trailsClient struct {
	client HTTPClient
	urls   [13]string
}

func NewTrailsClient(addr string, client HTTPClient) TrailsClient {
	prefix := urlBase(addr) + TrailsPathPrefix
	urls := [13]string{
		prefix + "Ping",
		prefix + "Version",
		prefix + "RuntimeStatus",
		prefix + "Clock",
		prefix + "QuoteIntent",
		prefix + "CommitIntent",
		prefix + "ExecuteIntent",
		prefix + "WaitIntentReceipt",
		prefix + "GetIntentReceipt",
		prefix + "GetIntent",
		prefix + "SearchIntents",
		prefix + "GetIntentTransactionHistory",
		prefix + "GetTokenPrices",
	}
	return &trailsClient{
		client: client,
		urls:   urls,
	}
}

func (c *trailsClient) Ping(ctx context.Context) (bool, error) {
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *trailsClient) Version(ctx context.Context) (*Version, error) {
	out := struct {
		Ret0 *Version `json:"version"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *trailsClient) RuntimeStatus(ctx context.Context) (*RuntimeStatus, error) {
	out := struct {
		Ret0 *RuntimeStatus `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *trailsClient) Clock(ctx context.Context) (time.Time, error) {
	out := struct {
		Ret0 time.Time `json:"serverTime"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *trailsClient) QuoteIntent(ctx context.Context, quoteIntentRequest QuoteIntentRequest) (*QuoteIntentResponse, error) {
	out := struct {
		Ret0 *QuoteIntentResponse
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], quoteIntentRequest, &out.Ret0)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *trailsClient) CommitIntent(ctx context.Context, commitIntentRequest CommitIntentRequest) (*CommitIntentResponse, error) {
	out := struct {
		Ret0 *CommitIntentResponse
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[5], commitIntentRequest, &out.Ret0)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *trailsClient) ExecuteIntent(ctx context.Context, executeIntentRequest ExecuteIntentRequest) (*ExecuteIntentResponse, error) {
	out := struct {
		Ret0 *ExecuteIntentResponse
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[6], executeIntentRequest, &out.Ret0)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *trailsClient) WaitIntentReceipt(ctx context.Context, waitIntentReceiptRequest WaitIntentReceiptRequest) (*WaitIntentReceiptResponse, error) {
	out := struct {
		Ret0 *WaitIntentReceiptResponse
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[7], waitIntentReceiptRequest, &out.Ret0)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *trailsClient) GetIntentReceipt(ctx context.Context, getIntentReceiptRequest GetIntentReceiptRequest) (*GetIntentReceiptResponse, error) {
	out := struct {
		Ret0 *GetIntentReceiptResponse
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[8], getIntentReceiptRequest, &out.Ret0)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *trailsClient) GetIntent(ctx context.Context, getIntentRequest GetIntentRequest) (*GetIntentResponse, error) {
	out := struct {
		Ret0 *GetIntentResponse
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[9], getIntentRequest, &out.Ret0)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *trailsClient) SearchIntents(ctx context.Context, searchIntentsRequest SearchIntentsRequest) (*SearchIntentsResponse, error) {
	out := struct {
		Ret0 *SearchIntentsResponse
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[10], searchIntentsRequest, &out.Ret0)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *trailsClient) GetIntentTransactionHistory(ctx context.Context, getIntentTransactionHistoryRequest GetIntentTransactionHistoryRequest) (*GetIntentTransactionHistoryResponse, error) {
	out := struct {
		Ret0 *GetIntentTransactionHistoryResponse
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[11], getIntentTransactionHistoryRequest, &out.Ret0)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *trailsClient) GetTokenPrices(ctx context.Context, tokens []*Token) ([]*TokenPrice, error) {
	in := struct {
		Arg0 []*Token `json:"tokens"`
	}{tokens}
	out := struct {
		Ret0 []*TokenPrice `json:"tokenPrices"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[12], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

//
// Client helpers
//

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// urlBase helps ensure that addr specifies a scheme. If it is unparsable
// as a URL, it returns addr unchanged.
func urlBase(addr string) string {
	// If the addr specifies a scheme, use it. If not, default to
	// http. If url.Parse fails on it, return it unchanged.
	url, err := url.Parse(addr)
	if err != nil {
		return addr
	}
	if url.Scheme == "" {
		url.Scheme = "http"
	}
	return url.String()
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) {
	req, err := http.NewRequestWithContext(ctx, "POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", contentType)
	req.Header.Set("Content-Type", contentType)
	req.Header.Set(WebrpcHeader, WebrpcHeaderValue)
	if headers, ok := HTTPRequestHeaders(ctx); ok {
		for k := range headers {
			for _, v := range headers[k] {
				req.Header.Add(k, v)
			}
		}
	}
	return req, nil
}

// doHTTPRequest is common code to make a request to the remote service.
func doHTTPRequest(ctx context.Context, client HTTPClient, url string, in, out interface{}) (*http.Response, error) {
	reqBody, err := json.Marshal(in)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("failed to marshal JSON body: %w", err)
	}
	if err = ctx.Err(); err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("aborted because context was done: %w", err)
	}

	req, err := newRequest(ctx, url, bytes.NewBuffer(reqBody), "application/json")
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("could not build request: %w", err)
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(err)
	}

	if resp.StatusCode != 200 {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to read server error response body: %w", err)
		}

		var rpcErr WebRPCError
		if err := json.Unmarshal(respBody, &rpcErr); err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to unmarshal server error: %w", err)
		}
		if rpcErr.Cause != "" {
			rpcErr.cause = errors.New(rpcErr.Cause)
		}
		return nil, rpcErr
	}

	if out != nil {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to read response body: %w", err)
		}

		err = json.Unmarshal(respBody, &out)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to unmarshal JSON response body: %w", err)
		}
	}

	return resp, nil
}

func WithHTTPRequestHeaders(ctx context.Context, h http.Header) (context.Context, error) {
	if _, ok := h["Accept"]; ok {
		return nil, errors.New("provided header cannot set Accept")
	}
	if _, ok := h["Content-Type"]; ok {
		return nil, errors.New("provided header cannot set Content-Type")
	}

	copied := make(http.Header, len(h))
	for k, vv := range h {
		if vv == nil {
			copied[k] = nil
			continue
		}
		copied[k] = make([]string, len(vv))
		copy(copied[k], vv)
	}

	return context.WithValue(ctx, HTTPClientRequestHeadersCtxKey, copied), nil
}

func HTTPRequestHeaders(ctx context.Context) (http.Header, bool) {
	h, ok := ctx.Value(HTTPClientRequestHeadersCtxKey).(http.Header)
	return h, ok
}

//
// Webrpc helpers
//

type method struct {
	name        string
	service     string
	annotations map[string]string
}

func (m method) Name() string {
	return m.name
}

func (m method) Service() string {
	return m.service
}

func (m method) Annotations() map[string]string {
	res := make(map[string]string, len(m.annotations))
	for k, v := range m.annotations {
		res[k] = v
	}

	return res
}

type contextKey struct {
	name string
}

func (k *contextKey) String() string {
	return "webrpc context value " + k.name
}

var (
	HTTPClientRequestHeadersCtxKey = &contextKey{"HTTPClientRequestHeaders"} // client
	HTTPRequestCtxKey              = &contextKey{"HTTPRequest"}              // server
	ServiceNameCtxKey              = &contextKey{"ServiceName"}              // server
	MethodNameCtxKey               = &contextKey{"MethodName"}               // server
)

func ServiceNameFromContext(ctx context.Context) string {
	service, _ := ctx.Value(ServiceNameCtxKey).(string)
	return service
}

func MethodNameFromContext(ctx context.Context) string {
	method, _ := ctx.Value(MethodNameCtxKey).(string)
	return method
}

func RequestFromContext(ctx context.Context) *http.Request {
	r, _ := ctx.Value(HTTPRequestCtxKey).(*http.Request)
	return r
}

func MethodCtx(ctx context.Context) (method, bool) {
	req := RequestFromContext(ctx)
	if req == nil {
		return method{}, false
	}

	m, ok := methods[req.URL.Path]
	if !ok {
		return method{}, false
	}

	return m, true
}

// PtrTo is a useful helper when constructing values for optional fields.
func PtrTo[T any](v T) *T { return &v }

//
// BigInt helpers
//

// BigInt is an alias of big.Int with custom JSON (decimal string) encoding.
type BigInt big.Int

func NewBigInt(v int64) BigInt { var bi big.Int; bi.SetInt64(v); return BigInt(bi) }

// AsInt exposes the underlying *big.Int.
func (b *BigInt) AsInt() *big.Int { return (*big.Int)(b) }

// String returns the decimal string representation of the BigInt.
func (b BigInt) String() string { return b.AsInt().String() }

// MarshalText implements encoding.TextMarshaler.
func (b BigInt) MarshalText() ([]byte, error) {
	return []byte(fmt.Sprintf("\"%s\"", b.String())), nil
}

// UnmarshalText implements encoding.TextUnmarshaler.
func (b *BigInt) UnmarshalText(text []byte) error {
	if len(text) == 0 {
		return nil
	}
	if len(text) == 4 && text[0] == 'n' && string(text) == "null" {
		return nil
	}
	for _, c := range text {
		if c == ' ' || c == '\t' || c == '\n' || c == '\r' {
			return fmt.Errorf("BigInt.UnmarshalText: unexpected whitespace in %q", text)
		}
	}
	var digits []byte
	if text[0] == '-' || (text[0] >= '0' && text[0] <= '9') {
		digits = text
	} else {
		if len(text) < 2 || text[0] != '"' || text[len(text)-1] != '"' {
			return fmt.Errorf("BigInt.UnmarshalText: unsupported format %q", text)
		}
		digits = text[1 : len(text)-1]
	}
	i, ok := big.NewInt(0).SetString(string(digits), 10)
	if !ok {
		return fmt.Errorf("BigInt.UnmarshalText: failed to parse %q", text)
	}
	*b = BigInt(*i)
	return nil
}

// MarshalJSON implements json.Marshaler
func (b BigInt) MarshalJSON() ([]byte, error) {
	return b.MarshalText()
}

// UnmarshalJSON implements json.Unmarshaler
func (b *BigInt) UnmarshalJSON(text []byte) error {
	if string(text) == "null" {
		return nil
	}
	return b.UnmarshalText(text)
}

// MarshalBinary implements encoding.BinaryMarshaler. The first byte is the sign byte
// to represent positive or negative numbers.
func (b BigInt) MarshalBinary() ([]byte, error) {
	bytes := b.AsInt().Bytes()
	out := make([]byte, len(bytes)+1)
	copy(out[1:], bytes)
	if b.AsInt().Sign() < 0 {
		// Prepend a sign byte (0xFF for negative)
		out[0] = 0xFF
	} else {
		// For zero or positive numbers, prepend 0x00
		out[0] = 0x00
	}
	return out, nil
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler. The first byte is the sign byte
// to represent positive or negative numbers.
func (b *BigInt) UnmarshalBinary(buff []byte) error {
	if len(buff) == 0 {
		*b = BigInt(*big.NewInt(0))
		return nil
	}
	// Extract the sign byte
	signByte := buff[0]
	i := new(big.Int)
	if len(buff) > 1 {
		i.SetBytes(buff[1:])
	}
	// Apply sign if negative
	if signByte == 0xFF {
		i.Neg(i)
	}
	*b = BigInt(*i)
	return nil
}

func (b BigInt) Value() (driver.Value, error) {
	return b.String(), nil
}

func (b *BigInt) Scan(src interface{}) error {
	if src == nil {
		return nil
	}

	var svalue string
	switch v := src.(type) {
	case string:
		svalue = v
	case []byte:
		svalue = string(v)
	default:
		return fmt.Errorf("BigInt.Scan: unexpected type %T", src)
	}

	// pgx driver returns NeX where N is digits and X is exponent
	parts := strings.SplitN(svalue, "e", 2)

	var ok bool
	i := &big.Int{}
	i, ok = i.SetString(parts[0], 10)
	if !ok {
		return fmt.Errorf("BigInt.Scan: failed to scan value %q", svalue)
	}

	if len(parts) >= 2 {
		exp := big.NewInt(0)
		exp, ok = exp.SetString(parts[1], 10)
		if !ok {
			return fmt.Errorf("BigInt.Scan failed to scan exp component %q", svalue)
		}
		i = i.Mul(i, big.NewInt(1).Exp(big.NewInt(10), exp, nil))
	}

	*b = BigInt(*i)
	return nil
}

//
// Errors
//

type WebRPCError struct {
	Name       string `json:"error"`
	Code       int    `json:"code"`
	Message    string `json:"msg"`
	Cause      string `json:"cause,omitempty"`
	HTTPStatus int    `json:"status"`
	cause      error
}

var _ error = WebRPCError{}

func (e WebRPCError) Error() string {
	if e.cause != nil {
		return fmt.Sprintf("%s %d: %s: %v", e.Name, e.Code, e.Message, e.cause)
	}
	return fmt.Sprintf("%s %d: %s", e.Name, e.Code, e.Message)
}

func (e WebRPCError) Is(target error) bool {
	if target == nil {
		return false
	}
	if rpcErr, ok := target.(WebRPCError); ok {
		return rpcErr.Code == e.Code
	}
	return errors.Is(e.cause, target)
}

func (e WebRPCError) Unwrap() error {
	return e.cause
}

func (e WebRPCError) WithCause(cause error) WebRPCError {
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

func (e WebRPCError) WithCausef(format string, args ...interface{}) WebRPCError {
	cause := fmt.Errorf(format, args...)
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

// Deprecated: Use .WithCause() method on WebRPCError.
func ErrorWithCause(rpcErr WebRPCError, cause error) WebRPCError {
	return rpcErr.WithCause(cause)
}

// Webrpc errors
var (
	ErrWebrpcEndpoint       = WebRPCError{Code: 0, Name: "WebrpcEndpoint", Message: "endpoint error", HTTPStatus: 400}
	ErrWebrpcRequestFailed  = WebRPCError{Code: -1, Name: "WebrpcRequestFailed", Message: "request failed", HTTPStatus: 400}
	ErrWebrpcBadRoute       = WebRPCError{Code: -2, Name: "WebrpcBadRoute", Message: "bad route", HTTPStatus: 404}
	ErrWebrpcBadMethod      = WebRPCError{Code: -3, Name: "WebrpcBadMethod", Message: "bad method", HTTPStatus: 405}
	ErrWebrpcBadRequest     = WebRPCError{Code: -4, Name: "WebrpcBadRequest", Message: "bad request", HTTPStatus: 400}
	ErrWebrpcBadResponse    = WebRPCError{Code: -5, Name: "WebrpcBadResponse", Message: "bad response", HTTPStatus: 500}
	ErrWebrpcServerPanic    = WebRPCError{Code: -6, Name: "WebrpcServerPanic", Message: "server panic", HTTPStatus: 500}
	ErrWebrpcInternalError  = WebRPCError{Code: -7, Name: "WebrpcInternalError", Message: "internal error", HTTPStatus: 500}
	ErrWebrpcClientAborted  = WebRPCError{Code: -8, Name: "WebrpcClientAborted", Message: "request aborted by client", HTTPStatus: 400}
	ErrWebrpcStreamLost     = WebRPCError{Code: -9, Name: "WebrpcStreamLost", Message: "stream lost", HTTPStatus: 400}
	ErrWebrpcStreamFinished = WebRPCError{Code: -10, Name: "WebrpcStreamFinished", Message: "stream finished", HTTPStatus: 200}
)

// Schema errors
var (
	ErrUnauthorized       = WebRPCError{Code: 1000, Name: "Unauthorized", Message: "Unauthorized access", HTTPStatus: 401}
	ErrPermissionDenied   = WebRPCError{Code: 1001, Name: "PermissionDenied", Message: "Permission denied", HTTPStatus: 403}
	ErrSessionExpired     = WebRPCError{Code: 1002, Name: "SessionExpired", Message: "Session expired", HTTPStatus: 403}
	ErrMethodNotFound     = WebRPCError{Code: 1003, Name: "MethodNotFound", Message: "Method not found", HTTPStatus: 404}
	ErrRequestConflict    = WebRPCError{Code: 1004, Name: "RequestConflict", Message: "Conflict with target resource", HTTPStatus: 409}
	ErrAborted            = WebRPCError{Code: 1005, Name: "Aborted", Message: "Request aborted", HTTPStatus: 400}
	ErrGeoblocked         = WebRPCError{Code: 1006, Name: "Geoblocked", Message: "Geoblocked region", HTTPStatus: 451}
	ErrRateLimited        = WebRPCError{Code: 1007, Name: "RateLimited", Message: "Rate-limited. Please slow down.", HTTPStatus: 429}
	ErrProjectNotFound    = WebRPCError{Code: 1008, Name: "ProjectNotFound", Message: "Project not found", HTTPStatus: 401}
	ErrAccessKeyNotFound  = WebRPCError{Code: 1101, Name: "AccessKeyNotFound", Message: "Access key not found", HTTPStatus: 401}
	ErrAccessKeyMismatch  = WebRPCError{Code: 1102, Name: "AccessKeyMismatch", Message: "Access key mismatch", HTTPStatus: 409}
	ErrInvalidOrigin      = WebRPCError{Code: 1103, Name: "InvalidOrigin", Message: "Invalid origin for Access Key", HTTPStatus: 403}
	ErrInvalidService     = WebRPCError{Code: 1104, Name: "InvalidService", Message: "Service not enabled for Access key", HTTPStatus: 403}
	ErrUnauthorizedUser   = WebRPCError{Code: 1105, Name: "UnauthorizedUser", Message: "Unauthorized user", HTTPStatus: 403}
	ErrQuotaExceeded      = WebRPCError{Code: 1200, Name: "QuotaExceeded", Message: "Quota request exceeded", HTTPStatus: 429}
	ErrQuotaRateLimit     = WebRPCError{Code: 1201, Name: "QuotaRateLimit", Message: "Quota rate limit exceeded", HTTPStatus: 429}
	ErrNoDefaultKey       = WebRPCError{Code: 1300, Name: "NoDefaultKey", Message: "No default access key found", HTTPStatus: 403}
	ErrMaxAccessKeys      = WebRPCError{Code: 1301, Name: "MaxAccessKeys", Message: "Access keys limit reached", HTTPStatus: 403}
	ErrAtLeastOneKey      = WebRPCError{Code: 1302, Name: "AtLeastOneKey", Message: "You need at least one Access Key", HTTPStatus: 403}
	ErrTimeout            = WebRPCError{Code: 1900, Name: "Timeout", Message: "Request timed out", HTTPStatus: 408}
	ErrInvalidArgument    = WebRPCError{Code: 2000, Name: "InvalidArgument", Message: "Invalid argument", HTTPStatus: 400}
	ErrUnexpected         = WebRPCError{Code: 2001, Name: "Unexpected", Message: "Unexpected server error", HTTPStatus: 500}
	ErrUnavailable        = WebRPCError{Code: 2002, Name: "Unavailable", Message: "Unavailable resource", HTTPStatus: 400}
	ErrQueryFailed        = WebRPCError{Code: 2003, Name: "QueryFailed", Message: "Query failed", HTTPStatus: 400}
	ErrIntentStatus       = WebRPCError{Code: 2004, Name: "IntentStatus", Message: "Invalid intent status", HTTPStatus: 422}
	ErrNotFound           = WebRPCError{Code: 8000, Name: "NotFound", Message: "Resource not found", HTTPStatus: 400}
	ErrUnsupportedNetwork = WebRPCError{Code: 8008, Name: "UnsupportedNetwork", Message: "Unsupported network", HTTPStatus: 422}
)

//
// Webrpc
//

const WebrpcHeader = "Webrpc"

const WebrpcHeaderValue = "webrpc@v0.30.2;gen-golang@v0.23.1;trails-api@v1.0.0"

type WebrpcGenVersions struct {
	WebrpcGenVersion string
	CodeGenName      string
	CodeGenVersion   string
	SchemaName       string
	SchemaVersion    string
}

func VersionFromHeader(h http.Header) (*WebrpcGenVersions, error) {
	if h.Get(WebrpcHeader) == "" {
		return nil, fmt.Errorf("header is empty or missing")
	}

	versions, err := parseWebrpcGenVersions(h.Get(WebrpcHeader))
	if err != nil {
		return nil, fmt.Errorf("webrpc header is invalid: %w", err)
	}

	return versions, nil
}

func parseWebrpcGenVersions(header string) (*WebrpcGenVersions, error) {
	versions := strings.Split(header, ";")
	if len(versions) < 3 {
		return nil, fmt.Errorf("expected at least 3 parts while parsing webrpc header: %v", header)
	}

	_, webrpcGenVersion, ok := strings.Cut(versions[0], "@")
	if !ok {
		return nil, fmt.Errorf("webrpc gen version could not be parsed from: %s", versions[0])
	}

	tmplTarget, tmplVersion, ok := strings.Cut(versions[1], "@")
	if !ok {
		return nil, fmt.Errorf("tmplTarget and tmplVersion could not be parsed from: %s", versions[1])
	}

	schemaName, schemaVersion, ok := strings.Cut(versions[2], "@")
	if !ok {
		return nil, fmt.Errorf("schema name and schema version could not be parsed from: %s", versions[2])
	}

	return &WebrpcGenVersions{
		WebrpcGenVersion: webrpcGenVersion,
		CodeGenName:      tmplTarget,
		CodeGenVersion:   tmplVersion,
		SchemaName:       schemaName,
		SchemaVersion:    schemaVersion,
	}, nil
}
