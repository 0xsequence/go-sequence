// trails-api v0.4.0 639386f692af6385305bf6901cc9f1b6fe21e979
// --
// Code generated by webrpc-gen@v0.28.1 with golang generator. DO NOT EDIT.
//
// webrpc-gen -schema=api.ridl -target=golang -pkg=api -client -out=./clients/trails-api.gen.go
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/0xsequence/go-sequence/lib/prototyp"
)

const WebrpcHeader = "Webrpc"

const WebrpcHeaderValue = "webrpc@v0.28.1;gen-golang@v0.21.0;trails-api@v0.4.0"

// WebRPC description and code-gen version
func WebRPCVersion() string {
	return "v1"
}

// Schema version of your RIDL schema
func WebRPCSchemaVersion() string {
	return "v0.4.0"
}

// Schema hash generated from your RIDL schema
func WebRPCSchemaHash() string {
	return "639386f692af6385305bf6901cc9f1b6fe21e979"
}

type WebrpcGenVersions struct {
	WebrpcGenVersion string
	CodeGenName      string
	CodeGenVersion   string
	SchemaName       string
	SchemaVersion    string
}

func VersionFromHeader(h http.Header) (*WebrpcGenVersions, error) {
	if h.Get(WebrpcHeader) == "" {
		return nil, fmt.Errorf("header is empty or missing")
	}

	versions, err := parseWebrpcGenVersions(h.Get(WebrpcHeader))
	if err != nil {
		return nil, fmt.Errorf("webrpc header is invalid: %w", err)
	}

	return versions, nil
}

func parseWebrpcGenVersions(header string) (*WebrpcGenVersions, error) {
	versions := strings.Split(header, ";")
	if len(versions) < 3 {
		return nil, fmt.Errorf("expected at least 3 parts while parsing webrpc header: %v", header)
	}

	_, webrpcGenVersion, ok := strings.Cut(versions[0], "@")
	if !ok {
		return nil, fmt.Errorf("webrpc gen version could not be parsed from: %s", versions[0])
	}

	tmplTarget, tmplVersion, ok := strings.Cut(versions[1], "@")
	if !ok {
		return nil, fmt.Errorf("tmplTarget and tmplVersion could not be parsed from: %s", versions[1])
	}

	schemaName, schemaVersion, ok := strings.Cut(versions[2], "@")
	if !ok {
		return nil, fmt.Errorf("schema name and schema version could not be parsed from: %s", versions[2])
	}

	return &WebrpcGenVersions{
		WebrpcGenVersion: webrpcGenVersion,
		CodeGenName:      tmplTarget,
		CodeGenVersion:   tmplVersion,
		SchemaName:       schemaName,
		SchemaVersion:    schemaVersion,
	}, nil
}

//
// Common types
//

type SortOrder uint32

const (
	SortOrder_DESC SortOrder = 0
	SortOrder_ASC  SortOrder = 1
)

var SortOrder_name = map[uint32]string{
	0: "DESC",
	1: "ASC",
}

var SortOrder_value = map[string]uint32{
	"DESC": 0,
	"ASC":  1,
}

func (x SortOrder) String() string {
	return SortOrder_name[uint32(x)]
}

func (x SortOrder) MarshalText() ([]byte, error) {
	return []byte(SortOrder_name[uint32(x)]), nil
}

func (x *SortOrder) UnmarshalText(b []byte) error {
	*x = SortOrder(SortOrder_value[string(b)])
	return nil
}

func (x *SortOrder) Is(values ...SortOrder) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TradeType string

const (
	TradeType_EXACT_INPUT  TradeType = "EXACT_INPUT"
	TradeType_EXACT_OUTPUT TradeType = "EXACT_OUTPUT"
)

func (x TradeType) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *TradeType) UnmarshalText(b []byte) error {
	*x = TradeType(string(b))
	return nil
}

func (x *TradeType) Is(values ...TradeType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type Version struct {
	WebrpcVersion string `json:"webrpcVersion"`
	SchemaVersion string `json:"schemaVersion"`
	SchemaHash    string `json:"schemaHash"`
	AppVersion    string `json:"appVersion"`
}

type RuntimeStatus struct {
	// overall status, true/false
	HealthOK   bool           `json:"healthOK"`
	StartTime  time.Time      `json:"startTime"`
	Uptime     uint64         `json:"uptime"`
	Ver        string         `json:"ver"`
	Branch     string         `json:"branch"`
	CommitHash string         `json:"commitHash"`
	Checks     *RuntimeChecks `json:"checks"`
	// TODOXXX: copied from relayer, should we keep it?
	NumTxnsRelayed map[string]*NumTxnsRelayed `json:"numTxnsRelayed"`
}

type NumTxnsRelayed struct {
	ChainID uint64 `json:"chainID"`
	Prev    uint64 `json:"prev"`
	Current uint64 `json:"current"`
	Period  uint64 `json:"period"`
}

type RuntimeChecks struct {
}

// From: `0xsequence/relayer`: https://github.com/0xsequence/relayer/blob/2c695b820970c68c57bfe71810f469412cdec675/proto/relayer.ridl#L502
// TODO: rename this to MetaTxnRaw (eventually), we can leave it for now to not break compat
// or name it, MetaTxnArgs ..?
type MetaTxn struct {
	ID            string          `json:"id"`
	ChainId       prototyp.BigInt `json:"chainId"`
	WalletAddress string          `json:"walletAddress" db:"wallet_address"`
	// TODO (later): rename this to `to: string`
	Contract string `json:"contract" db:"to_address"`
	// TODO: rename to 'execdata'
	Input string `json:"input" db:"tx_data"`
}

type Call struct {
	To              prototyp.Hash   `json:"to"`
	Value           prototyp.BigInt `json:"value"`
	Data            prototyp.Hash   `json:"data"`
	GasLimit        prototyp.BigInt `json:"gasLimit"`
	DelegateCall    *bool           `json:"delegateCall"`
	OnlyFallback    *bool           `json:"onlyFallback"`
	BehaviorOnError *uint8          `json:"behaviorOnError"`
}

type IntentCallsPayload struct {
	ChainId prototyp.BigInt `json:"chainId"`
	Space   prototyp.BigInt `json:"space"`
	Nonce   prototyp.BigInt `json:"nonce"`
	Calls   []*Call         `json:"calls"`
}

// IntentConfig
type IntentConfig struct {
	ID                       uint64              `json:"id" db:"id,omitempty"`
	ConfigHash               prototyp.Hash       `json:"configHash" db:"config_hash"`
	OriginIntentAddress      prototyp.Hash       `json:"originIntentAddress" db:"origin_intent_address"`
	DestinationIntentAddress prototyp.Hash       `json:"destinationIntentAddress" db:"destination_intent_address"`
	MainSigner               prototyp.Hash       `json:"mainSigner" db:"main_signer"`
	Calls                    prototyp.JSONString `json:"calls" db:"calls"`
	Preconditions            prototyp.JSONString `json:"preconditions" db:"preconditions"`
	ExecutionStatus          *string             `json:"executionStatus" db:"execution_status,omitempty"`
	MetaTxnID                *string             `json:"metaTxnId" db:"meta_txn_id,omitempty"`
	TxnHash                  *string             `json:"txnHash" db:"txn_hash,omitempty"`
	UpdatedAt                *time.Time          `json:"updatedAt,omitempty" db:"updated_at,omitempty"`
	CreatedAt                *time.Time          `json:"createdAt,omitempty" db:"created_at,omitempty"`
}

// IntentTransaction represents a transaction that went through the intent machine
type IntentTransaction struct {
	OriginIntentAddress      prototyp.Hash   `json:"originIntentAddress" db:"origin_intent_address"`
	DestinationIntentAddress prototyp.Hash   `json:"destinationIntentAddress" db:"destination_intent_address"`
	MainSigner               prototyp.Hash   `json:"mainSigner" db:"main_signer"`
	MetaTxnID                *string         `json:"metaTxnId" db:"meta_txn_id,omitempty"`
	TxnHash                  *string         `json:"txnHash" db:"txn_hash,omitempty"`
	ExecutionStatus          *string         `json:"executionStatus" db:"execution_status,omitempty"`
	OriginChainID            *uint64         `json:"originChainId"`
	DestinationChainID       *uint64         `json:"destinationChainId"`
	OriginTokenAddress       prototyp.Hash   `json:"originTokenAddress"`
	OriginTokenAmount        prototyp.BigInt `json:"originTokenAmount"`
	DestinationTokenAddress  prototyp.Hash   `json:"destinationTokenAddress"`
	DestinationTokenAmount   prototyp.BigInt `json:"destinationTokenAmount"`
	DestinationToAddress     prototyp.Hash   `json:"destinationToAddress"`
	CreatedAt                *string         `json:"createdAt"`
}

// MetaTxnReceipt
type MetaTxnReceipt struct {
	MetaTxID     string  `json:"metaTxID" db:"meta_tx_id"`
	Status       string  `json:"status" db:"status"`
	TxnReceipt   *string `json:"txnReceipt" db:"txn_receipt"`
	RevertReason *string `json:"revertReason" db:"revert_reason"`
}

type AddressOverrides struct {
	SequenceWalletFactoryAddress              *string `json:"sequenceWalletFactoryAddress"`
	SequenceWalletMainModuleAddress           *string `json:"sequenceWalletMainModuleAddress"`
	SequenceWalletMainModuleUpgradableAddress *string `json:"sequenceWalletMainModuleUpgradableAddress"`
	SequenceWalletGuestModuleAddress          *string `json:"sequenceWalletGuestModuleAddress"`
	SequenceWalletUtilsAddress                *string `json:"sequenceWalletUtilsAddress"`
}

type TakerFee struct {
	Address prototyp.Hash `json:"address"`
	Bps     uint64        `json:"bps"`
}

type OriginCall struct {
	ChainId          prototyp.BigInt `json:"chainId"`
	To               string          `json:"to"`
	TransactionData  string          `json:"transactionData"`
	TransactionValue prototyp.BigInt `json:"transactionValue"`
}

type IntentPrecondition struct {
	Type    string          `json:"type"`
	ChainId prototyp.BigInt `json:"chainId"`
	Data    interface{}     `json:"data"`
}

type Token struct {
	ChainId         uint64        `json:"chainId"`
	ContractAddress prototyp.Hash `json:"contractAddress"`
	TokenId         *string       `json:"tokenId"`
}

type Price struct {
	Value    float64 `json:"value"`
	Currency string  `json:"currency"`
}

type TokenPrice struct {
	Token          *Token     `json:"token"`
	Price          *Price     `json:"price"`
	Price24hChange *Price     `json:"price24hChange"`
	Price24hVol    *Price     `json:"price24hVol"`
	FloorPrice     *Price     `json:"floorPrice,omitempty"`
	BuyPrice       *Price     `json:"buyPrice,omitempty"`
	SellPrice      *Price     `json:"sellPrice,omitempty"`
	UpdatedAt      *time.Time `json:"updatedAt"`
}

type ExchangeRate struct {
	Name         string  `json:"name"`
	Symbol       string  `json:"symbol"`
	Value        float64 `json:"value"`
	VsCurrency   string  `json:"vsCurrency"`
	CurrencyType string  `json:"currencyType"`
}

// TOOD: refactor, we should be returning a cursor always..
// see indexer/indexer.ridl Page object..
//
// ---
//
// Page represents a results page. This can be used both to request a page and
// to store the state of a page.
type Page struct {
	// Common for both numbered pages and cursor: Number of items per page
	// TODO: REMOVE..
	PageSize *uint32 `json:"pageSize"`
	// Numbered pages: Page number, this is multiplied by the value of the <pageSize> parameter.
	// TODO: REMOVE..
	Page *uint32 `json:"page"`
	// Number of total items on this query.
	// TODO: REMOVE..
	TotalRecords *uint64 `json:"totalRecords"`
	// Cursor: column to compare before/after to
	Column *string `json:"column"`
	// Cursor: return column < before - include to get previous page
	Before *interface{} `json:"before"`
	// Cursor: return column > after - include to get next page
	After *interface{} `json:"after"`
	// Sorting filter
	Sort []*SortBy `json:"sort"`
	// Indicates if there are more results available
	More *bool `json:"more,omitempty"`
}

type SortBy struct {
	Column string    `json:"column"`
	Order  SortOrder `json:"order"`
}

type CCTPTransfer struct {
	ID                 string    `json:"id"`
	SourceTxHash       string    `json:"sourceTxHash"`
	SourceChainID      uint64    `json:"sourceChainId"`
	DestinationChainID uint64    `json:"destinationChainId"`
	Message            string    `json:"message"`
	Attestation        string    `json:"attestation"`
	Status             string    `json:"status"`
	CreatedAt          time.Time `json:"createdAt"`
	UpdatedAt          time.Time `json:"updatedAt"`
}

type GetIntentCallsPayloadParams struct {
	UserAddress             prototyp.Hash     `json:"userAddress"`
	DestinationChainID      uint64            `json:"destinationChainId"`
	DestinationTokenAddress prototyp.Hash     `json:"destinationTokenAddress"`
	DestinationTokenAmount  string            `json:"destinationTokenAmount"`
	DestinationToAddress    prototyp.Hash     `json:"destinationToAddress"`
	OriginChainID           uint64            `json:"originChainId"`
	OriginTokenAddress      prototyp.Hash     `json:"originTokenAddress"`
	OriginTokenAmount       string            `json:"originTokenAmount"`
	DestinationCallData     *string           `json:"destinationCallData"`
	DestinationCallValue    *string           `json:"destinationCallValue"`
	Provider                *string           `json:"provider"`
	AddressOverrides        *AddressOverrides `json:"addressOverrides"`
	DestinationSalt         *string           `json:"destinationSalt"`
	TakerFee                *TakerFee         `json:"takerFee"`
	SlippageTolerance       *float64          `json:"slippageTolerance"`
	TradeType               *TradeType        `json:"tradeType"`
}

type GetIntentsQuoteParams struct {
	UserAddress                   prototyp.Hash     `json:"userAddress"`
	DestinationChainID            uint64            `json:"destinationChainId"`
	DestinationTokenAddress       prototyp.Hash     `json:"destinationTokenAddress"`
	DestinationTokenAmount        string            `json:"destinationTokenAmount"`
	DestinationToAddress          prototyp.Hash     `json:"destinationToAddress"`
	OriginChainID                 uint64            `json:"originChainId"`
	OriginTokenAddress            prototyp.Hash     `json:"originTokenAddress"`
	OriginTokenAmount             string            `json:"originTokenAmount"`
	DestinationCallData           *string           `json:"destinationCallData"`
	DestinationCallValue          *string           `json:"destinationCallValue"`
	Provider                      *string           `json:"provider"`
	AddressOverrides              *AddressOverrides `json:"addressOverrides"`
	DestinationSalt               *string           `json:"destinationSalt"`
	TakerFee                      *TakerFee         `json:"takerFee"`
	SlippageTolerance             *float64          `json:"slippageTolerance"`
	TradeType                     *TradeType        `json:"tradeType"`
	ExactInputOriginalTokenAmount *string           `json:"exactInputOriginalTokenAmount"`
}

type CommitIntentConfigParams struct {
	OriginIntentAddress      string                `json:"originIntentAddress"`
	DestinationIntentAddress string                `json:"destinationIntentAddress"`
	MainSigner               string                `json:"mainSigner"`
	Calls                    []*IntentCallsPayload `json:"calls"`
	Preconditions            []*IntentPrecondition `json:"preconditions"`
	AddressOverrides         *AddressOverrides     `json:"addressOverrides"`
	RequestParams            *IntentRequestParams  `json:"requestParams"`
}

type IntentRequestParams struct {
	Version                 string          `json:"version"`
	UserAddress             prototyp.Hash   `json:"userAddress"`
	DestinationChainId      uint64          `json:"destinationChainId"`
	DestinationTokenAddress prototyp.Hash   `json:"destinationTokenAddress"`
	DestinationTokenAmount  prototyp.BigInt `json:"destinationTokenAmount"`
	DestinationToAddress    prototyp.Hash   `json:"destinationToAddress"`
	OriginChainId           uint64          `json:"originChainId"`
	OriginTokenAddress      prototyp.Hash   `json:"originTokenAddress"`
	OriginTokenAmount       prototyp.BigInt `json:"originTokenAmount"`
	DestinationCallData     *string         `json:"destinationCallData"`
	DestinationCallValue    *string         `json:"destinationCallValue"`
	CreatedAt               time.Time       `json:"createdAt"`
}

type IntentCallsPayloads struct {
	Calls                    []*IntentCallsPayload `json:"calls"`
	Preconditions            []*IntentPrecondition `json:"preconditions"`
	MetaTxns                 []*MetaTxn            `json:"metaTxns"`
	TrailsFee                *TrailsFee            `json:"trailsFee"`
	Quote                    *IntentQuote          `json:"quote"`
	FeeQuotes                map[string]string     `json:"feeQuotes"`
	OriginIntentAddress      string                `json:"originIntentAddress"`
	DestinationIntentAddress string                `json:"destinationIntentAddress"`
}

type CrossChainFee struct {
	ProviderFee      prototyp.BigInt `json:"providerFee"`
	TrailsSwapFee    prototyp.BigInt `json:"trailsSwapFee"`
	ProviderFeeUSD   float64         `json:"providerFeeUSD"`
	TrailsSwapFeeUSD float64         `json:"trailsSwapFeeUSD"`
	TotalFeeAmount   prototyp.BigInt `json:"totalFeeAmount"`
	TotalFeeUSD      float64         `json:"totalFeeUSD"`
}

type MetaTxnFeeDetail struct {
	MetaTxnID         string          `json:"metaTxnID"`
	EstimatedGasLimit prototyp.BigInt `json:"estimatedGasLimit"`
	FeeNative         prototyp.BigInt `json:"feeNative"`
}

type ChainExecuteQuote struct {
	ChainId           prototyp.BigInt     `json:"chainId"`
	TotalGasLimit     prototyp.BigInt     `json:"totalGasLimit"`
	GasPrice          prototyp.BigInt     `json:"gasPrice"`
	TotalFeeAmount    prototyp.BigInt     `json:"totalFeeAmount"`
	NativeTokenSymbol string              `json:"nativeTokenSymbol"`
	NativeTokenPrice  float64             `json:"nativeTokenPrice"`
	MetaTxnFeeDetails []*MetaTxnFeeDetail `json:"metaTxnFeeDetails"`
	TotalFeeUSD       float64             `json:"totalFeeUSD"`
}

type ExecuteQuote struct {
	ChainQuotes []*ChainExecuteQuote `json:"chainQuotes"`
}

type TrailsFee struct {
	ExecuteQuote           *ExecuteQuote   `json:"executeQuote"`
	CrossChainFee          *CrossChainFee  `json:"crossChainFee"`
	TakerFeeAmount         prototyp.BigInt `json:"takerFeeAmount"`
	TakerFeeUSD            *float64        `json:"takerFeeUSD"`
	TrailsFixedFeeUSD      float64         `json:"trailsFixedFeeUSD"`
	FeeToken               prototyp.Hash   `json:"feeToken"`
	OriginTokenTotalAmount prototyp.BigInt `json:"originTokenTotalAmount"`
	TotalFeeAmount         prototyp.BigInt `json:"totalFeeAmount"`
	TotalFeeUSD            float64         `json:"totalFeeUSD"`
	QuoteProvider          *string         `json:"quoteProvider"`
}

type IntentQuote struct {
	FromAmount             prototyp.BigInt   `json:"fromAmount"`
	FromAmountMin          prototyp.BigInt   `json:"fromAmountMin"`
	ToAmount               prototyp.BigInt   `json:"toAmount"`
	ToAmountMin            prototyp.BigInt   `json:"toAmountMin"`
	PriceImpact            float64           `json:"priceImpact"`
	PriceImpactUsd         string            `json:"priceImpactUsd"`
	MaxSlippage            float64           `json:"maxSlippage"`
	QuoteProvider          string            `json:"quoteProvider"`
	QuoteProviderRequestId string            `json:"quoteProviderRequestId"`
	QuoteProviderFeeUsd    string            `json:"quoteProviderFeeUsd"`
	FeeQuotes              map[string]string `json:"feeQuotes"`
}

type GetIntentEntrypointDepositParams struct {
	UserAddress     prototyp.Hash   `json:"userAddress"`
	TokenAddress    prototyp.Hash   `json:"tokenAddress"`
	Amount          prototyp.BigInt `json:"amount"`
	IntentAddress   prototyp.Hash   `json:"intentAddress"`
	ChainID         uint64          `json:"chainID"`
	Deadline        uint64          `json:"deadline"`
	IntentSignature string          `json:"intentSignature"`
	UsePermit       *bool           `json:"usePermit"`
	PermitDeadline  *uint64         `json:"permitDeadline"`
	PermitSignature *string         `json:"permitSignature"`
}

type GetIntentEntrypointDepositResult struct {
	DepositWalletAddress string   `json:"depositWalletAddress"`
	MetaTxn              *MetaTxn `json:"metaTxn"`
	FeeQuote             string   `json:"feeQuote"`
	EntrypointAddress    string   `json:"entrypointAddress"`
}

type GetIntentEntrypointMessageHashParams struct {
	UserAddress   prototyp.Hash   `json:"userAddress"`
	TokenAddress  prototyp.Hash   `json:"tokenAddress"`
	Amount        prototyp.BigInt `json:"amount"`
	IntentAddress prototyp.Hash   `json:"intentAddress"`
	ChainID       uint64          `json:"chainID"`
	Deadline      uint64          `json:"deadline"`
}

var methods = map[string]method{
	"/rpc/API/Ping": {
		name:        "Ping",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/Version": {
		name:        "Version",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/RuntimeStatus": {
		name:        "RuntimeStatus",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/Clock": {
		name:        "Clock",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetIntentCallsPayloads": {
		name:        "GetIntentCallsPayloads",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetIntentsQuote": {
		name:        "GetIntentsQuote",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/CommitIntentConfig": {
		name:        "CommitIntentConfig",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetIntentConfig": {
		name:        "GetIntentConfig",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetIntentTransactionHistory": {
		name:        "GetIntentTransactionHistory",
		service:     "API",
		annotations: map[string]string{},
	},
	"/rpc/API/GetIntentEntrypointDeposit": {
		name:        "GetIntentEntrypointDeposit",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GetIntentEntrypointMessageHash": {
		name:        "GetIntentEntrypointMessageHash",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GetCCTPTransfer": {
		name:        "GetCCTPTransfer",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/QueueCCTPTransfer": {
		name:        "QueueCCTPTransfer",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/QueueIntentConfigExecution": {
		name:        "QueueIntentConfigExecution",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/GetIntentConfigExecutionStatus": {
		name:        "GetIntentConfigExecutionStatus",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/ListIntentConfigs": {
		name:        "ListIntentConfigs",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
	"/rpc/API/QueueMetaTxnReceipt": {
		name:        "QueueMetaTxnReceipt",
		service:     "API",
		annotations: map[string]string{"public": ""},
	},
}

func WebrpcMethods() map[string]method {
	res := make(map[string]method, len(methods))
	for k, v := range methods {
		res[k] = v
	}

	return res
}

var WebRPCServices = map[string][]string{
	"API": {
		"Ping",
		"Version",
		"RuntimeStatus",
		"Clock",
		"GetIntentCallsPayloads",
		"GetIntentsQuote",
		"CommitIntentConfig",
		"GetIntentConfig",
		"GetIntentTransactionHistory",
		"GetIntentEntrypointDeposit",
		"GetIntentEntrypointMessageHash",
		"GetCCTPTransfer",
		"QueueCCTPTransfer",
		"QueueIntentConfigExecution",
		"GetIntentConfigExecutionStatus",
		"ListIntentConfigs",
		"QueueMetaTxnReceipt",
	},
}

//
// Server types
//

type API interface {
	Ping(ctx context.Context) (bool, error)
	Version(ctx context.Context) (*Version, error)
	RuntimeStatus(ctx context.Context) (*RuntimeStatus, error)
	Clock(ctx context.Context) (time.Time, error)
	// Generates complete intent execution payloads including calls, preconditions, meta transactions, and quotes for cross-chain swaps/transfers.
	GetIntentCallsPayloads(ctx context.Context, params *GetIntentCallsPayloadParams) (*IntentCallsPayloads, error)
	GetIntentsQuote(ctx context.Context, params *GetIntentsQuoteParams) (*IntentQuote, error)
	// Persists intent configuration details to database for later execution, creating a new intent config record.
	CommitIntentConfig(ctx context.Context, params *CommitIntentConfigParams) (*IntentConfig, error)
	// Retrieves stored intent configuration by wallet address for inspection or execution.
	GetIntentConfig(ctx context.Context, intentAddress string) (*IntentConfig, error)
	// Intent transaction history endpoint
	GetIntentTransactionHistory(ctx context.Context, accountAddress string, page *Page) (*Page, []*IntentTransaction, error)
	// Generates gasless meta transaction for depositing tokens into an Intent Entrypoint contract.
	GetIntentEntrypointDeposit(ctx context.Context, params *GetIntentEntrypointDepositParams) (*GetIntentEntrypointDepositResult, error)
	// Calculates the EIP-712 message hash that user needs to sign for intent entrypoint deposit.
	GetIntentEntrypointMessageHash(ctx context.Context, params *GetIntentEntrypointMessageHashParams) (string, error)
	GetCCTPTransfer(ctx context.Context, id string) (*CCTPTransfer, error)
	QueueCCTPTransfer(ctx context.Context, sourceTxHash *string, metaTxHash *string, sourceChainId uint64, destinationChainId uint64) (*CCTPTransfer, error)
	// Marks an intent config as ready for processing by the execution worker.
	QueueIntentConfigExecution(ctx context.Context, intentConfigId uint64) (bool, error)
	// Returns current execution status (pending/processing/executed/failed) for a given intent config.
	GetIntentConfigExecutionStatus(ctx context.Context, intentConfigId uint64) (string, error)
	// Paginated listing of intent configs with optional execution status filtering.
	ListIntentConfigs(ctx context.Context, page *Page, executionStatus *string) (*Page, []*IntentConfig, error)
	// Processes relay transaction receipts to update intent execution status and trigger refund logic.
	QueueMetaTxnReceipt(ctx context.Context, metaTxID string) (bool, error)
}

//
// Client types
//

type APIClient interface {
	Ping(ctx context.Context) (bool, error)
	Version(ctx context.Context) (*Version, error)
	RuntimeStatus(ctx context.Context) (*RuntimeStatus, error)
	Clock(ctx context.Context) (time.Time, error)
	// Generates complete intent execution payloads including calls, preconditions, meta transactions, and quotes for cross-chain swaps/transfers.
	GetIntentCallsPayloads(ctx context.Context, params *GetIntentCallsPayloadParams) (*IntentCallsPayloads, error)
	GetIntentsQuote(ctx context.Context, params *GetIntentsQuoteParams) (*IntentQuote, error)
	// Persists intent configuration details to database for later execution, creating a new intent config record.
	CommitIntentConfig(ctx context.Context, params *CommitIntentConfigParams) (*IntentConfig, error)
	// Retrieves stored intent configuration by wallet address for inspection or execution.
	GetIntentConfig(ctx context.Context, intentAddress string) (*IntentConfig, error)
	// Intent transaction history endpoint
	GetIntentTransactionHistory(ctx context.Context, accountAddress string, page *Page) (*Page, []*IntentTransaction, error)
	// Generates gasless meta transaction for depositing tokens into an Intent Entrypoint contract.
	GetIntentEntrypointDeposit(ctx context.Context, params *GetIntentEntrypointDepositParams) (*GetIntentEntrypointDepositResult, error)
	// Calculates the EIP-712 message hash that user needs to sign for intent entrypoint deposit.
	GetIntentEntrypointMessageHash(ctx context.Context, params *GetIntentEntrypointMessageHashParams) (string, error)
	GetCCTPTransfer(ctx context.Context, id string) (*CCTPTransfer, error)
	QueueCCTPTransfer(ctx context.Context, sourceTxHash *string, metaTxHash *string, sourceChainId uint64, destinationChainId uint64) (*CCTPTransfer, error)
	// Marks an intent config as ready for processing by the execution worker.
	QueueIntentConfigExecution(ctx context.Context, intentConfigId uint64) (bool, error)
	// Returns current execution status (pending/processing/executed/failed) for a given intent config.
	GetIntentConfigExecutionStatus(ctx context.Context, intentConfigId uint64) (string, error)
	// Paginated listing of intent configs with optional execution status filtering.
	ListIntentConfigs(ctx context.Context, page *Page, executionStatus *string) (*Page, []*IntentConfig, error)
	// Processes relay transaction receipts to update intent execution status and trigger refund logic.
	QueueMetaTxnReceipt(ctx context.Context, metaTxID string) (bool, error)
}

//
// Client
//

const APIPathPrefix = "/rpc/API/"

type aPIClient struct {
	client HTTPClient
	urls   [17]string
}

func NewAPIClient(addr string, client HTTPClient) APIClient {
	prefix := urlBase(addr) + APIPathPrefix
	urls := [17]string{
		prefix + "Ping",
		prefix + "Version",
		prefix + "RuntimeStatus",
		prefix + "Clock",
		prefix + "GetIntentCallsPayloads",
		prefix + "GetIntentsQuote",
		prefix + "CommitIntentConfig",
		prefix + "GetIntentConfig",
		prefix + "GetIntentTransactionHistory",
		prefix + "GetIntentEntrypointDeposit",
		prefix + "GetIntentEntrypointMessageHash",
		prefix + "GetCCTPTransfer",
		prefix + "QueueCCTPTransfer",
		prefix + "QueueIntentConfigExecution",
		prefix + "GetIntentConfigExecutionStatus",
		prefix + "ListIntentConfigs",
		prefix + "QueueMetaTxnReceipt",
	}
	return &aPIClient{
		client: client,
		urls:   urls,
	}
}

func (c *aPIClient) Ping(ctx context.Context) (bool, error) {
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) Version(ctx context.Context) (*Version, error) {
	out := struct {
		Ret0 *Version `json:"version"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) RuntimeStatus(ctx context.Context) (*RuntimeStatus, error) {
	out := struct {
		Ret0 *RuntimeStatus `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) Clock(ctx context.Context) (time.Time, error) {
	out := struct {
		Ret0 time.Time `json:"serverTime"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetIntentCallsPayloads(ctx context.Context, params *GetIntentCallsPayloadParams) (*IntentCallsPayloads, error) {
	in := struct {
		Arg0 *GetIntentCallsPayloadParams `json:"params"`
	}{params}

	out := struct {
		Ret0 *IntentCallsPayloads `json:"payloads"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetIntentsQuote(ctx context.Context, params *GetIntentsQuoteParams) (*IntentQuote, error) {
	in := struct {
		Arg0 *GetIntentsQuoteParams `json:"params"`
	}{params}

	out := struct {
		Ret0 *IntentQuote `json:"quote"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[5], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) CommitIntentConfig(ctx context.Context, params *CommitIntentConfigParams) (*IntentConfig, error) {
	in := struct {
		Arg0 *CommitIntentConfigParams `json:"params"`
	}{params}

	out := struct {
		Ret0 *IntentConfig `json:"config"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[6], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetIntentConfig(ctx context.Context, intentAddress string) (*IntentConfig, error) {
	in := struct {
		Arg0 string `json:"intentAddress"`
	}{intentAddress}

	out := struct {
		Ret0 *IntentConfig `json:"config"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[7], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetIntentTransactionHistory(ctx context.Context, accountAddress string, page *Page) (*Page, []*IntentTransaction, error) {
	in := struct {
		Arg0 string `json:"accountAddress"`
		Arg1 *Page  `json:"page"`
	}{accountAddress, page}

	out := struct {
		Ret0 *Page                `json:"page"`
		Ret1 []*IntentTransaction `json:"transactions"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[8], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) GetIntentEntrypointDeposit(ctx context.Context, params *GetIntentEntrypointDepositParams) (*GetIntentEntrypointDepositResult, error) {
	in := struct {
		Arg0 *GetIntentEntrypointDepositParams `json:"params"`
	}{params}

	out := struct {
		Ret0 *GetIntentEntrypointDepositResult `json:"result"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[9], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetIntentEntrypointMessageHash(ctx context.Context, params *GetIntentEntrypointMessageHashParams) (string, error) {
	in := struct {
		Arg0 *GetIntentEntrypointMessageHashParams `json:"params"`
	}{params}

	out := struct {
		Ret0 string `json:"messageHash"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[10], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetCCTPTransfer(ctx context.Context, id string) (*CCTPTransfer, error) {
	in := struct {
		Arg0 string `json:"id"`
	}{id}

	out := struct {
		Ret0 *CCTPTransfer `json:"transfer"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[11], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) QueueCCTPTransfer(ctx context.Context, sourceTxHash *string, metaTxHash *string, sourceChainId uint64, destinationChainId uint64) (*CCTPTransfer, error) {
	in := struct {
		Arg0 *string `json:"sourceTxHash"`
		Arg1 *string `json:"metaTxHash"`
		Arg2 uint64  `json:"sourceChainId"`
		Arg3 uint64  `json:"destinationChainId"`
	}{sourceTxHash, metaTxHash, sourceChainId, destinationChainId}

	out := struct {
		Ret0 *CCTPTransfer `json:"transfer"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[12], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) QueueIntentConfigExecution(ctx context.Context, intentConfigId uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"intentConfigId"`
	}{intentConfigId}

	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[13], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) GetIntentConfigExecutionStatus(ctx context.Context, intentConfigId uint64) (string, error) {
	in := struct {
		Arg0 uint64 `json:"intentConfigId"`
	}{intentConfigId}

	out := struct {
		Ret0 string `json:"executionStatus"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[14], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *aPIClient) ListIntentConfigs(ctx context.Context, page *Page, executionStatus *string) (*Page, []*IntentConfig, error) {
	in := struct {
		Arg0 *Page   `json:"page"`
		Arg1 *string `json:"executionStatus"`
	}{page, executionStatus}

	out := struct {
		Ret0 *Page           `json:"page"`
		Ret1 []*IntentConfig `json:"intentConfigs"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[15], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *aPIClient) QueueMetaTxnReceipt(ctx context.Context, metaTxID string) (bool, error) {
	in := struct {
		Arg0 string `json:"metaTxID"`
	}{metaTxID}

	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[16], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// urlBase helps ensure that addr specifies a scheme. If it is unparsable
// as a URL, it returns addr unchanged.
func urlBase(addr string) string {
	// If the addr specifies a scheme, use it. If not, default to
	// http. If url.Parse fails on it, return it unchanged.
	url, err := url.Parse(addr)
	if err != nil {
		return addr
	}
	if url.Scheme == "" {
		url.Scheme = "http"
	}
	return url.String()
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) {
	req, err := http.NewRequestWithContext(ctx, "POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", contentType)
	req.Header.Set("Content-Type", contentType)
	req.Header.Set(WebrpcHeader, WebrpcHeaderValue)
	if headers, ok := HTTPRequestHeaders(ctx); ok {
		for k := range headers {
			for _, v := range headers[k] {
				req.Header.Add(k, v)
			}
		}
	}
	return req, nil
}

// doHTTPRequest is common code to make a request to the remote service.
func doHTTPRequest(ctx context.Context, client HTTPClient, url string, in, out interface{}) (*http.Response, error) {
	reqBody, err := json.Marshal(in)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("failed to marshal JSON body: %w", err)
	}
	if err = ctx.Err(); err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("aborted because context was done: %w", err)
	}

	req, err := newRequest(ctx, url, bytes.NewBuffer(reqBody), "application/json")
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("could not build request: %w", err)
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(err)
	}

	if resp.StatusCode != 200 {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to read server error response body: %w", err)
		}

		var rpcErr WebRPCError
		if err := json.Unmarshal(respBody, &rpcErr); err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to unmarshal server error: %w", err)
		}
		if rpcErr.Cause != "" {
			rpcErr.cause = errors.New(rpcErr.Cause)
		}
		return nil, rpcErr
	}

	if out != nil {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to read response body: %w", err)
		}

		err = json.Unmarshal(respBody, &out)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to unmarshal JSON response body: %w", err)
		}
	}

	return resp, nil
}

func WithHTTPRequestHeaders(ctx context.Context, h http.Header) (context.Context, error) {
	if _, ok := h["Accept"]; ok {
		return nil, errors.New("provided header cannot set Accept")
	}
	if _, ok := h["Content-Type"]; ok {
		return nil, errors.New("provided header cannot set Content-Type")
	}

	copied := make(http.Header, len(h))
	for k, vv := range h {
		if vv == nil {
			copied[k] = nil
			continue
		}
		copied[k] = make([]string, len(vv))
		copy(copied[k], vv)
	}

	return context.WithValue(ctx, HTTPClientRequestHeadersCtxKey, copied), nil
}

func HTTPRequestHeaders(ctx context.Context) (http.Header, bool) {
	h, ok := ctx.Value(HTTPClientRequestHeadersCtxKey).(http.Header)
	return h, ok
}

//
// Helpers
//

type method struct {
	name        string
	service     string
	annotations map[string]string
}

func (m method) Name() string {
	return m.name
}

func (m method) Service() string {
	return m.service
}

func (m method) Annotations() map[string]string {
	res := make(map[string]string, len(m.annotations))
	for k, v := range m.annotations {
		res[k] = v
	}

	return res
}

type contextKey struct {
	name string
}

func (k *contextKey) String() string {
	return "webrpc context value " + k.name
}

var (
	HTTPClientRequestHeadersCtxKey = &contextKey{"HTTPClientRequestHeaders"}
	HTTPRequestCtxKey              = &contextKey{"HTTPRequest"}

	ServiceNameCtxKey = &contextKey{"ServiceName"}

	MethodNameCtxKey = &contextKey{"MethodName"}
)

func ServiceNameFromContext(ctx context.Context) string {
	service, _ := ctx.Value(ServiceNameCtxKey).(string)
	return service
}

func MethodNameFromContext(ctx context.Context) string {
	method, _ := ctx.Value(MethodNameCtxKey).(string)
	return method
}

func RequestFromContext(ctx context.Context) *http.Request {
	r, _ := ctx.Value(HTTPRequestCtxKey).(*http.Request)
	return r
}

func MethodCtx(ctx context.Context) (method, bool) {
	req := RequestFromContext(ctx)
	if req == nil {
		return method{}, false
	}

	m, ok := methods[req.URL.Path]
	if !ok {
		return method{}, false
	}

	return m, true
}

//
// Errors
//

type WebRPCError struct {
	Name       string `json:"error"`
	Code       int    `json:"code"`
	Message    string `json:"msg"`
	Cause      string `json:"cause,omitempty"`
	HTTPStatus int    `json:"status"`
	cause      error
}

var _ error = WebRPCError{}

func (e WebRPCError) Error() string {
	if e.cause != nil {
		return fmt.Sprintf("%s %d: %s: %v", e.Name, e.Code, e.Message, e.cause)
	}
	return fmt.Sprintf("%s %d: %s", e.Name, e.Code, e.Message)
}

func (e WebRPCError) Is(target error) bool {
	if target == nil {
		return false
	}
	if rpcErr, ok := target.(WebRPCError); ok {
		return rpcErr.Code == e.Code
	}
	return errors.Is(e.cause, target)
}

func (e WebRPCError) Unwrap() error {
	return e.cause
}

func (e WebRPCError) WithCause(cause error) WebRPCError {
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

func (e WebRPCError) WithCausef(format string, args ...interface{}) WebRPCError {
	cause := fmt.Errorf(format, args...)
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

// Deprecated: Use .WithCause() method on WebRPCError.
func ErrorWithCause(rpcErr WebRPCError, cause error) WebRPCError {
	return rpcErr.WithCause(cause)
}

// Webrpc errors
var (
	ErrWebrpcEndpoint       = WebRPCError{Code: 0, Name: "WebrpcEndpoint", Message: "endpoint error", HTTPStatus: 400}
	ErrWebrpcRequestFailed  = WebRPCError{Code: -1, Name: "WebrpcRequestFailed", Message: "request failed", HTTPStatus: 400}
	ErrWebrpcBadRoute       = WebRPCError{Code: -2, Name: "WebrpcBadRoute", Message: "bad route", HTTPStatus: 404}
	ErrWebrpcBadMethod      = WebRPCError{Code: -3, Name: "WebrpcBadMethod", Message: "bad method", HTTPStatus: 405}
	ErrWebrpcBadRequest     = WebRPCError{Code: -4, Name: "WebrpcBadRequest", Message: "bad request", HTTPStatus: 400}
	ErrWebrpcBadResponse    = WebRPCError{Code: -5, Name: "WebrpcBadResponse", Message: "bad response", HTTPStatus: 500}
	ErrWebrpcServerPanic    = WebRPCError{Code: -6, Name: "WebrpcServerPanic", Message: "server panic", HTTPStatus: 500}
	ErrWebrpcInternalError  = WebRPCError{Code: -7, Name: "WebrpcInternalError", Message: "internal error", HTTPStatus: 500}
	ErrWebrpcClientAborted  = WebRPCError{Code: -8, Name: "WebrpcClientAborted", Message: "request aborted by client", HTTPStatus: 400}
	ErrWebrpcStreamLost     = WebRPCError{Code: -9, Name: "WebrpcStreamLost", Message: "stream lost", HTTPStatus: 400}
	ErrWebrpcStreamFinished = WebRPCError{Code: -10, Name: "WebrpcStreamFinished", Message: "stream finished", HTTPStatus: 200}
)

// Schema errors
var (
	ErrUnauthorized       = WebRPCError{Code: 1000, Name: "Unauthorized", Message: "Unauthorized access", HTTPStatus: 401}
	ErrPermissionDenied   = WebRPCError{Code: 1001, Name: "PermissionDenied", Message: "Permission denied", HTTPStatus: 403}
	ErrSessionExpired     = WebRPCError{Code: 1002, Name: "SessionExpired", Message: "Session expired", HTTPStatus: 403}
	ErrMethodNotFound     = WebRPCError{Code: 1003, Name: "MethodNotFound", Message: "Method not found", HTTPStatus: 404}
	ErrRequestConflict    = WebRPCError{Code: 1004, Name: "RequestConflict", Message: "Conflict with target resource", HTTPStatus: 409}
	ErrAborted            = WebRPCError{Code: 1005, Name: "Aborted", Message: "Request aborted", HTTPStatus: 400}
	ErrGeoblocked         = WebRPCError{Code: 1006, Name: "Geoblocked", Message: "Geoblocked region", HTTPStatus: 451}
	ErrRateLimited        = WebRPCError{Code: 1007, Name: "RateLimited", Message: "Rate-limited. Please slow down.", HTTPStatus: 429}
	ErrProjectNotFound    = WebRPCError{Code: 1008, Name: "ProjectNotFound", Message: "Project not found", HTTPStatus: 401}
	ErrAccessKeyNotFound  = WebRPCError{Code: 1101, Name: "AccessKeyNotFound", Message: "Access key not found", HTTPStatus: 401}
	ErrAccessKeyMismatch  = WebRPCError{Code: 1102, Name: "AccessKeyMismatch", Message: "Access key mismatch", HTTPStatus: 409}
	ErrInvalidOrigin      = WebRPCError{Code: 1103, Name: "InvalidOrigin", Message: "Invalid origin for Access Key", HTTPStatus: 403}
	ErrInvalidService     = WebRPCError{Code: 1104, Name: "InvalidService", Message: "Service not enabled for Access key", HTTPStatus: 403}
	ErrUnauthorizedUser   = WebRPCError{Code: 1105, Name: "UnauthorizedUser", Message: "Unauthorized user", HTTPStatus: 403}
	ErrQuotaExceeded      = WebRPCError{Code: 1200, Name: "QuotaExceeded", Message: "Quota request exceeded", HTTPStatus: 429}
	ErrQuotaRateLimit     = WebRPCError{Code: 1201, Name: "QuotaRateLimit", Message: "Quota rate limit exceeded", HTTPStatus: 429}
	ErrNoDefaultKey       = WebRPCError{Code: 1300, Name: "NoDefaultKey", Message: "No default access key found", HTTPStatus: 403}
	ErrMaxAccessKeys      = WebRPCError{Code: 1301, Name: "MaxAccessKeys", Message: "Access keys limit reached", HTTPStatus: 403}
	ErrAtLeastOneKey      = WebRPCError{Code: 1302, Name: "AtLeastOneKey", Message: "You need at least one Access Key", HTTPStatus: 403}
	ErrTimeout            = WebRPCError{Code: 1900, Name: "Timeout", Message: "Request timed out", HTTPStatus: 408}
	ErrInvalidArgument    = WebRPCError{Code: 2000, Name: "InvalidArgument", Message: "Invalid argument", HTTPStatus: 400}
	ErrUnavailable        = WebRPCError{Code: 2002, Name: "Unavailable", Message: "Unavailable resource", HTTPStatus: 400}
	ErrQueryFailed        = WebRPCError{Code: 2003, Name: "QueryFailed", Message: "Query failed", HTTPStatus: 400}
	ErrNotFound           = WebRPCError{Code: 8000, Name: "NotFound", Message: "Resource not found", HTTPStatus: 400}
	ErrUnsupportedNetwork = WebRPCError{Code: 8008, Name: "UnsupportedNetwork", Message: "Unsupported network", HTTPStatus: 422}
)
