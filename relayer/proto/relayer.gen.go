// sequence-relayer v0.4.1 7f8a4b83b00e0b6849c76c2ff0e23931e26b3d9f
// --
// Code generated by webrpc-gen@v0.31.2 with golang generator. DO NOT EDIT.
//
// webrpc-gen -schema=relayer.ridl -target=golang -pkg=proto -client -out=./clients/relayer.gen.go
package proto

import (
	"bytes"
	"context"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"math/big"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/0xsequence/go-sequence/lib/prototyp"
	"github.com/shopspring/decimal"
)

// WebRPC description and code-gen version
func WebRPCVersion() string {
	return "v1"
}

// Schema version of your RIDL schema
func WebRPCSchemaVersion() string {
	return "v0.4.1"
}

// Schema hash generated from your RIDL schema
func WebRPCSchemaHash() string {
	return "7f8a4b83b00e0b6849c76c2ff0e23931e26b3d9f"
}

//
// Client interface
//

type RelayerClient interface {
	Ping(ctx context.Context) (bool, error)
	Version(ctx context.Context) (*Version, error)
	RuntimeStatus(ctx context.Context) (*RuntimeStatus, error)
	GetSequenceContext(ctx context.Context) (*SequenceContext, error)
	GetChainID(ctx context.Context) (uint64, error)
	//
	// Transactions
	//
	// TODO (future): rename this to just, 'SendTransaction(txn: MetaTransaction)' or 'SendTransaction(txn: SignedTransaction)', or something..
	// Project ID is only used by service and admin calls. Other clients must have projectID passed via the context
	// TODO: rename return txnHash: string to metaTxnID: string
	SendMetaTxn(ctx context.Context, call *MetaTxn, quote *string, projectID *uint64, preconditions []*TransactionPrecondition) (bool, string, error)
	GetMetaTxnNonce(ctx context.Context, walletContractAddress string, space *string) (string, error)
	// TODO: one day, make GetMetaTxnReceipt respond immediately with receipt or not
	// and add WaitTransactionReceipt method, which will block and wait, similar to how GetMetaTxnReceipt
	// is implemented now.
	// For backwards compat, we can leave the current GetMetaTxnReceipt how it is, an deprecate it, and introduce
	// new, GetTransactionReceipt and WaitTransactionReceipt methods
	// we can also accept metaTxnId and txnHash .. so can take either or.. I wonder if ERC-4337 has any convention on this?
	GetMetaTxnReceipt(ctx context.Context, metaTxID string) (*MetaTxnReceipt, error)
	Simulate(ctx context.Context, wallet string, transactions string) ([]*SimulateResult, error)
	SimulateV3(ctx context.Context, wallet string, calls string) ([]*SimulateV3Result, error)
	// TODO: deprecated, to be removed by https://github.com/0xsequence/stack/pull/356 at a later date
	UpdateMetaTxnGasLimits(ctx context.Context, walletAddress string, walletConfig interface{}, payload string) (string, error)
	FeeTokens(ctx context.Context) (bool, []*FeeToken, string, error)
	FeeOptions(ctx context.Context, wallet string, to string, data string, simulate *bool) ([]*FeeOption, bool, *string, error)
	// TODO: deprecated, to be removed by https://github.com/0xsequence/stack/pull/356 at a later date
	GetMetaTxnNetworkFeeOptions(ctx context.Context, walletConfig interface{}, payload string) ([]*FeeOption, error)
	GetMetaTransactions(ctx context.Context, projectId uint64, page *Page) (*Page, []*MetaTxnLog, error)
	GetTransactionCost(ctx context.Context, projectId uint64, from time.Time, to time.Time) (float64, error)
	// Sent transactions from an account. If filter is omitted then it will return all transactions.
	SentTransactions(ctx context.Context, filter *SentTransactionsFilter, page *Page) (*Page, []*Transaction, error)
	// Pending transactions waiting to be mined for an account. This endpoint is just a sugar of `SentTransactions`
	// with the filter set to pending: true.
	PendingTransactions(ctx context.Context, page *Page) (*Page, []*Transaction, error)
	// Legacy Gas Tank
	GetGasTank(ctx context.Context, id uint64) (*GasTank, error)
	AddGasTank(ctx context.Context, name string, feeMarkupFactor float64, unlimited *bool) (bool, *GasTank, error)
	UpdateGasTank(ctx context.Context, id uint64, name *string, feeMarkupFactor *float64, unlimited *bool) (bool, *GasTank, error)
	// Legacy Gas Adjustment
	NextGasTankBalanceAdjustmentNonce(ctx context.Context, id uint64) (uint64, error)
	AdjustGasTankBalance(ctx context.Context, id uint64, nonce uint64, amount float64) (bool, *GasTankBalanceAdjustment, error)
	GetGasTankBalanceAdjustment(ctx context.Context, id uint64, nonce uint64) (*GasTankBalanceAdjustment, error)
	ListGasTankBalanceAdjustments(ctx context.Context, id uint64, page *Page) (*Page, []*GasTankBalanceAdjustment, error)
	// Gas Sponsorship
	ListGasSponsors(ctx context.Context, projectId uint64, page *Page) (*Page, []*GasSponsor, error)
	GetGasSponsor(ctx context.Context, projectId uint64, id uint64) (*GasSponsor, error)
	AddGasSponsor(ctx context.Context, projectId uint64, address string, name *string, active *bool) (bool, *GasSponsor, error)
	UpdateGasSponsor(ctx context.Context, projectId uint64, id uint64, name *string, active *bool) (bool, *GasSponsor, error)
	RemoveGasSponsor(ctx context.Context, projectId uint64, id uint64) (bool, error)
	// Gas Sponsor Lookup
	AddressGasSponsors(ctx context.Context, address string, page *Page) (*Page, []*GasSponsor, error)
	// Project Balance
	GetProjectBalance(ctx context.Context, projectId uint64) (float64, error)
	AdjustProjectBalance(ctx context.Context, projectId uint64, amount float64, identifier string) (float64, error)
}

//
// Schema types
//

type ETHTxnStatus uint

const (
	ETHTxnStatus_UNKNOWN ETHTxnStatus = 0
	// txn rejected by relayer
	ETHTxnStatus_DROPPED ETHTxnStatus = 1
	// txn accepted by relayer, waiting to be sent
	ETHTxnStatus_QUEUED ETHTxnStatus = 2
	// txn sent, waiting for txn to be mined
	ETHTxnStatus_SENT ETHTxnStatus = 3
	// txn mined, all txns in the bundle succeeded
	ETHTxnStatus_SUCCEEDED ETHTxnStatus = 4
	// txn mined, but some txns in the bundle failed
	ETHTxnStatus_PARTIALLY_FAILED ETHTxnStatus = 5
	// txn mined, but all txns in the bundle failed
	ETHTxnStatus_FAILED ETHTxnStatus = 6
	// txn accepted by relayer, waiting for preconditions to be satisfied
	ETHTxnStatus_PENDING_PRECONDITION ETHTxnStatus = 7
)

var ETHTxnStatus_name = map[uint]string{
	0: "UNKNOWN",
	1: "DROPPED",
	2: "QUEUED",
	3: "SENT",
	4: "SUCCEEDED",
	5: "PARTIALLY_FAILED",
	6: "FAILED",
	7: "PENDING_PRECONDITION",
}

var ETHTxnStatus_value = map[string]uint{
	"UNKNOWN":              0,
	"DROPPED":              1,
	"QUEUED":               2,
	"SENT":                 3,
	"SUCCEEDED":            4,
	"PARTIALLY_FAILED":     5,
	"FAILED":               6,
	"PENDING_PRECONDITION": 7,
}

func (x ETHTxnStatus) String() string {
	return ETHTxnStatus_name[uint(x)]
}

func (x ETHTxnStatus) MarshalText() ([]byte, error) {
	return []byte(ETHTxnStatus_name[uint(x)]), nil
}

func (x *ETHTxnStatus) UnmarshalText(b []byte) error {
	*x = ETHTxnStatus(ETHTxnStatus_value[string(b)])
	return nil
}

func (x *ETHTxnStatus) Is(values ...ETHTxnStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TransferType uint32

const (
	TransferType_SEND            TransferType = 0
	TransferType_RECEIVE         TransferType = 1
	TransferType_BRIDGE_DEPOSIT  TransferType = 2
	TransferType_BRIDGE_WITHDRAW TransferType = 3
	TransferType_BURN            TransferType = 4
	TransferType_UNKNOWN         TransferType = 5
)

var TransferType_name = map[uint32]string{
	0: "SEND",
	1: "RECEIVE",
	2: "BRIDGE_DEPOSIT",
	3: "BRIDGE_WITHDRAW",
	4: "BURN",
	5: "UNKNOWN",
}

var TransferType_value = map[string]uint32{
	"SEND":            0,
	"RECEIVE":         1,
	"BRIDGE_DEPOSIT":  2,
	"BRIDGE_WITHDRAW": 3,
	"BURN":            4,
	"UNKNOWN":         5,
}

func (x TransferType) String() string {
	return TransferType_name[uint32(x)]
}

func (x TransferType) MarshalText() ([]byte, error) {
	return []byte(TransferType_name[uint32(x)]), nil
}

func (x *TransferType) UnmarshalText(b []byte) error {
	*x = TransferType(TransferType_value[string(b)])
	return nil
}

func (x *TransferType) Is(values ...TransferType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type SimulateStatus int

const (
	SimulateStatus_SKIPPED        SimulateStatus = 0
	SimulateStatus_SUCCEEDED      SimulateStatus = 1
	SimulateStatus_FAILED         SimulateStatus = 2
	SimulateStatus_ABORTED        SimulateStatus = 3
	SimulateStatus_REVERTED       SimulateStatus = 4
	SimulateStatus_NOT_ENOUGH_GAS SimulateStatus = 5
)

var SimulateStatus_name = map[int]string{
	0: "SKIPPED",
	1: "SUCCEEDED",
	2: "FAILED",
	3: "ABORTED",
	4: "REVERTED",
	5: "NOT_ENOUGH_GAS",
}

var SimulateStatus_value = map[string]int{
	"SKIPPED":        0,
	"SUCCEEDED":      1,
	"FAILED":         2,
	"ABORTED":        3,
	"REVERTED":       4,
	"NOT_ENOUGH_GAS": 5,
}

func (x SimulateStatus) String() string {
	return SimulateStatus_name[int(x)]
}

func (x SimulateStatus) MarshalText() ([]byte, error) {
	return []byte(SimulateStatus_name[int(x)]), nil
}

func (x *SimulateStatus) UnmarshalText(b []byte) error {
	*x = SimulateStatus(SimulateStatus_value[string(b)])
	return nil
}

func (x *SimulateStatus) Is(values ...SimulateStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type FeeTokenType uint32

const (
	FeeTokenType_UNKNOWN       FeeTokenType = 0
	FeeTokenType_ERC20_TOKEN   FeeTokenType = 1
	FeeTokenType_ERC1155_TOKEN FeeTokenType = 2
)

var FeeTokenType_name = map[uint32]string{
	0: "UNKNOWN",
	1: "ERC20_TOKEN",
	2: "ERC1155_TOKEN",
}

var FeeTokenType_value = map[string]uint32{
	"UNKNOWN":       0,
	"ERC20_TOKEN":   1,
	"ERC1155_TOKEN": 2,
}

func (x FeeTokenType) String() string {
	return FeeTokenType_name[uint32(x)]
}

func (x FeeTokenType) MarshalText() ([]byte, error) {
	return []byte(FeeTokenType_name[uint32(x)]), nil
}

func (x *FeeTokenType) UnmarshalText(b []byte) error {
	*x = FeeTokenType(FeeTokenType_value[string(b)])
	return nil
}

func (x *FeeTokenType) Is(values ...FeeTokenType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type SortOrder uint32

const (
	SortOrder_DESC SortOrder = 0
	SortOrder_ASC  SortOrder = 1
)

var SortOrder_name = map[uint32]string{
	0: "DESC",
	1: "ASC",
}

var SortOrder_value = map[string]uint32{
	"DESC": 0,
	"ASC":  1,
}

func (x SortOrder) String() string {
	return SortOrder_name[uint32(x)]
}

func (x SortOrder) MarshalText() ([]byte, error) {
	return []byte(SortOrder_name[uint32(x)]), nil
}

func (x *SortOrder) UnmarshalText(b []byte) error {
	*x = SortOrder(SortOrder_value[string(b)])
	return nil
}

func (x *SortOrder) Is(values ...SortOrder) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type Version struct {
	WebrpcVersion string `json:"webrpcVersion"`
	SchemaVersion string `json:"schemaVersion"`
	SchemaHash    string `json:"schemaHash"`
	AppVersion    string `json:"appVersion"`
}

type RuntimeStatus struct {
	// overall status, true/false
	HealthOK   bool            `json:"healthOK"`
	StartTime  time.Time       `json:"startTime"`
	Uptime     uint64          `json:"uptime"`
	Ver        string          `json:"ver"`
	Branch     string          `json:"branch"`
	CommitHash string          `json:"commitHash"`
	ChainID    uint64          `json:"chainID"`
	UseEIP1559 bool            `json:"useEIP1559"`
	Senders    []*SenderStatus `json:"senders"`
	Checks     *RuntimeChecks  `json:"checks"`
}

type SenderStatus struct {
	Index        uint32  `json:"index"`
	Address      string  `json:"address"`
	EtherBalance float64 `json:"etherBalance"`
	Active       bool    `json:"active"`
}

type RuntimeChecks struct {
}

type SequenceContext struct {
	Factory              string `json:"factory"`
	MainModule           string `json:"mainModule"`
	MainModuleUpgradable string `json:"mainModuleUpgradable"`
	GuestModule          string `json:"guestModule"`
	Utils                string `json:"utils"`
}

type GasTank struct {
	ID              uint64          `json:"id" db:"id,omitempty"`
	ChainID         uint64          `json:"chainId" db:"chain_id,omitempty"`
	Name            string          `json:"name" db:"name"`
	CurrentBalance  decimal.Decimal `json:"currentBalance" db:"current_balance"`
	Unlimited       bool            `json:"unlimited" db:"unlimited"`
	FeeMarkupFactor decimal.Decimal `json:"feeMarkupFactor" db:"fee_markup_factor"`
	UpdatedAt       *time.Time      `json:"updatedAt" db:"updated_at,omitempty"`
	CreatedAt       *time.Time      `json:"createdAt" db:"created_at,omitempty"`
}

type GasTankBalanceAdjustment struct {
	GasTankID        uint64          `json:"gasTankId" db:"gas_tank_id"`
	Nonce            uint64          `json:"nonce" db:"nonce"`
	Amount           decimal.Decimal `json:"amount" db:"amount"`
	TotalBalance     decimal.Decimal `json:"totalBalance" db:"total_balance"`
	BalanceTimestamp time.Time       `json:"balanceTimestamp" db:"balance_timestamp"`
	CreatedAt        *time.Time      `json:"createdAt" db:"created_at,omitempty"`
}

type GasSponsor struct {
	ID        uint64        `json:"id" db:"id,omitempty"`
	GasTankID uint64        `json:"gasTankId" db:"gas_tank_id,omitempty"`
	ProjectID uint64        `json:"projectId" db:"project_id"`
	ChainID   uint64        `json:"chainId" db:"chain_id,omitempty"`
	Address   prototyp.Hash `json:"address" db:"address"`
	Name      string        `json:"name" db:"name"`
	Active    bool          `json:"active" db:"active"`
	UpdatedAt *time.Time    `json:"updatedAt" db:"updated_at,omitempty"`
	CreatedAt *time.Time    `json:"createdAt" db:"created_at,omitempty"`
	DeletedAt *time.Time    `json:"-" db:"deleted_at,omitempty"`
}

type GasSponsorUsage struct {
	Name            string          `json:"name" db:"name"`
	ID              uint64          `json:"id" db:"gas_sponsor_id,omitempty"`
	TotalGasUsed    int64           `json:"totalGasUsed" db:"total_gas_used"`
	TotalTxnFees    float64         `json:"totalTxnFees" db:"total_txn_fees"`
	TotalTxnFeesUSD decimal.Decimal `json:"totalTxnFeesUsd" db:"total_txn_fees_usd"`
	AvgGasPrice     float64         `json:"avgGasPrice" db:"avg_gas_price"`
	TotalTxns       int64           `json:"totalTxns" db:"total_txns"`
	StartTime       *time.Time      `json:"startTime"`
	EndTime         *time.Time      `json:"endTime"`
}

// TODO: rename this to MetaTxnRaw (eventually), we can leave it for now to not break compat
// or name it, MetaTxnArgs ..?
type MetaTxn struct {
	WalletAddress string `json:"walletAddress" db:"wallet_address"`
	// TODO (later): rename this to `to: string`
	Contract string `json:"contract" db:"to_address"`
	// TODO: rename to 'execdata'
	Input string `json:"input" db:"tx_data"`
}

// TODO: review
type MetaTxnLog struct {
	ID        uint64 `json:"id" db:"id,omitempty"`
	ChainID   uint64 `json:"chainId" db:"chain_id,omitempty"`
	ProjectID uint64 `json:"projectId" db:"project_id"`
	// this is optional, but we don't specify txnHash?: string,
	// otherwise it sets go.field.type to pointer-type which we dont want.
	TxnHash prototyp.HashMaybe `json:"txnHash" db:"txn_hash"`
	// TODO: this should be txnNonce?: string, but pgx giving issues
	// with *prototyp.BigInt scanning
	TxnNonce        prototyp.BigInt `json:"txnNonce" db:"txn_nonce"`
	MetaTxnID       *string         `json:"metaTxnID" db:"meta_txn_id"`
	TxnStatus       ETHTxnStatus    `json:"txnStatus" db:"txn_status"`
	TxnRevertReason string          `json:"txnRevertReason" db:"txn_revert_reason"`
	Requeues        uint            `json:"requeues" db:"requeues"`
	QueuedAt        *time.Time      `json:"queuedAt" db:"queued_at,omitempty"`
	SentAt          *time.Time      `json:"sentAt" db:"sent_at,omitempty"`
	MinedAt         *time.Time      `json:"minedAt" db:"mined_at,omitempty"`
	Target          prototyp.Hash   `json:"target" db:"target"`
	Input           prototyp.Hash   `json:"input" db:"input"`
	// TODO: review this field.. we may not want it.. what goes in here..? is it just
	// the input/target from MetaTxn above? we already have these as separate columns..
	TxnArgs       map[string]interface{} `json:"txnArgs" db:"txn_args"`
	TxnReceipt    map[string]interface{} `json:"txnReceipt" db:"txn_receipt,omitempty"`
	WalletAddress prototyp.Hash          `json:"walletAddress" db:"wallet_address"`
	MetaTxnNonce  prototyp.BigInt        `json:"metaTxnNonce" db:"metatx_nonce"`
	GasLimit      uint64                 `json:"gasLimit" db:"gas_limit"`
	GasPrice      prototyp.BigInt        `json:"gasPrice" db:"gas_price"`
	GasUsed       uint64                 `json:"gasUsed" db:"gas_used"`
	GasEstimated  uint64                 `json:"gasEstimated" db:"gas_estimated"`
	GasFeeMarkup  *uint64                `json:"gasFeeMarkup" db:"gas_fee_markup"`
	UsdRate       prototyp.BigInt        `json:"usdRate" db:"usd_rate"`
	CreditsUsed   uint64                 `json:"creditsUsed" db:"credits_used"`
	Cost          decimal.Decimal        `json:"cost" db:"-"`
	IsWhitelisted bool                   `json:"isWhitelisted" db:"is_whitelisted,omitempty"`
	GasSponsor    *uint64                `json:"gasSponsor" db:"gas_sponsor_id,omitempty"`
	GasTank       *uint64                `json:"gasTank" db:"gas_tank_id,omitempty"`
	UpdatedAt     *time.Time             `json:"updatedAt" db:"updated_at,omitempty"`
	CreatedAt     *time.Time             `json:"createdAt" db:"created_at,omitempty"`
}

type MetaTxnReceipt struct {
	ID           string               `json:"id"`
	Status       string               `json:"status"`
	RevertReason *string              `json:"revertReason"`
	Index        uint                 `json:"index"`
	Logs         []*MetaTxnReceiptLog `json:"logs"`
	Receipts     []*MetaTxnReceipt    `json:"receipts"`
	BlockNumber  prototyp.BigInt      `json:"blockNumber"`
	TxnHash      string               `json:"txnHash"`
	TxnReceipt   string               `json:"txnReceipt"`
}

type MetaTxnReceiptLog struct {
	Address string   `json:"address"`
	Topics  []string `json:"topics"`
	Data    string   `json:"data"`
}

type Transactions struct {
	ChainID       prototyp.BigInt            `json:"chainId"`
	Transactions  []*Transaction             `json:"transactions"`
	Preconditions []*TransactionPrecondition `json:"preconditions,omitempty"`
}

type Transaction struct {
	DelegateCall  bool            `json:"delegateCall"`
	RevertOnError bool            `json:"revertOnError"`
	GasLimit      prototyp.BigInt `json:"gasLimit"`
	Target        prototyp.Hash   `json:"target"`
	Value         prototyp.BigInt `json:"value"`
	Data          prototyp.Hash   `json:"data"`
}

// Transaction preconditions based on https://eips.ethereum.org/EIPS/eip-7795
type TransactionPrecondition struct {
	// value must be 'tokenMinBalance'
	Type         string          `json:"type"`
	ChainID      uint64          `json:"chainId"`
	OwnerAddress prototyp.Hash   `json:"ownerAddress"`
	TokenAddress prototyp.Hash   `json:"tokenAddress"`
	MinAmount    prototyp.BigInt `json:"minAmount"`
}

// TODO: remove this.. we're not going to include username here anymore, the client will have to do it.
type TxnLogUser struct {
	Username string `json:"username"`
}

type TxnLogTransfer struct {
	TransferType    TransferType      `json:"transferType"`
	ContractAddress string            `json:"contractAddress"`
	From            string            `json:"from"`
	To              string            `json:"to"`
	Ids             []prototyp.BigInt `json:"ids"`
	Amounts         []prototyp.BigInt `json:"amounts"`
}

type SentTransactionsFilter struct {
	Pending *bool `json:"pending"`
	Failed  *bool `json:"failed"`
}

type SimulateResult struct {
	Executed  bool    `json:"executed"`
	Succeeded bool    `json:"succeeded"`
	Result    *string `json:"result"`
	Reason    *string `json:"reason"`
	GasUsed   uint    `json:"gasUsed"`
	GasLimit  uint    `json:"gasLimit"`
}

type SimulateV3Result struct {
	Status   SimulateStatus `json:"status"`
	Result   *string        `json:"result"`
	Error    *string        `json:"error"`
	GasUsed  uint64         `json:"gasUsed"`
	GasLimit uint64         `json:"gasLimit"`
}

type FeeOption struct {
	Token    *FeeToken `json:"token"`
	To       string    `json:"to"`
	Value    string    `json:"value"`
	GasLimit uint      `json:"gasLimit"`
}

type FeeToken struct {
	ChainId         uint64       `json:"chainId"`
	Name            string       `json:"name"`
	Symbol          string       `json:"symbol"`
	Type            FeeTokenType `json:"type"`
	Decimals        *uint32      `json:"decimals"`
	LogoURL         string       `json:"logoURL"`
	ContractAddress *string      `json:"contractAddress"`
	TokenID         *string      `json:"tokenID"`
}

// Page represents a results page. This can be used both to request a page and
// to store the state of a page.
type Page struct {
	// Common for both numbered pages and cursor: Number of items per page
	PageSize *uint32 `json:"pageSize"`
	// Numbered pages: Page number, this is multiplied by the value of the <pageSize> parameter.
	Page *uint32 `json:"page"`
	More *bool   `json:"more"`
	// Number of total items on this query.
	TotalRecords *uint64 `json:"total_records,omitempty"`
	// Cursor: column to compare before/after to
	Column *string `json:"column,omitempty"`
	// Cursor: return column < before - include to get previous page
	Before *interface{} `json:"before,omitempty"`
	// Cursor: return column > after - include to get next page
	After *interface{} `json:"after,omitempty"`
	// Sorting filter
	Sort []*SortBy `json:"sort,omitempty"`
}

type SortBy struct {
	Column string    `json:"column"`
	Order  SortOrder `json:"order"`
}

//
// Client
//

const RelayerPathPrefix = "/rpc/Relayer/"

type relayerClient struct {
	client HTTPClient
	urls   [33]string
}

func NewRelayerClient(addr string, client HTTPClient) RelayerClient {
	prefix := urlBase(addr) + RelayerPathPrefix
	urls := [33]string{
		prefix + "Ping",
		prefix + "Version",
		prefix + "RuntimeStatus",
		prefix + "GetSequenceContext",
		prefix + "GetChainID",
		prefix + "SendMetaTxn",
		prefix + "GetMetaTxnNonce",
		prefix + "GetMetaTxnReceipt",
		prefix + "Simulate",
		prefix + "SimulateV3",
		prefix + "UpdateMetaTxnGasLimits",
		prefix + "FeeTokens",
		prefix + "FeeOptions",
		prefix + "GetMetaTxnNetworkFeeOptions",
		prefix + "GetMetaTransactions",
		prefix + "GetTransactionCost",
		prefix + "SentTransactions",
		prefix + "PendingTransactions",
		prefix + "GetGasTank",
		prefix + "AddGasTank",
		prefix + "UpdateGasTank",
		prefix + "NextGasTankBalanceAdjustmentNonce",
		prefix + "AdjustGasTankBalance",
		prefix + "GetGasTankBalanceAdjustment",
		prefix + "ListGasTankBalanceAdjustments",
		prefix + "ListGasSponsors",
		prefix + "GetGasSponsor",
		prefix + "AddGasSponsor",
		prefix + "UpdateGasSponsor",
		prefix + "RemoveGasSponsor",
		prefix + "AddressGasSponsors",
		prefix + "GetProjectBalance",
		prefix + "AdjustProjectBalance",
	}
	return &relayerClient{
		client: client,
		urls:   urls,
	}
}

func (c *relayerClient) Ping(ctx context.Context) (bool, error) {
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) Version(ctx context.Context) (*Version, error) {
	out := struct {
		Ret0 *Version `json:"version"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) RuntimeStatus(ctx context.Context) (*RuntimeStatus, error) {
	out := struct {
		Ret0 *RuntimeStatus `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) GetSequenceContext(ctx context.Context) (*SequenceContext, error) {
	out := struct {
		Ret0 *SequenceContext `json:"data"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) GetChainID(ctx context.Context) (uint64, error) {
	out := struct {
		Ret0 uint64 `json:"chainID"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) SendMetaTxn(ctx context.Context, call *MetaTxn, quote *string, projectID *uint64, preconditions []*TransactionPrecondition) (bool, string, error) {
	in := struct {
		Arg0 *MetaTxn                   `json:"call"`
		Arg1 *string                    `json:"quote"`
		Arg2 *uint64                    `json:"projectID"`
		Arg3 []*TransactionPrecondition `json:"preconditions"`
	}{call, quote, projectID, preconditions}
	out := struct {
		Ret0 bool   `json:"status"`
		Ret1 string `json:"txnHash"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[5], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *relayerClient) GetMetaTxnNonce(ctx context.Context, walletContractAddress string, space *string) (string, error) {
	in := struct {
		Arg0 string  `json:"walletContractAddress"`
		Arg1 *string `json:"space"`
	}{walletContractAddress, space}
	out := struct {
		Ret0 string `json:"nonce"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[6], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) GetMetaTxnReceipt(ctx context.Context, metaTxID string) (*MetaTxnReceipt, error) {
	in := struct {
		Arg0 string `json:"metaTxID"`
	}{metaTxID}
	out := struct {
		Ret0 *MetaTxnReceipt `json:"receipt"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[7], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) Simulate(ctx context.Context, wallet string, transactions string) ([]*SimulateResult, error) {
	in := struct {
		Arg0 string `json:"wallet"`
		Arg1 string `json:"transactions"`
	}{wallet, transactions}
	out := struct {
		Ret0 []*SimulateResult `json:"results"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[8], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) SimulateV3(ctx context.Context, wallet string, calls string) ([]*SimulateV3Result, error) {
	in := struct {
		Arg0 string `json:"wallet"`
		Arg1 string `json:"calls"`
	}{wallet, calls}
	out := struct {
		Ret0 []*SimulateV3Result `json:"results"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[9], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) UpdateMetaTxnGasLimits(ctx context.Context, walletAddress string, walletConfig interface{}, payload string) (string, error) {
	in := struct {
		Arg0 string      `json:"walletAddress"`
		Arg1 interface{} `json:"walletConfig"`
		Arg2 string      `json:"payload"`
	}{walletAddress, walletConfig, payload}
	out := struct {
		Ret0 string `json:"payload"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[10], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) FeeTokens(ctx context.Context) (bool, []*FeeToken, string, error) {
	out := struct {
		Ret0 bool        `json:"isFeeRequired"`
		Ret1 []*FeeToken `json:"tokens"`
		Ret2 string      `json:"paymentAddress"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[11], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, out.Ret2, err
}

func (c *relayerClient) FeeOptions(ctx context.Context, wallet string, to string, data string, simulate *bool) ([]*FeeOption, bool, *string, error) {
	in := struct {
		Arg0 string `json:"wallet"`
		Arg1 string `json:"to"`
		Arg2 string `json:"data"`
		Arg3 *bool  `json:"simulate"`
	}{wallet, to, data, simulate}
	out := struct {
		Ret0 []*FeeOption `json:"options"`
		Ret1 bool         `json:"sponsored"`
		Ret2 *string      `json:"quote"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[12], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, out.Ret2, err
}

func (c *relayerClient) GetMetaTxnNetworkFeeOptions(ctx context.Context, walletConfig interface{}, payload string) ([]*FeeOption, error) {
	in := struct {
		Arg0 interface{} `json:"walletConfig"`
		Arg1 string      `json:"payload"`
	}{walletConfig, payload}
	out := struct {
		Ret0 []*FeeOption `json:"options"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[13], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) GetMetaTransactions(ctx context.Context, projectId uint64, page *Page) (*Page, []*MetaTxnLog, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 *Page  `json:"page"`
	}{projectId, page}
	out := struct {
		Ret0 *Page         `json:"page"`
		Ret1 []*MetaTxnLog `json:"transactions"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[14], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *relayerClient) GetTransactionCost(ctx context.Context, projectId uint64, from time.Time, to time.Time) (float64, error) {
	in := struct {
		Arg0 uint64    `json:"projectId"`
		Arg1 time.Time `json:"from"`
		Arg2 time.Time `json:"to"`
	}{projectId, from, to}
	out := struct {
		Ret0 float64 `json:"cost"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[15], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) SentTransactions(ctx context.Context, filter *SentTransactionsFilter, page *Page) (*Page, []*Transaction, error) {
	in := struct {
		Arg0 *SentTransactionsFilter `json:"filter"`
		Arg1 *Page                   `json:"page"`
	}{filter, page}
	out := struct {
		Ret0 *Page          `json:"page"`
		Ret1 []*Transaction `json:"transactions"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[16], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *relayerClient) PendingTransactions(ctx context.Context, page *Page) (*Page, []*Transaction, error) {
	in := struct {
		Arg0 *Page `json:"page"`
	}{page}
	out := struct {
		Ret0 *Page          `json:"page"`
		Ret1 []*Transaction `json:"transactions"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[17], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *relayerClient) GetGasTank(ctx context.Context, id uint64) (*GasTank, error) {
	in := struct {
		Arg0 uint64 `json:"id"`
	}{id}
	out := struct {
		Ret0 *GasTank `json:"gasTank"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[18], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) AddGasTank(ctx context.Context, name string, feeMarkupFactor float64, unlimited *bool) (bool, *GasTank, error) {
	in := struct {
		Arg0 string  `json:"name"`
		Arg1 float64 `json:"feeMarkupFactor"`
		Arg2 *bool   `json:"unlimited"`
	}{name, feeMarkupFactor, unlimited}
	out := struct {
		Ret0 bool     `json:"status"`
		Ret1 *GasTank `json:"gasTank"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[19], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *relayerClient) UpdateGasTank(ctx context.Context, id uint64, name *string, feeMarkupFactor *float64, unlimited *bool) (bool, *GasTank, error) {
	in := struct {
		Arg0 uint64   `json:"id"`
		Arg1 *string  `json:"name"`
		Arg2 *float64 `json:"feeMarkupFactor"`
		Arg3 *bool    `json:"unlimited"`
	}{id, name, feeMarkupFactor, unlimited}
	out := struct {
		Ret0 bool     `json:"status"`
		Ret1 *GasTank `json:"gasTank"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[20], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *relayerClient) NextGasTankBalanceAdjustmentNonce(ctx context.Context, id uint64) (uint64, error) {
	in := struct {
		Arg0 uint64 `json:"id"`
	}{id}
	out := struct {
		Ret0 uint64 `json:"nonce"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[21], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) AdjustGasTankBalance(ctx context.Context, id uint64, nonce uint64, amount float64) (bool, *GasTankBalanceAdjustment, error) {
	in := struct {
		Arg0 uint64  `json:"id"`
		Arg1 uint64  `json:"nonce"`
		Arg2 float64 `json:"amount"`
	}{id, nonce, amount}
	out := struct {
		Ret0 bool                      `json:"status"`
		Ret1 *GasTankBalanceAdjustment `json:"adjustment"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[22], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *relayerClient) GetGasTankBalanceAdjustment(ctx context.Context, id uint64, nonce uint64) (*GasTankBalanceAdjustment, error) {
	in := struct {
		Arg0 uint64 `json:"id"`
		Arg1 uint64 `json:"nonce"`
	}{id, nonce}
	out := struct {
		Ret0 *GasTankBalanceAdjustment `json:"adjustment"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[23], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) ListGasTankBalanceAdjustments(ctx context.Context, id uint64, page *Page) (*Page, []*GasTankBalanceAdjustment, error) {
	in := struct {
		Arg0 uint64 `json:"id"`
		Arg1 *Page  `json:"page"`
	}{id, page}
	out := struct {
		Ret0 *Page                       `json:"page"`
		Ret1 []*GasTankBalanceAdjustment `json:"adjustments"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[24], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *relayerClient) ListGasSponsors(ctx context.Context, projectId uint64, page *Page) (*Page, []*GasSponsor, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 *Page  `json:"page"`
	}{projectId, page}
	out := struct {
		Ret0 *Page         `json:"page"`
		Ret1 []*GasSponsor `json:"gasSponsors"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[25], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *relayerClient) GetGasSponsor(ctx context.Context, projectId uint64, id uint64) (*GasSponsor, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 uint64 `json:"id"`
	}{projectId, id}
	out := struct {
		Ret0 *GasSponsor `json:"gasSponsor"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[26], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) AddGasSponsor(ctx context.Context, projectId uint64, address string, name *string, active *bool) (bool, *GasSponsor, error) {
	in := struct {
		Arg0 uint64  `json:"projectId"`
		Arg1 string  `json:"address"`
		Arg2 *string `json:"name"`
		Arg3 *bool   `json:"active"`
	}{projectId, address, name, active}
	out := struct {
		Ret0 bool        `json:"status"`
		Ret1 *GasSponsor `json:"gasSponsor"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[27], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *relayerClient) UpdateGasSponsor(ctx context.Context, projectId uint64, id uint64, name *string, active *bool) (bool, *GasSponsor, error) {
	in := struct {
		Arg0 uint64  `json:"projectId"`
		Arg1 uint64  `json:"id"`
		Arg2 *string `json:"name"`
		Arg3 *bool   `json:"active"`
	}{projectId, id, name, active}
	out := struct {
		Ret0 bool        `json:"status"`
		Ret1 *GasSponsor `json:"gasSponsor"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[28], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *relayerClient) RemoveGasSponsor(ctx context.Context, projectId uint64, id uint64) (bool, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 uint64 `json:"id"`
	}{projectId, id}
	out := struct {
		Ret0 bool `json:"status"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[29], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) AddressGasSponsors(ctx context.Context, address string, page *Page) (*Page, []*GasSponsor, error) {
	in := struct {
		Arg0 string `json:"address"`
		Arg1 *Page  `json:"page"`
	}{address, page}
	out := struct {
		Ret0 *Page         `json:"page"`
		Ret1 []*GasSponsor `json:"gasSponsors"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[30], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *relayerClient) GetProjectBalance(ctx context.Context, projectId uint64) (float64, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
	}{projectId}
	out := struct {
		Ret0 float64 `json:"balance"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[31], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *relayerClient) AdjustProjectBalance(ctx context.Context, projectId uint64, amount float64, identifier string) (float64, error) {
	in := struct {
		Arg0 uint64  `json:"projectId"`
		Arg1 float64 `json:"amount"`
		Arg2 string  `json:"identifier"`
	}{projectId, amount, identifier}
	out := struct {
		Ret0 float64 `json:"balance"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[32], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

//
// Client helpers
//

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// urlBase helps ensure that addr specifies a scheme. If it is unparsable
// as a URL, it returns addr unchanged.
func urlBase(addr string) string {
	// If the addr specifies a scheme, use it. If not, default to
	// http. If url.Parse fails on it, return it unchanged.
	url, err := url.Parse(addr)
	if err != nil {
		return addr
	}
	if url.Scheme == "" {
		url.Scheme = "http"
	}
	return url.String()
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) {
	req, err := http.NewRequestWithContext(ctx, "POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", contentType)
	req.Header.Set("Content-Type", contentType)
	req.Header.Set(WebrpcHeader, WebrpcHeaderValue)
	if headers, ok := HTTPRequestHeaders(ctx); ok {
		for k := range headers {
			for _, v := range headers[k] {
				req.Header.Add(k, v)
			}
		}
	}
	return req, nil
}

// doHTTPRequest is common code to make a request to the remote service.
func doHTTPRequest(ctx context.Context, client HTTPClient, url string, in, out interface{}) (*http.Response, error) {
	reqBody, err := json.Marshal(in)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("failed to marshal JSON body: %w", err)
	}
	if err = ctx.Err(); err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("aborted because context was done: %w", err)
	}

	req, err := newRequest(ctx, url, bytes.NewBuffer(reqBody), "application/json")
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("could not build request: %w", err)
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(err)
	}

	if resp.StatusCode != 200 {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to read server error response body: %w", err)
		}

		var rpcErr WebRPCError
		if err := json.Unmarshal(respBody, &rpcErr); err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to unmarshal server error: %w", err)
		}
		if rpcErr.Cause != "" {
			rpcErr.cause = errors.New(rpcErr.Cause)
		}
		return nil, rpcErr
	}

	if out != nil {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to read response body: %w", err)
		}

		err = json.Unmarshal(respBody, &out)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to unmarshal JSON response body: %w", err)
		}
	}

	return resp, nil
}

func WithHTTPRequestHeaders(ctx context.Context, h http.Header) (context.Context, error) {
	if _, ok := h["Accept"]; ok {
		return nil, errors.New("provided header cannot set Accept")
	}
	if _, ok := h["Content-Type"]; ok {
		return nil, errors.New("provided header cannot set Content-Type")
	}

	copied := make(http.Header, len(h))
	for k, vv := range h {
		if vv == nil {
			copied[k] = nil
			continue
		}
		copied[k] = make([]string, len(vv))
		copy(copied[k], vv)
	}

	return context.WithValue(ctx, HTTPClientRequestHeadersCtxKey, copied), nil
}

func HTTPRequestHeaders(ctx context.Context) (http.Header, bool) {
	h, ok := ctx.Value(HTTPClientRequestHeadersCtxKey).(http.Header)
	return h, ok
}

//
// Webrpc helpers
//

type contextKey struct {
	name string
}

func (k *contextKey) String() string {
	return "webrpc context value " + k.name
}

var (
	HTTPClientRequestHeadersCtxKey = &contextKey{"HTTPClientRequestHeaders"}
)

// PtrTo is a useful helper when constructing values for optional fields.
func PtrTo[T any](v T) *T { return &v }

//
// BigInt helpers
//

// BigInt is an alias of big.Int with custom JSON (decimal string) encoding.
type BigInt big.Int

func NewBigInt(v int64) BigInt { var bi big.Int; bi.SetInt64(v); return BigInt(bi) }

// AsInt exposes the underlying *big.Int.
func (b *BigInt) AsInt() *big.Int { return (*big.Int)(b) }

// String returns the decimal string representation of the BigInt.
func (b BigInt) String() string { return b.AsInt().String() }

// MarshalText implements encoding.TextMarshaler.
func (b BigInt) MarshalText() ([]byte, error) {
	return []byte(fmt.Sprintf("\"%s\"", b.String())), nil
}

// UnmarshalText implements encoding.TextUnmarshaler.
func (b *BigInt) UnmarshalText(text []byte) error {
	if len(text) == 0 {
		return nil
	}
	if len(text) == 4 && text[0] == 'n' && string(text) == "null" {
		return nil
	}
	for _, c := range text {
		if c == ' ' || c == '\t' || c == '\n' || c == '\r' {
			return fmt.Errorf("BigInt.UnmarshalText: unexpected whitespace in %q", text)
		}
	}
	var digits []byte
	if text[0] == '-' || (text[0] >= '0' && text[0] <= '9') {
		digits = text
	} else {
		if len(text) < 2 || text[0] != '"' || text[len(text)-1] != '"' {
			return fmt.Errorf("BigInt.UnmarshalText: unsupported format %q", text)
		}
		digits = text[1 : len(text)-1]
	}
	i, ok := big.NewInt(0).SetString(string(digits), 10)
	if !ok {
		return fmt.Errorf("BigInt.UnmarshalText: failed to parse %q", text)
	}
	*b = BigInt(*i)
	return nil
}

// MarshalJSON implements json.Marshaler
func (b BigInt) MarshalJSON() ([]byte, error) {
	return b.MarshalText()
}

// UnmarshalJSON implements json.Unmarshaler
func (b *BigInt) UnmarshalJSON(text []byte) error {
	if string(text) == "null" {
		return nil
	}
	return b.UnmarshalText(text)
}

// MarshalBinary implements encoding.BinaryMarshaler. The first byte is the sign byte
// to represent positive or negative numbers.
func (b BigInt) MarshalBinary() ([]byte, error) {
	bytes := b.AsInt().Bytes()
	out := make([]byte, len(bytes)+1)
	copy(out[1:], bytes)
	if b.AsInt().Sign() < 0 {
		// Prepend a sign byte (0xFF for negative)
		out[0] = 0xFF
	} else {
		// For zero or positive numbers, prepend 0x00
		out[0] = 0x00
	}
	return out, nil
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler. The first byte is the sign byte
// to represent positive or negative numbers.
func (b *BigInt) UnmarshalBinary(buff []byte) error {
	if len(buff) == 0 {
		*b = BigInt(*big.NewInt(0))
		return nil
	}
	// Extract the sign byte
	signByte := buff[0]
	i := new(big.Int)
	if len(buff) > 1 {
		i.SetBytes(buff[1:])
	}
	// Apply sign if negative
	if signByte == 0xFF {
		i.Neg(i)
	}
	*b = BigInt(*i)
	return nil
}

func (b BigInt) Value() (driver.Value, error) {
	return b.String(), nil
}

func (b *BigInt) Scan(src interface{}) error {
	if src == nil {
		return nil
	}

	var svalue string
	switch v := src.(type) {
	case string:
		svalue = v
	case []byte:
		svalue = string(v)
	default:
		return fmt.Errorf("BigInt.Scan: unexpected type %T", src)
	}

	// pgx driver returns NeX where N is digits and X is exponent
	parts := strings.SplitN(svalue, "e", 2)

	var ok bool
	i := &big.Int{}
	i, ok = i.SetString(parts[0], 10)
	if !ok {
		return fmt.Errorf("BigInt.Scan: failed to scan value %q", svalue)
	}

	if len(parts) >= 2 {
		exp := big.NewInt(0)
		exp, ok = exp.SetString(parts[1], 10)
		if !ok {
			return fmt.Errorf("BigInt.Scan failed to scan exp component %q", svalue)
		}
		i = i.Mul(i, big.NewInt(1).Exp(big.NewInt(10), exp, nil))
	}

	*b = BigInt(*i)
	return nil
}

//
// Errors
//

type WebRPCError struct {
	Name       string `json:"error"`
	Code       int    `json:"code"`
	Message    string `json:"msg"`
	Cause      string `json:"cause,omitempty"`
	HTTPStatus int    `json:"status"`
	cause      error
}

var _ error = WebRPCError{}

func (e WebRPCError) Error() string {
	if e.cause != nil {
		return fmt.Sprintf("%s %d: %s: %v", e.Name, e.Code, e.Message, e.cause)
	}
	return fmt.Sprintf("%s %d: %s", e.Name, e.Code, e.Message)
}

func (e WebRPCError) Is(target error) bool {
	if target == nil {
		return false
	}
	if rpcErr, ok := target.(WebRPCError); ok {
		return rpcErr.Code == e.Code
	}
	return errors.Is(e.cause, target)
}

func (e WebRPCError) Unwrap() error {
	return e.cause
}

func (e WebRPCError) WithCause(cause error) WebRPCError {
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

func (e WebRPCError) WithCausef(format string, args ...interface{}) WebRPCError {
	cause := fmt.Errorf(format, args...)
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

// Deprecated: Use .WithCause() method on WebRPCError.
func ErrorWithCause(rpcErr WebRPCError, cause error) WebRPCError {
	return rpcErr.WithCause(cause)
}

// Webrpc errors
var (
	ErrWebrpcEndpoint       = WebRPCError{Code: 0, Name: "WebrpcEndpoint", Message: "endpoint error", HTTPStatus: 400}
	ErrWebrpcRequestFailed  = WebRPCError{Code: -1, Name: "WebrpcRequestFailed", Message: "request failed", HTTPStatus: 400}
	ErrWebrpcBadRoute       = WebRPCError{Code: -2, Name: "WebrpcBadRoute", Message: "bad route", HTTPStatus: 404}
	ErrWebrpcBadMethod      = WebRPCError{Code: -3, Name: "WebrpcBadMethod", Message: "bad method", HTTPStatus: 405}
	ErrWebrpcBadRequest     = WebRPCError{Code: -4, Name: "WebrpcBadRequest", Message: "bad request", HTTPStatus: 400}
	ErrWebrpcBadResponse    = WebRPCError{Code: -5, Name: "WebrpcBadResponse", Message: "bad response", HTTPStatus: 500}
	ErrWebrpcServerPanic    = WebRPCError{Code: -6, Name: "WebrpcServerPanic", Message: "server panic", HTTPStatus: 500}
	ErrWebrpcInternalError  = WebRPCError{Code: -7, Name: "WebrpcInternalError", Message: "internal error", HTTPStatus: 500}
	ErrWebrpcClientAborted  = WebRPCError{Code: -8, Name: "WebrpcClientAborted", Message: "request aborted by client", HTTPStatus: 400}
	ErrWebrpcStreamLost     = WebRPCError{Code: -9, Name: "WebrpcStreamLost", Message: "stream lost", HTTPStatus: 400}
	ErrWebrpcStreamFinished = WebRPCError{Code: -10, Name: "WebrpcStreamFinished", Message: "stream finished", HTTPStatus: 200}
)

// Schema errors
var (
	ErrUnauthorized      = WebRPCError{Code: 1000, Name: "Unauthorized", Message: "Unauthorized access", HTTPStatus: 401}
	ErrPermissionDenied  = WebRPCError{Code: 1001, Name: "PermissionDenied", Message: "Permission denied", HTTPStatus: 403}
	ErrSessionExpired    = WebRPCError{Code: 1002, Name: "SessionExpired", Message: "Session expired", HTTPStatus: 403}
	ErrMethodNotFound    = WebRPCError{Code: 1003, Name: "MethodNotFound", Message: "Method not found", HTTPStatus: 404}
	ErrRequestConflict   = WebRPCError{Code: 1004, Name: "RequestConflict", Message: "Conflict with target resource", HTTPStatus: 409}
	ErrAborted           = WebRPCError{Code: 1005, Name: "Aborted", Message: "Request aborted", HTTPStatus: 400}
	ErrGeoblocked        = WebRPCError{Code: 1006, Name: "Geoblocked", Message: "Geoblocked region", HTTPStatus: 451}
	ErrRateLimited       = WebRPCError{Code: 1007, Name: "RateLimited", Message: "Rate-limited. Please slow down.", HTTPStatus: 429}
	ErrProjectNotFound   = WebRPCError{Code: 1008, Name: "ProjectNotFound", Message: "Project not found", HTTPStatus: 401}
	ErrAccessKeyNotFound = WebRPCError{Code: 1101, Name: "AccessKeyNotFound", Message: "Access key not found", HTTPStatus: 401}
	ErrAccessKeyMismatch = WebRPCError{Code: 1102, Name: "AccessKeyMismatch", Message: "Access key mismatch", HTTPStatus: 409}
	ErrInvalidOrigin     = WebRPCError{Code: 1103, Name: "InvalidOrigin", Message: "Invalid origin for Access Key", HTTPStatus: 403}
	ErrInvalidService    = WebRPCError{Code: 1104, Name: "InvalidService", Message: "Service not enabled for Access key", HTTPStatus: 403}
	ErrUnauthorizedUser  = WebRPCError{Code: 1105, Name: "UnauthorizedUser", Message: "Unauthorized user", HTTPStatus: 403}
	ErrQuotaExceeded     = WebRPCError{Code: 1200, Name: "QuotaExceeded", Message: "Quota request exceeded", HTTPStatus: 429}
	ErrQuotaRateLimit    = WebRPCError{Code: 1201, Name: "QuotaRateLimit", Message: "Quota rate limit exceeded", HTTPStatus: 429}
	ErrNoDefaultKey      = WebRPCError{Code: 1300, Name: "NoDefaultKey", Message: "No default access key found", HTTPStatus: 403}
	ErrMaxAccessKeys     = WebRPCError{Code: 1301, Name: "MaxAccessKeys", Message: "Access keys limit reached", HTTPStatus: 403}
	ErrAtLeastOneKey     = WebRPCError{Code: 1302, Name: "AtLeastOneKey", Message: "You need at least one Access Key", HTTPStatus: 403}
	ErrTimeout           = WebRPCError{Code: 1900, Name: "Timeout", Message: "Request timed out", HTTPStatus: 408}
	ErrInvalidArgument   = WebRPCError{Code: 2001, Name: "InvalidArgument", Message: "Invalid argument", HTTPStatus: 400}
	ErrUnavailable       = WebRPCError{Code: 2002, Name: "Unavailable", Message: "Unavailable resource", HTTPStatus: 400}
	ErrQueryFailed       = WebRPCError{Code: 2003, Name: "QueryFailed", Message: "Query failed", HTTPStatus: 400}
	ErrNotFound          = WebRPCError{Code: 3000, Name: "NotFound", Message: "Resource not found", HTTPStatus: 400}
	ErrInsufficientFee   = WebRPCError{Code: 3004, Name: "InsufficientFee", Message: "Insufficient fee", HTTPStatus: 402}
	ErrNotEnoughBalance  = WebRPCError{Code: 3005, Name: "NotEnoughBalance", Message: "Not enough balance", HTTPStatus: 402}
	ErrSimulationFailed  = WebRPCError{Code: 3006, Name: "SimulationFailed", Message: "Simulation failed", HTTPStatus: 400}
)

const WebrpcHeader = "Webrpc"

const WebrpcHeaderValue = "webrpc@v0.31.2;gen-golang@v0.23.3;sequence-relayer@v0.4.1"

type WebrpcGenVersions struct {
	WebrpcGenVersion string
	CodeGenName      string
	CodeGenVersion   string
	SchemaName       string
	SchemaVersion    string
}

func VersionFromHeader(h http.Header) (*WebrpcGenVersions, error) {
	if h.Get(WebrpcHeader) == "" {
		return nil, fmt.Errorf("header is empty or missing")
	}

	versions, err := parseWebrpcGenVersions(h.Get(WebrpcHeader))
	if err != nil {
		return nil, fmt.Errorf("webrpc header is invalid: %w", err)
	}

	return versions, nil
}

func parseWebrpcGenVersions(header string) (*WebrpcGenVersions, error) {
	versions := strings.Split(header, ";")
	if len(versions) < 3 {
		return nil, fmt.Errorf("expected at least 3 parts while parsing webrpc header: %v", header)
	}

	_, webrpcGenVersion, ok := strings.Cut(versions[0], "@")
	if !ok {
		return nil, fmt.Errorf("webrpc gen version could not be parsed from: %s", versions[0])
	}

	tmplTarget, tmplVersion, ok := strings.Cut(versions[1], "@")
	if !ok {
		return nil, fmt.Errorf("tmplTarget and tmplVersion could not be parsed from: %s", versions[1])
	}

	schemaName, schemaVersion, ok := strings.Cut(versions[2], "@")
	if !ok {
		return nil, fmt.Errorf("schema name and schema version could not be parsed from: %s", versions[2])
	}

	return &WebrpcGenVersions{
		WebrpcGenVersion: webrpcGenVersion,
		CodeGenName:      tmplTarget,
		CodeGenVersion:   tmplVersion,
		SchemaName:       schemaName,
		SchemaVersion:    schemaVersion,
	}, nil
}
