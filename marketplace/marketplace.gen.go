// marketplace-api  b5774f13b4560eb460ec8b9a464299fcb195c6b3
// --
// Code generated by webrpc-gen@v0.22.0 with golang generator. DO NOT EDIT.
//
// webrpc-gen -schema=proto/marketplace.ridl -target=golang -pkg=marketplace -client -out=proto/clients/marketplace.gen.go
package marketplace

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)

const WebrpcHeader = "Webrpc"

const WebrpcHeaderValue = "webrpc@v0.22.0;gen-golang@v0.17.0;marketplace-api@v0.0.0-b5774f13b4560eb460ec8b9a464299fcb195c6b3"

// WebRPC description and code-gen version
func WebRPCVersion() string {
	return "v1"
}

// Schema version of your RIDL schema
func WebRPCSchemaVersion() string {
	return ""
}

// Schema hash generated from your RIDL schema
func WebRPCSchemaHash() string {
	return "b5774f13b4560eb460ec8b9a464299fcb195c6b3"
}

type WebrpcGenVersions struct {
	WebrpcGenVersion string
	CodeGenName      string
	CodeGenVersion   string
	SchemaName       string
	SchemaVersion    string
}

func VersionFromHeader(h http.Header) (*WebrpcGenVersions, error) {
	if h.Get(WebrpcHeader) == "" {
		return nil, fmt.Errorf("header is empty or missing")
	}

	versions, err := parseWebrpcGenVersions(h.Get(WebrpcHeader))
	if err != nil {
		return nil, fmt.Errorf("webrpc header is invalid: %w", err)
	}

	return versions, nil
}

func parseWebrpcGenVersions(header string) (*WebrpcGenVersions, error) {
	versions := strings.Split(header, ";")
	if len(versions) < 3 {
		return nil, fmt.Errorf("expected at least 3 parts while parsing webrpc header: %v", header)
	}

	_, webrpcGenVersion, ok := strings.Cut(versions[0], "@")
	if !ok {
		return nil, fmt.Errorf("webrpc gen version could not be parsed from: %s", versions[0])
	}

	tmplTarget, tmplVersion, ok := strings.Cut(versions[1], "@")
	if !ok {
		return nil, fmt.Errorf("tmplTarget and tmplVersion could not be parsed from: %s", versions[1])
	}

	schemaName, schemaVersion, ok := strings.Cut(versions[2], "@")
	if !ok {
		return nil, fmt.Errorf("schema name and schema version could not be parsed from: %s", versions[2])
	}

	return &WebrpcGenVersions{
		WebrpcGenVersion: webrpcGenVersion,
		CodeGenName:      tmplTarget,
		CodeGenVersion:   tmplVersion,
		SchemaName:       schemaName,
		SchemaVersion:    schemaVersion,
	}, nil
}

//
// Common types
//

// TokenMetadata based on 721/1155 standards, as well including some
// fields which are used by OpenSea.
//
// TokenMetadata is RPC type for responding to clients that represents
// the token-level metadata.
type TokenMetadata struct {
	TokenID     string `json:"tokenId" cbor:"-"`
	Name        string `json:"name" cbor:"-"`
	Description string `json:"description" cbor:"-"`
	// url
	Image string `json:"image" cbor:"-"`
	// non-standard fields we've added for Sequence. Others should adopt
	// these too and we should prompt, similar to how `image` field works.
	// url
	Video string `json:"video,omitempty" cbor:"-"`
	// url
	Audio      string                 `json:"audio,omitempty" cbor:"-"`
	Properties map[string]interface{} `json:"properties" cbor:"-"`
	// OpenSea fields
	// see https://docs.opensea.io/docs/metadata-standards
	//
	// NOTE: its a bit unfortunate OpenSea didn't use camelCase, and
	// also introduces 'attributes' when 'properties' is actually the correct property name.
	// TODO: we could smooth this out / normalize it, but we can leave it for now.
	Attributes      []map[string]interface{} `json:"attributes" cbor:"-"`
	ImageData       string                   `json:"image_data,omitempty" cbor:"-"`
	ExternalUrl     string                   `json:"external_url,omitempty" cbor:"-"`
	BackgroundColor string                   `json:"background_color,omitempty" cbor:"-"`
	AnimationUrl    string                   `json:"animation_url,omitempty" cbor:"-"`
	//
	// Misc
	//
	// decimals is deprecated, but still used by some
	Decimals  *uint64   `json:"decimals,omitempty" cbor:"-"`
	UpdatedAt time.Time `json:"updatedAt" cbor:"-"`
	// Assets associated to this token metadata
	Assets []*Asset `json:"assets,omitempty" cbor:"-"`
}

// Asset is a database type used by 'collections' to record static assets for
// a particular 'token' for the token metadata.
//
// db table: assets
type Asset struct {
	// asset id
	ID uint64 `json:"id" db:"id,omitempty"`
	// collection id associated to this asset
	CollectionID uint64 `json:"collectionId" db:"collection_id"`
	// token id associated to this collection
	TokenID prototyp.BigInt `json:"tokenId" db:"token_id"`
	// url where we can view the asset contents
	// ie. https://metadata.sequence.app/projects/1/collections/1/tokens/1/image
	URL string `json:"url" db:"-"`
	// metadata field related to TokenMetadata, some field names:
	// ['image', 'video', 'audio', 'animation_url', ...]
	MetadataField string `json:"metadataField,omitempty" db:"metadata_field"`
	// asset details
	Filename  string    `json:"filename,omitempty" db:"filename"`
	Filesize  uint32    `json:"filesize,omitempty" db:"filesize"`
	MimeType  string    `json:"mimeType,omitempty" db:"mime_type"`
	Width     *uint16   `json:"width,omitempty" db:"width"`
	Height    *uint16   `json:"height,omitempty" db:"height"`
	UpdatedAt time.Time `json:"updatedAt" db:"updated_at"`
}

type SortOrder uint32

const (
	SortOrder_DESC SortOrder = 0
	SortOrder_ASC  SortOrder = 1
)

var SortOrder_name = map[uint32]string{
	0: "DESC",
	1: "ASC",
}

var SortOrder_value = map[string]uint32{
	"DESC": 0,
	"ASC":  1,
}

func (x SortOrder) String() string {
	return SortOrder_name[uint32(x)]
}

func (x SortOrder) MarshalText() ([]byte, error) {
	return []byte(SortOrder_name[uint32(x)]), nil
}

func (x *SortOrder) UnmarshalText(b []byte) error {
	*x = SortOrder(SortOrder_value[string(b)])
	return nil
}

func (x *SortOrder) Is(values ...SortOrder) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type PropertyType uint32

const (
	PropertyType_INT     PropertyType = 0
	PropertyType_STRING  PropertyType = 1
	PropertyType_ARRAY   PropertyType = 2
	PropertyType_GENERIC PropertyType = 3
)

var PropertyType_name = map[uint32]string{
	0: "INT",
	1: "STRING",
	2: "ARRAY",
	3: "GENERIC",
}

var PropertyType_value = map[string]uint32{
	"INT":     0,
	"STRING":  1,
	"ARRAY":   2,
	"GENERIC": 3,
}

func (x PropertyType) String() string {
	return PropertyType_name[uint32(x)]
}

func (x PropertyType) MarshalText() ([]byte, error) {
	return []byte(PropertyType_name[uint32(x)]), nil
}

func (x *PropertyType) UnmarshalText(b []byte) error {
	*x = PropertyType(PropertyType_value[string(b)])
	return nil
}

func (x *PropertyType) Is(values ...PropertyType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type MarketplaceKind uint32

const (
	MarketplaceKind_unknown                 MarketplaceKind = 0
	MarketplaceKind_sequence_marketplace_v1 MarketplaceKind = 1
	MarketplaceKind_sequence_marketplace_v2 MarketplaceKind = 2
	MarketplaceKind_blur                    MarketplaceKind = 3
	MarketplaceKind_zerox                   MarketplaceKind = 4
	MarketplaceKind_opensea                 MarketplaceKind = 5
	MarketplaceKind_looks_rare              MarketplaceKind = 6
	MarketplaceKind_x2y2                    MarketplaceKind = 7
	MarketplaceKind_alienswap               MarketplaceKind = 8
	MarketplaceKind_payment_processor       MarketplaceKind = 9
	MarketplaceKind_mintify                 MarketplaceKind = 10
)

var MarketplaceKind_name = map[uint32]string{
	0:  "unknown",
	1:  "sequence_marketplace_v1",
	2:  "sequence_marketplace_v2",
	3:  "blur",
	4:  "zerox",
	5:  "opensea",
	6:  "looks_rare",
	7:  "x2y2",
	8:  "alienswap",
	9:  "payment_processor",
	10: "mintify",
}

var MarketplaceKind_value = map[string]uint32{
	"unknown":                 0,
	"sequence_marketplace_v1": 1,
	"sequence_marketplace_v2": 2,
	"blur":                    3,
	"zerox":                   4,
	"opensea":                 5,
	"looks_rare":              6,
	"x2y2":                    7,
	"alienswap":               8,
	"payment_processor":       9,
	"mintify":                 10,
}

func (x MarketplaceKind) String() string {
	return MarketplaceKind_name[uint32(x)]
}

func (x MarketplaceKind) MarshalText() ([]byte, error) {
	return []byte(MarketplaceKind_name[uint32(x)]), nil
}

func (x *MarketplaceKind) UnmarshalText(b []byte) error {
	*x = MarketplaceKind(MarketplaceKind_value[string(b)])
	return nil
}

func (x *MarketplaceKind) Is(values ...MarketplaceKind) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type OrderbookKind uint32

const (
	OrderbookKind_unknown                 OrderbookKind = 0
	OrderbookKind_sequence_marketplace_v1 OrderbookKind = 1
	OrderbookKind_sequence_marketplace_v2 OrderbookKind = 2
	OrderbookKind_blur                    OrderbookKind = 3
	OrderbookKind_opensea                 OrderbookKind = 4
	OrderbookKind_looks_rare              OrderbookKind = 5
	OrderbookKind_reservoir               OrderbookKind = 6
	OrderbookKind_x2y2                    OrderbookKind = 7
)

var OrderbookKind_name = map[uint32]string{
	0: "unknown",
	1: "sequence_marketplace_v1",
	2: "sequence_marketplace_v2",
	3: "blur",
	4: "opensea",
	5: "looks_rare",
	6: "reservoir",
	7: "x2y2",
}

var OrderbookKind_value = map[string]uint32{
	"unknown":                 0,
	"sequence_marketplace_v1": 1,
	"sequence_marketplace_v2": 2,
	"blur":                    3,
	"opensea":                 4,
	"looks_rare":              5,
	"reservoir":               6,
	"x2y2":                    7,
}

func (x OrderbookKind) String() string {
	return OrderbookKind_name[uint32(x)]
}

func (x OrderbookKind) MarshalText() ([]byte, error) {
	return []byte(OrderbookKind_name[uint32(x)]), nil
}

func (x *OrderbookKind) UnmarshalText(b []byte) error {
	*x = OrderbookKind(OrderbookKind_value[string(b)])
	return nil
}

func (x *OrderbookKind) Is(values ...OrderbookKind) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type SourceKind uint32

const (
	SourceKind_unknown                 SourceKind = 0
	SourceKind_external                SourceKind = 1
	SourceKind_sequence_marketplace_v1 SourceKind = 2
	SourceKind_sequence_marketplace_v2 SourceKind = 3
)

var SourceKind_name = map[uint32]string{
	0: "unknown",
	1: "external",
	2: "sequence_marketplace_v1",
	3: "sequence_marketplace_v2",
}

var SourceKind_value = map[string]uint32{
	"unknown":                 0,
	"external":                1,
	"sequence_marketplace_v1": 2,
	"sequence_marketplace_v2": 3,
}

func (x SourceKind) String() string {
	return SourceKind_name[uint32(x)]
}

func (x SourceKind) MarshalText() ([]byte, error) {
	return []byte(SourceKind_name[uint32(x)]), nil
}

func (x *SourceKind) UnmarshalText(b []byte) error {
	*x = SourceKind(SourceKind_value[string(b)])
	return nil
}

func (x *SourceKind) Is(values ...SourceKind) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type OrderSide uint8

const (
	OrderSide_unknown OrderSide = 0
	// Ask
	OrderSide_listing OrderSide = 1
	// Bid
	OrderSide_offer OrderSide = 2
)

var OrderSide_name = map[uint8]string{
	0: "unknown",
	1: "listing",
	2: "offer",
}

var OrderSide_value = map[string]uint8{
	"unknown": 0,
	"listing": 1,
	"offer":   2,
}

func (x OrderSide) String() string {
	return OrderSide_name[uint8(x)]
}

func (x OrderSide) MarshalText() ([]byte, error) {
	return []byte(OrderSide_name[uint8(x)]), nil
}

func (x *OrderSide) UnmarshalText(b []byte) error {
	*x = OrderSide(OrderSide_value[string(b)])
	return nil
}

func (x *OrderSide) Is(values ...OrderSide) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type OrderStatus uint8

const (
	OrderStatus_unknown OrderStatus = 0
	// Fillable
	OrderStatus_active OrderStatus = 1
	// Temporarily unfillable, due to balance / approval
	OrderStatus_inactive OrderStatus = 2
	// Permanently unfillable, due to expiry
	OrderStatus_expired OrderStatus = 3
	// Permanently unfillable, due to cancellation (by user or protocol)
	OrderStatus_cancelled OrderStatus = 4
	// Permanently unfillable, because it's been completely filled
	OrderStatus_filled OrderStatus = 5
	// Decimals are missing on collectible needs to be synced and order updated
	OrderStatus_decimals_missing OrderStatus = 6
)

var OrderStatus_name = map[uint8]string{
	0: "unknown",
	1: "active",
	2: "inactive",
	3: "expired",
	4: "cancelled",
	5: "filled",
	6: "decimals_missing",
}

var OrderStatus_value = map[string]uint8{
	"unknown":          0,
	"active":           1,
	"inactive":         2,
	"expired":          3,
	"cancelled":        4,
	"filled":           5,
	"decimals_missing": 6,
}

func (x OrderStatus) String() string {
	return OrderStatus_name[uint8(x)]
}

func (x OrderStatus) MarshalText() ([]byte, error) {
	return []byte(OrderStatus_name[uint8(x)]), nil
}

func (x *OrderStatus) UnmarshalText(b []byte) error {
	*x = OrderStatus(OrderStatus_value[string(b)])
	return nil
}

func (x *OrderStatus) Is(values ...OrderStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type ContractType uint16

const (
	ContractType_UNKNOWN ContractType = 0
	ContractType_ERC20   ContractType = 1
	ContractType_ERC721  ContractType = 2
	ContractType_ERC1155 ContractType = 3
)

var ContractType_name = map[uint16]string{
	0: "UNKNOWN",
	1: "ERC20",
	2: "ERC721",
	3: "ERC1155",
}

var ContractType_value = map[string]uint16{
	"UNKNOWN": 0,
	"ERC20":   1,
	"ERC721":  2,
	"ERC1155": 3,
}

func (x ContractType) String() string {
	return ContractType_name[uint16(x)]
}

func (x ContractType) MarshalText() ([]byte, error) {
	return []byte(ContractType_name[uint16(x)]), nil
}

func (x *ContractType) UnmarshalText(b []byte) error {
	*x = ContractType(ContractType_value[string(b)])
	return nil
}

func (x *ContractType) Is(values ...ContractType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type CollectionStatus uint8

const (
	CollectionStatus_unknown          CollectionStatus = 0
	CollectionStatus_created          CollectionStatus = 1
	CollectionStatus_syncing_metadata CollectionStatus = 2
	CollectionStatus_synced_metadata  CollectionStatus = 3
	CollectionStatus_syncing_tokens   CollectionStatus = 4
	CollectionStatus_synced_tokens    CollectionStatus = 5
	CollectionStatus_syncing_orders   CollectionStatus = 6
	CollectionStatus_active           CollectionStatus = 7
	CollectionStatus_failed           CollectionStatus = 8
	CollectionStatus_inactive         CollectionStatus = 9
)

var CollectionStatus_name = map[uint8]string{
	0: "unknown",
	1: "created",
	2: "syncing_metadata",
	3: "synced_metadata",
	4: "syncing_tokens",
	5: "synced_tokens",
	6: "syncing_orders",
	7: "active",
	8: "failed",
	9: "inactive",
}

var CollectionStatus_value = map[string]uint8{
	"unknown":          0,
	"created":          1,
	"syncing_metadata": 2,
	"synced_metadata":  3,
	"syncing_tokens":   4,
	"synced_tokens":    5,
	"syncing_orders":   6,
	"active":           7,
	"failed":           8,
	"inactive":         9,
}

func (x CollectionStatus) String() string {
	return CollectionStatus_name[uint8(x)]
}

func (x CollectionStatus) MarshalText() ([]byte, error) {
	return []byte(CollectionStatus_name[uint8(x)]), nil
}

func (x *CollectionStatus) UnmarshalText(b []byte) error {
	*x = CollectionStatus(CollectionStatus_value[string(b)])
	return nil
}

func (x *CollectionStatus) Is(values ...CollectionStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type ProjectStatus uint8

const (
	ProjectStatus_unknown  ProjectStatus = 0
	ProjectStatus_active   ProjectStatus = 1
	ProjectStatus_inactive ProjectStatus = 2
)

var ProjectStatus_name = map[uint8]string{
	0: "unknown",
	1: "active",
	2: "inactive",
}

var ProjectStatus_value = map[string]uint8{
	"unknown":  0,
	"active":   1,
	"inactive": 2,
}

func (x ProjectStatus) String() string {
	return ProjectStatus_name[uint8(x)]
}

func (x ProjectStatus) MarshalText() ([]byte, error) {
	return []byte(ProjectStatus_name[uint8(x)]), nil
}

func (x *ProjectStatus) UnmarshalText(b []byte) error {
	*x = ProjectStatus(ProjectStatus_value[string(b)])
	return nil
}

func (x *ProjectStatus) Is(values ...ProjectStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type CollectibleStatus uint8

const (
	CollectibleStatus_unknown  CollectibleStatus = 0
	CollectibleStatus_active   CollectibleStatus = 1
	CollectibleStatus_inactive CollectibleStatus = 2
)

var CollectibleStatus_name = map[uint8]string{
	0: "unknown",
	1: "active",
	2: "inactive",
}

var CollectibleStatus_value = map[string]uint8{
	"unknown":  0,
	"active":   1,
	"inactive": 2,
}

func (x CollectibleStatus) String() string {
	return CollectibleStatus_name[uint8(x)]
}

func (x CollectibleStatus) MarshalText() ([]byte, error) {
	return []byte(CollectibleStatus_name[uint8(x)]), nil
}

func (x *CollectibleStatus) UnmarshalText(b []byte) error {
	*x = CollectibleStatus(CollectibleStatus_value[string(b)])
	return nil
}

func (x *CollectibleStatus) Is(values ...CollectibleStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type WalletKind uint8

const (
	WalletKind_unknown  WalletKind = 0
	WalletKind_sequence WalletKind = 1
)

var WalletKind_name = map[uint8]string{
	0: "unknown",
	1: "sequence",
}

var WalletKind_value = map[string]uint8{
	"unknown":  0,
	"sequence": 1,
}

func (x WalletKind) String() string {
	return WalletKind_name[uint8(x)]
}

func (x WalletKind) MarshalText() ([]byte, error) {
	return []byte(WalletKind_name[uint8(x)]), nil
}

func (x *WalletKind) UnmarshalText(b []byte) error {
	*x = WalletKind(WalletKind_value[string(b)])
	return nil
}

func (x *WalletKind) Is(values ...WalletKind) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type StepType uint8

const (
	StepType_unknown       StepType = 0
	StepType_tokenApproval StepType = 1
	StepType_buy           StepType = 2
	StepType_sell          StepType = 3
	StepType_createListing StepType = 4
	StepType_createOffer   StepType = 5
	StepType_signEIP712    StepType = 6
	StepType_signEIP191    StepType = 7
	StepType_cancel        StepType = 8
)

var StepType_name = map[uint8]string{
	0: "unknown",
	1: "tokenApproval",
	2: "buy",
	3: "sell",
	4: "createListing",
	5: "createOffer",
	6: "signEIP712",
	7: "signEIP191",
	8: "cancel",
}

var StepType_value = map[string]uint8{
	"unknown":       0,
	"tokenApproval": 1,
	"buy":           2,
	"sell":          3,
	"createListing": 4,
	"createOffer":   5,
	"signEIP712":    6,
	"signEIP191":    7,
	"cancel":        8,
}

func (x StepType) String() string {
	return StepType_name[uint8(x)]
}

func (x StepType) MarshalText() ([]byte, error) {
	return []byte(StepType_name[uint8(x)]), nil
}

func (x *StepType) UnmarshalText(b []byte) error {
	*x = StepType(StepType_value[string(b)])
	return nil
}

func (x *StepType) Is(values ...StepType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TransactionCrypto uint32

const (
	TransactionCrypto_none      TransactionCrypto = 0
	TransactionCrypto_partially TransactionCrypto = 1
	TransactionCrypto_all       TransactionCrypto = 2
)

var TransactionCrypto_name = map[uint32]string{
	0: "none",
	1: "partially",
	2: "all",
}

var TransactionCrypto_value = map[string]uint32{
	"none":      0,
	"partially": 1,
	"all":       2,
}

func (x TransactionCrypto) String() string {
	return TransactionCrypto_name[uint32(x)]
}

func (x TransactionCrypto) MarshalText() ([]byte, error) {
	return []byte(TransactionCrypto_name[uint32(x)]), nil
}

func (x *TransactionCrypto) UnmarshalText(b []byte) error {
	*x = TransactionCrypto(TransactionCrypto_value[string(b)])
	return nil
}

func (x *TransactionCrypto) Is(values ...TransactionCrypto) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TransactionNFTCheckoutProvider uint32

const (
	TransactionNFTCheckoutProvider_unknown TransactionNFTCheckoutProvider = 0
	TransactionNFTCheckoutProvider_sardine TransactionNFTCheckoutProvider = 1
	TransactionNFTCheckoutProvider_transak TransactionNFTCheckoutProvider = 2
)

var TransactionNFTCheckoutProvider_name = map[uint32]string{
	0: "unknown",
	1: "sardine",
	2: "transak",
}

var TransactionNFTCheckoutProvider_value = map[string]uint32{
	"unknown": 0,
	"sardine": 1,
	"transak": 2,
}

func (x TransactionNFTCheckoutProvider) String() string {
	return TransactionNFTCheckoutProvider_name[uint32(x)]
}

func (x TransactionNFTCheckoutProvider) MarshalText() ([]byte, error) {
	return []byte(TransactionNFTCheckoutProvider_name[uint32(x)]), nil
}

func (x *TransactionNFTCheckoutProvider) UnmarshalText(b []byte) error {
	*x = TransactionNFTCheckoutProvider(TransactionNFTCheckoutProvider_value[string(b)])
	return nil
}

func (x *TransactionNFTCheckoutProvider) Is(values ...TransactionNFTCheckoutProvider) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TransactionOnRampProvider uint32

const (
	TransactionOnRampProvider_unknown TransactionOnRampProvider = 0
	TransactionOnRampProvider_sardine TransactionOnRampProvider = 1
	TransactionOnRampProvider_transak TransactionOnRampProvider = 2
)

var TransactionOnRampProvider_name = map[uint32]string{
	0: "unknown",
	1: "sardine",
	2: "transak",
}

var TransactionOnRampProvider_value = map[string]uint32{
	"unknown": 0,
	"sardine": 1,
	"transak": 2,
}

func (x TransactionOnRampProvider) String() string {
	return TransactionOnRampProvider_name[uint32(x)]
}

func (x TransactionOnRampProvider) MarshalText() ([]byte, error) {
	return []byte(TransactionOnRampProvider_name[uint32(x)]), nil
}

func (x *TransactionOnRampProvider) UnmarshalText(b []byte) error {
	*x = TransactionOnRampProvider(TransactionOnRampProvider_value[string(b)])
	return nil
}

func (x *TransactionOnRampProvider) Is(values ...TransactionOnRampProvider) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TransactionSwapProvider uint32

const (
	TransactionSwapProvider_unknown TransactionSwapProvider = 0
	TransactionSwapProvider_zerox   TransactionSwapProvider = 1
)

var TransactionSwapProvider_name = map[uint32]string{
	0: "unknown",
	1: "zerox",
}

var TransactionSwapProvider_value = map[string]uint32{
	"unknown": 0,
	"zerox":   1,
}

func (x TransactionSwapProvider) String() string {
	return TransactionSwapProvider_name[uint32(x)]
}

func (x TransactionSwapProvider) MarshalText() ([]byte, error) {
	return []byte(TransactionSwapProvider_name[uint32(x)]), nil
}

func (x *TransactionSwapProvider) UnmarshalText(b []byte) error {
	*x = TransactionSwapProvider(TransactionSwapProvider_value[string(b)])
	return nil
}

func (x *TransactionSwapProvider) Is(values ...TransactionSwapProvider) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type ExecuteType uint32

const (
	ExecuteType_unknown ExecuteType = 0
	ExecuteType_order   ExecuteType = 1
)

var ExecuteType_name = map[uint32]string{
	0: "unknown",
	1: "order",
}

var ExecuteType_value = map[string]uint32{
	"unknown": 0,
	"order":   1,
}

func (x ExecuteType) String() string {
	return ExecuteType_name[uint32(x)]
}

func (x ExecuteType) MarshalText() ([]byte, error) {
	return []byte(ExecuteType_name[uint32(x)]), nil
}

func (x *ExecuteType) UnmarshalText(b []byte) error {
	*x = ExecuteType(ExecuteType_value[string(b)])
	return nil
}

func (x *ExecuteType) Is(values ...ExecuteType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

// Page represents a results page. This can be used both to request a page and
// to store the state of a page.
type Page struct {
	// Numbered pages: Page number, this is multiplied by the value of the <pageSize> parameter.
	Page uint32 `json:"page,omitempty"`
	// Number of items per page
	PageSize uint32 `json:"pageSize,omitempty"`
	// Indicates if there are more results available
	More *bool `json:"more,omitempty"`
	// Sorting filter
	Sort []*SortBy `json:"sort,omitempty"`
}

type SortBy struct {
	Column string    `json:"column"`
	Order  SortOrder `json:"order"`
}

// copied from metadata filter
// PropertyFilter
// name -> name of the property, eg: hero
// type -> type of the values of the property, eg: Int, string
// min?, max? used if type is int, gives range of values for filtering
// values? -> if string then array of values, eg: ['Ada', 'Ari', 'Axel', 'Banjo' ...]
// NOTE: When Filter has an array of PropertyFilter, the logic used is an 'and' condition
// whereas if the user selects multiple values inside the PropertyFilter, they logic used is the 'or' condition
// this is to achieve the desired effect opensea had on their filters
type Filter struct {
	Text       *string           `json:"text"`
	Properties []*PropertyFilter `json:"properties"`
}

type PropertyFilter struct {
	Name   string        `json:"name"`
	Type   PropertyType  `json:"type"`
	Min    *int64        `json:"min"`
	Max    *int64        `json:"max"`
	Values []interface{} `json:"values"`
}

type CollectiblesFilter struct {
	IncludeEmpty bool              `json:"includeEmpty"`
	SearchText   *string           `json:"searchText"`
	Properties   []*PropertyFilter `json:"properties"`
	Marketplaces []MarketplaceKind `json:"marketplaces"`
	// filter collectibles owned by given account addresses
	InAccounts []string `json:"inAccounts"`
	// filter out collectibles owned by given account addresses
	NotInAccounts []string `json:"notInAccounts"`
	// filter orders created by given account addresses
	OrdersCreatedBy []string `json:"ordersCreatedBy"`
	// filter out orders created by given account addresses
	OrdersNotCreatedBy []string `json:"ordersNotCreatedBy"`
}

type Order struct {
	ID            uint64          `json:"-" db:"id,omitempty"`
	CollectionID  uint64          `json:"-" db:"collection_id,omitempty"`
	CollectibleID uint64          `json:"-" db:"collectible_id,omitempty"`
	OrderID       string          `json:"orderId" db:"order_id"`
	Marketplace   MarketplaceKind `json:"marketplace" db:"marketplace"`
	Source        SourceKind      `json:"-" db:"source"`
	Side          OrderSide       `json:"side" db:"side"`
	Status        OrderStatus     `json:"status" db:"status"`
	ChainID       uint64          `json:"chainId" db:"chain_id"`
	OriginName    string          `json:"originName,omitempty" db:"origin_name"`
	// contract
	CollectionContractAddress  prototyp.Hash   `json:"collectionContractAddress" db:"contract_address"`
	TokenID                    prototyp.BigInt `json:"tokenId" db:"token_id"`
	CreatedBy                  prototyp.Hash   `json:"createdBy" db:"created_by"`
	PriceAmount                prototyp.BigInt `json:"priceAmount" db:"price_amount"`
	PriceAmountFormatted       string          `json:"priceAmountFormatted"`
	PriceAmountNet             prototyp.BigInt `json:"priceAmountNet" db:"price_amount_net"`
	PriceAmountNetFormatted    string          `json:"priceAmountNetFormatted"`
	PriceCurrencyAddress       prototyp.Hash   `json:"priceCurrencyAddress" db:"price_currency_address"`
	PriceDecimals              uint64          `json:"priceDecimals" db:"price_decimals"`
	PriceUSD                   float64         `json:"priceUSD" db:"price_usd"`
	QuantityInitial            prototyp.BigInt `json:"quantityInitial" db:"qty_initial"`
	QuantityInitialFormatted   string          `json:"quantityInitialFormatted"`
	QuantityRemaining          prototyp.BigInt `json:"quantityRemaining" db:"qty_remaining"`
	QuantityRemainingFormatted string          `json:"quantityRemainingFormatted"`
	QuantityAvailable          prototyp.BigInt `json:"quantityAvailable" db:"qty_available"`
	QuantityAvailableFormatted string          `json:"quantityAvailableFormatted"`
	QuantityDecimals           uint64          `json:"quantityDecimals" db:"qty_decimals"`
	FeeBPS                     int64           `json:"feeBps" db:"fee_bps"`
	FeeBreakdown               []*FeeBreakdown `json:"feeBreakdown" db:"fee_breakdown"`
	ValidFrom                  time.Time       `json:"validFrom" db:"valid_from"`
	// expiration
	ValidUntil     time.Time  `json:"validUntil" db:"valid_until"`
	BlockNumber    uint64     `json:"blockNumber" db:"block_number"`
	OrderCreatedAt *time.Time `json:"orderCreatedAt" db:"order_created_at"`
	OrderUpdatedAt *time.Time `json:"orderUpdatedAt" db:"order_updated_at"`
	CreatedAt      time.Time  `json:"createdAt" db:"created_at"`
	UpdatedAt      time.Time  `json:"updatedAt" db:"updated_at"`
	DeletedAt      *time.Time `json:"deletedAt,omitempty" db:"deleted_at"`
}

type FeeBreakdown struct {
	Kind             string `json:"kind"`
	RecipientAddress string `json:"recipientAddress"`
	Bps              int64  `json:"bps"`
}

type CollectibleOrder struct {
	Metadata *TokenMetadata `json:"metadata"`
	Order    *Order         `json:"order"`
}

type OrderFilter struct {
	CreatedBy   []string          `json:"createdBy"`
	Marketplace []MarketplaceKind `json:"marketplace"`
	Currencies  []string          `json:"currencies"`
}

type Activity struct {
	Type        string    `json:"type"`
	FromAddress string    `json:"fromAddress"`
	ToAddress   string    `json:"toAddress"`
	TxHash      string    `json:"txHash"`
	Timestamp   int64     `json:"timestamp"`
	TokenId     string    `json:"tokenId"`
	TokenImage  string    `json:"tokenImage"`
	TokenName   string    `json:"tokenName"`
	Currency    *Currency `json:"currency"`
}

type Collection struct {
	ID                       uint64            `json:"-" db:"id,omitempty"`
	Status                   CollectionStatus  `json:"status" db:"status"`
	ChainID                  uint64            `json:"chainId" db:"chain_id"`
	ContractAddress          prototyp.Hash     `json:"contractAddress" db:"contract_address"`
	ContractType             ContractType      `json:"contractType" db:"contract_type"`
	TokenQuantityDecimals    uint64            `json:"tokenQuantityDecimals" db:"token_qty_decimals"`
	Config                   *CollectionConfig `json:"config" db:"config"`
	RefreshMetadataJob       uint64            `json:"-" db:"refresh_metadata_job"`
	RefreshMetadataTimestamp time.Time         `json:"-" db:"refresh_metadata_timestamp"`
	CreatedAt                time.Time         `json:"createdAt" db:"created_at"`
	UpdatedAt                time.Time         `json:"updatedAt" db:"updated_at"`
	DeletedAt                *time.Time        `json:"deletedAt,omitempty" db:"deleted_at"`
}

type CollectionConfig struct {
	LastSynced         map[string]*CollectionLastSynced `json:"lastSynced"`
	CollectiblesSynced time.Time                        `json:"collectiblesSynced"`
}

type CollectionLastSynced struct {
	AllOrders time.Time `json:"allOrders"`
	NewOrders time.Time `json:"newOrders"`
}

type Project struct {
	ID              uint64        `json:"-" db:"id,omitempty"`
	ProjectID       uint64        `json:"projectId" db:"project_id"`
	CollectionID    uint64        `json:"-" db:"collection_id,omitempty"`
	ChainID         uint64        `json:"chainId" db:"chain_id"`
	ContractAddress prototyp.Hash `json:"contractAddress" db:"contract_address"`
	Status          ProjectStatus `json:"status" db:"status"`
	CreatedAt       time.Time     `json:"createdAt" db:"created_at"`
	UpdatedAt       time.Time     `json:"updatedAt" db:"updated_at"`
	DeletedAt       *time.Time    `json:"deletedAt,omitempty" db:"deleted_at"`
}

type Collectible struct {
	ID              uint64            `json:"-" db:"id,omitempty"`
	CollectionID    uint64            `json:"-" db:"collection_id,omitempty"`
	ChainID         uint64            `json:"chainId" db:"chain_id"`
	ContractAddress prototyp.Hash     `json:"contractAddress" db:"contract_address"`
	Status          CollectibleStatus `json:"status" db:"status"`
	TokenID         prototyp.BigInt   `json:"tokenId" db:"token_id"`
	Decimals        uint64            `json:"decimals" db:"decimals"`
	CreatedAt       time.Time         `json:"createdAt" db:"created_at"`
	UpdatedAt       time.Time         `json:"updatedAt" db:"updated_at"`
	DeletedAt       *time.Time        `json:"deletedAt,omitempty" db:"deleted_at"`
}

type Currency struct {
	ID                   uint64        `json:"-" db:"id,omitempty"`
	ChainID              uint64        `json:"chainId" db:"chain_id"`
	ContractAddress      prototyp.Hash `json:"contractAddress,omitempty" db:"contract_address"`
	Name                 string        `json:"name" db:"name"`
	Symbol               string        `json:"symbol" db:"symbol"`
	Decimals             uint64        `json:"decimals" db:"decimals"`
	ImageURL             string        `json:"imageUrl" db:"image_url"`
	ExchangeRate         float64       `json:"exchangeRate" db:"exchange_rate"`
	DefaultChainCurrency bool          `json:"defaultChainCurrency" db:"default_chain_currency"`
	NativeCurrency       bool          `json:"nativeCurrency" db:"native_currency"`
	CreatedAt            time.Time     `json:"createdAt" db:"created_at"`
	UpdatedAt            time.Time     `json:"updatedAt" db:"updated_at"`
	DeletedAt            *time.Time    `json:"deletedAt,omitempty" db:"deleted_at"`
}

type OrderData struct {
	OrderID  string `json:"orderId"`
	Quantity string `json:"quantity"`
}

type AdditionalFee struct {
	Amount   string `json:"amount"`
	Receiver string `json:"receiver"`
}

type Step struct {
	Id          StepType     `json:"id"`
	Data        string       `json:"data"`
	To          string       `json:"to"`
	Value       string       `json:"value"`
	Signature   *Signature   `json:"signature"`
	Post        *PostRequest `json:"post"`
	ExecuteType *ExecuteType `json:"executeType"`
}

type PostRequest struct {
	Endpoint string      `json:"endpoint"`
	Method   string      `json:"method"`
	Body     interface{} `json:"body"`
}

type CreateReq struct {
	TokenId         string `json:"tokenId"`
	Quantity        string `json:"quantity"`
	Expiry          string `json:"expiry"`
	CurrencyAddress string `json:"currencyAddress"`
	PricePerToken   string `json:"pricePerToken"`
}

type GetOrdersInput struct {
	ContractAddress prototyp.Hash   `json:"contractAddress"`
	OrderID         string          `json:"orderId"`
	Marketplace     MarketplaceKind `json:"marketplace"`
}

type Signature struct {
	Domain      *Domain     `json:"domain"`
	Types       interface{} `json:"types"`
	PrimaryType string      `json:"primaryType"`
	Value       interface{} `json:"value"`
}

type Domain struct {
	Name              string `json:"name"`
	Version           string `json:"version"`
	ChainID           uint64 `json:"chainId"`
	VerifyingContract string `json:"verifyingContract"`
}

type CheckoutOptionsMarketplaceOrder struct {
	ContractAddress prototyp.Hash   `json:"contractAddress"`
	OrderID         string          `json:"orderId"`
	Marketplace     MarketplaceKind `json:"marketplace"`
}

type CheckoutOptionsItem struct {
	TokenID  string          `json:"tokenId"`
	Quantity prototyp.BigInt `json:"quantity"`
}

type CheckoutOptions struct {
	Crypto      TransactionCrypto                `json:"crypto"`
	Swap        []TransactionSwapProvider        `json:"swap"`
	NFTCheckout []TransactionNFTCheckoutProvider `json:"nftCheckout"`
	OnRamp      []TransactionOnRampProvider      `json:"onRamp"`
}

var methods = map[string]method{
	"/rpc/Admin/CreateCollection": {
		Name:        "CreateCollection",
		Service:     "Admin",
		Annotations: map[string]string{"auth": "AccessKey", "credits": "300"},
	},
	"/rpc/Admin/GetCollection": {
		Name:        "GetCollection",
		Service:     "Admin",
		Annotations: map[string]string{"auth": "AccessKey", "credits": "300"},
	},
	"/rpc/Admin/ListCollections": {
		Name:        "ListCollections",
		Service:     "Admin",
		Annotations: map[string]string{"auth": "AccessKey", "credits": "300"},
	},
	"/rpc/Admin/DeleteCollection": {
		Name:        "DeleteCollection",
		Service:     "Admin",
		Annotations: map[string]string{"auth": "AccessKey", "credits": "300"},
	},
	"/rpc/Admin/SyncCollection": {
		Name:        "SyncCollection",
		Service:     "Admin",
		Annotations: map[string]string{"auth": "AccessKey", "credits": "300"},
	},
	"/rpc/Admin/CreateCurrency": {
		Name:        "CreateCurrency",
		Service:     "Admin",
		Annotations: map[string]string{"auth": "AccessKey", "credits": "300a"},
	},
	"/rpc/Admin/CreateCurrencies": {
		Name:        "CreateCurrencies",
		Service:     "Admin",
		Annotations: map[string]string{"auth": "AccessKey", "credits": "300"},
	},
	"/rpc/Admin/UpdateCurrency": {
		Name:        "UpdateCurrency",
		Service:     "Admin",
		Annotations: map[string]string{"auth": "AccessKey", "credits": "300"},
	},
	"/rpc/Admin/ListCurrencies": {
		Name:        "ListCurrencies",
		Service:     "Admin",
		Annotations: map[string]string{"auth": "AccessKey", "credits": "300"},
	},
	"/rpc/Admin/DeleteCurrency": {
		Name:        "DeleteCurrency",
		Service:     "Admin",
		Annotations: map[string]string{"auth": "AccessKey", "credits": "300"},
	},
	"/rpc/Marketplace/ListCurrencies": {
		Name:        "ListCurrencies",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/GetCollectible": {
		Name:        "GetCollectible",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/GetLowestPriceOfferForCollectible": {
		Name:        "GetLowestPriceOfferForCollectible",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/GetHighestPriceOfferForCollectible": {
		Name:        "GetHighestPriceOfferForCollectible",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/GetLowestPriceListingForCollectible": {
		Name:        "GetLowestPriceListingForCollectible",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/GetHighestPriceListingForCollectible": {
		Name:        "GetHighestPriceListingForCollectible",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/ListListingsForCollectible": {
		Name:        "ListListingsForCollectible",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/ListOffersForCollectible": {
		Name:        "ListOffersForCollectible",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/GetCountOfListingsForCollectible": {
		Name:        "GetCountOfListingsForCollectible",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/GetCountOfOffersForCollectible": {
		Name:        "GetCountOfOffersForCollectible",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/GetCollectibleLowestOffer": {
		Name:        "GetCollectibleLowestOffer",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300", "deprecated": "GetLowestPriceOfferForCollectible"},
	},
	"/rpc/Marketplace/GetCollectibleHighestOffer": {
		Name:        "GetCollectibleHighestOffer",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300", "deprecated": "GetHighestPriceOfferForCollectible"},
	},
	"/rpc/Marketplace/GetCollectibleLowestListing": {
		Name:        "GetCollectibleLowestListing",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300", "deprecated": "GetLowestPriceListingForCollectible"},
	},
	"/rpc/Marketplace/GetCollectibleHighestListing": {
		Name:        "GetCollectibleHighestListing",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300", "deprecated": "GetHighestPriceListingForCollectible"},
	},
	"/rpc/Marketplace/ListCollectibleListings": {
		Name:        "ListCollectibleListings",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300", "deprecated": "ListListingsForCollectible"},
	},
	"/rpc/Marketplace/ListCollectibleOffers": {
		Name:        "ListCollectibleOffers",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300", "deprecated": "ListOffersForCollectible"},
	},
	"/rpc/Marketplace/GenerateBuyTransaction": {
		Name:        "GenerateBuyTransaction",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/GenerateSellTransaction": {
		Name:        "GenerateSellTransaction",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/GenerateListingTransaction": {
		Name:        "GenerateListingTransaction",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/GenerateOfferTransaction": {
		Name:        "GenerateOfferTransaction",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/GenerateCancelTransaction": {
		Name:        "GenerateCancelTransaction",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/Execute": {
		Name:        "Execute",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/ListCollectibles": {
		Name:        "ListCollectibles",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/GetCountOfAllCollectibles": {
		Name:        "GetCountOfAllCollectibles",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/GetCountOfFilteredCollectibles": {
		Name:        "GetCountOfFilteredCollectibles",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/GetFloorOrder": {
		Name:        "GetFloorOrder",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/ListCollectiblesWithLowestListing": {
		Name:        "ListCollectiblesWithLowestListing",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300", "deprecated": "ListCollectibles"},
	},
	"/rpc/Marketplace/ListCollectiblesWithHighestOffer": {
		Name:        "ListCollectiblesWithHighestOffer",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300", "deprecated": "ListCollectibles"},
	},
	"/rpc/Marketplace/SyncOrder": {
		Name:        "SyncOrder",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300", "internal": ""},
	},
	"/rpc/Marketplace/SyncOrders": {
		Name:        "SyncOrders",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300", "internal": ""},
	},
	"/rpc/Marketplace/GetOrders": {
		Name:        "GetOrders",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/CheckoutOptionsMarketplace": {
		Name:        "CheckoutOptionsMarketplace",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
	"/rpc/Marketplace/CheckoutOptionsSalesContract": {
		Name:        "CheckoutOptionsSalesContract",
		Service:     "Marketplace",
		Annotations: map[string]string{"auth": "Public", "credits": "300"},
	},
}

func WebrpcMethods() map[string]method {
	res := make(map[string]method, len(methods))
	for k, v := range methods {
		res[k] = v
	}

	return res
}

var WebRPCServices = map[string][]string{
	"Admin": {
		"CreateCollection",
		"GetCollection",
		"ListCollections",
		"DeleteCollection",
		"SyncCollection",
		"CreateCurrency",
		"CreateCurrencies",
		"UpdateCurrency",
		"ListCurrencies",
		"DeleteCurrency",
	},
	"Marketplace": {
		"ListCurrencies",
		"GetCollectible",
		"GetLowestPriceOfferForCollectible",
		"GetHighestPriceOfferForCollectible",
		"GetLowestPriceListingForCollectible",
		"GetHighestPriceListingForCollectible",
		"ListListingsForCollectible",
		"ListOffersForCollectible",
		"GetCountOfListingsForCollectible",
		"GetCountOfOffersForCollectible",
		"GetCollectibleLowestOffer",
		"GetCollectibleHighestOffer",
		"GetCollectibleLowestListing",
		"GetCollectibleHighestListing",
		"ListCollectibleListings",
		"ListCollectibleOffers",
		"GenerateBuyTransaction",
		"GenerateSellTransaction",
		"GenerateListingTransaction",
		"GenerateOfferTransaction",
		"GenerateCancelTransaction",
		"Execute",
		"ListCollectibles",
		"GetCountOfAllCollectibles",
		"GetCountOfFilteredCollectibles",
		"GetFloorOrder",
		"ListCollectiblesWithLowestListing",
		"ListCollectiblesWithHighestOffer",
		"SyncOrder",
		"SyncOrders",
		"GetOrders",
		"CheckoutOptionsMarketplace",
		"CheckoutOptionsSalesContract",
	},
}

//
// Server types
//

type Admin interface {
	CreateCollection(ctx context.Context, projectId uint64, contractAddress string) (*Collection, error)
	GetCollection(ctx context.Context, projectId uint64, contractAddress string) (*Collection, error)
	ListCollections(ctx context.Context, projectId uint64, page *Page) ([]*Collection, *Page, error)
	DeleteCollection(ctx context.Context, projectId uint64, contractAddress string) (*Collection, error)
	// determine what should happen here
	SyncCollection(ctx context.Context, projectId uint64, contractAddress string) (*Collection, error)
	CreateCurrency(ctx context.Context, currency *Currency) (*Currency, error)
	CreateCurrencies(ctx context.Context, currencies []*Currency) (map[string]*Currency, error)
	UpdateCurrency(ctx context.Context, currency *Currency) (*Currency, error)
	ListCurrencies(ctx context.Context) ([]*Currency, error)
	DeleteCurrency(ctx context.Context, chainId uint64, contractAddress string) (*Currency, error)
}

type Marketplace interface {
	ListCurrencies(ctx context.Context) ([]*Currency, error)
	GetCollectible(ctx context.Context, contractAddress string, tokenId string) (*TokenMetadata, error)
	GetLowestPriceOfferForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	GetHighestPriceOfferForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	GetLowestPriceListingForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	GetHighestPriceListingForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	ListListingsForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error)
	ListOffersForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error)
	GetCountOfListingsForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (uint64, error)
	GetCountOfOffersForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (uint64, error)
	// Deprecated:
	GetCollectibleLowestOffer(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	// Deprecated:
	GetCollectibleHighestOffer(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	// Deprecated:
	GetCollectibleLowestListing(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	// Deprecated:
	GetCollectibleHighestListing(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	// Deprecated:
	ListCollectibleListings(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error)
	// Deprecated:
	ListCollectibleOffers(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error)
	// checkout process
	GenerateBuyTransaction(ctx context.Context, collectionAddress string, buyer string, marketplace MarketplaceKind, ordersData []*OrderData, additionalFees []*AdditionalFee, walletType *WalletKind) ([]*Step, error)
	GenerateSellTransaction(ctx context.Context, collectionAddress string, seller string, marketplace MarketplaceKind, ordersData []*OrderData, additionalFees []*AdditionalFee, walletType *WalletKind) ([]*Step, error)
	GenerateListingTransaction(ctx context.Context, collectionAddress string, owner string, contractType ContractType, orderbook OrderbookKind, listing *CreateReq, walletType *WalletKind) ([]*Step, error)
	GenerateOfferTransaction(ctx context.Context, collectionAddress string, maker string, contractType ContractType, orderbook OrderbookKind, offer *CreateReq, walletType *WalletKind) ([]*Step, error)
	GenerateCancelTransaction(ctx context.Context, collectionAddress string, maker string, marketplace MarketplaceKind, orderId string) ([]*Step, error)
	// only used in a case of external transactions ( when we create off-chain transactions ) for instance opensea market
	Execute(ctx context.Context, signature string, executeType ExecuteType, body interface{}) (string, error)
	ListCollectibles(ctx context.Context, side OrderSide, contractAddress string, filter *CollectiblesFilter, page *Page) ([]*CollectibleOrder, *Page, error)
	GetCountOfAllCollectibles(ctx context.Context, contractAddress string) (uint64, error)
	GetCountOfFilteredCollectibles(ctx context.Context, side OrderSide, contractAddress string, filter *CollectiblesFilter) (uint64, error)
	GetFloorOrder(ctx context.Context, contractAddress string, filter *CollectiblesFilter) (*CollectibleOrder, error)
	// Deprecated:
	ListCollectiblesWithLowestListing(ctx context.Context, contractAddress string, filter *CollectiblesFilter, page *Page) ([]*CollectibleOrder, *Page, error)
	// Deprecated:
	ListCollectiblesWithHighestOffer(ctx context.Context, contractAddress string, filter *CollectiblesFilter, page *Page) ([]*CollectibleOrder, *Page, error)
	SyncOrder(ctx context.Context, order *Order) error
	SyncOrders(ctx context.Context, orders []*Order) error
	GetOrders(ctx context.Context, input []*GetOrdersInput, page *Page) ([]*Order, *Page, error)
	CheckoutOptionsMarketplace(ctx context.Context, wallet string, orders []*CheckoutOptionsMarketplaceOrder, additionalFee int) (*CheckoutOptions, error)
	CheckoutOptionsSalesContract(ctx context.Context, wallet string, contractAddress string, collectionAddress string, items []*CheckoutOptionsItem) (*CheckoutOptions, error)
}

//
// Client types
//

type AdminClient interface {
	CreateCollection(ctx context.Context, projectId uint64, contractAddress string) (*Collection, error)
	GetCollection(ctx context.Context, projectId uint64, contractAddress string) (*Collection, error)
	ListCollections(ctx context.Context, projectId uint64, page *Page) ([]*Collection, *Page, error)
	DeleteCollection(ctx context.Context, projectId uint64, contractAddress string) (*Collection, error)
	// determine what should happen here
	SyncCollection(ctx context.Context, projectId uint64, contractAddress string) (*Collection, error)
	CreateCurrency(ctx context.Context, currency *Currency) (*Currency, error)
	CreateCurrencies(ctx context.Context, currencies []*Currency) (map[string]*Currency, error)
	UpdateCurrency(ctx context.Context, currency *Currency) (*Currency, error)
	ListCurrencies(ctx context.Context) ([]*Currency, error)
	DeleteCurrency(ctx context.Context, chainId uint64, contractAddress string) (*Currency, error)
}

type MarketplaceClient interface {
	ListCurrencies(ctx context.Context) ([]*Currency, error)
	GetCollectible(ctx context.Context, contractAddress string, tokenId string) (*TokenMetadata, error)
	GetLowestPriceOfferForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	GetHighestPriceOfferForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	GetLowestPriceListingForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	GetHighestPriceListingForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	ListListingsForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error)
	ListOffersForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error)
	GetCountOfListingsForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (uint64, error)
	GetCountOfOffersForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (uint64, error)
	// Deprecated:
	GetCollectibleLowestOffer(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	// Deprecated:
	GetCollectibleHighestOffer(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	// Deprecated:
	GetCollectibleLowestListing(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	// Deprecated:
	GetCollectibleHighestListing(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	// Deprecated:
	ListCollectibleListings(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error)
	// Deprecated:
	ListCollectibleOffers(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error)
	// checkout process
	GenerateBuyTransaction(ctx context.Context, collectionAddress string, buyer string, marketplace MarketplaceKind, ordersData []*OrderData, additionalFees []*AdditionalFee, walletType *WalletKind) ([]*Step, error)
	GenerateSellTransaction(ctx context.Context, collectionAddress string, seller string, marketplace MarketplaceKind, ordersData []*OrderData, additionalFees []*AdditionalFee, walletType *WalletKind) ([]*Step, error)
	GenerateListingTransaction(ctx context.Context, collectionAddress string, owner string, contractType ContractType, orderbook OrderbookKind, listing *CreateReq, walletType *WalletKind) ([]*Step, error)
	GenerateOfferTransaction(ctx context.Context, collectionAddress string, maker string, contractType ContractType, orderbook OrderbookKind, offer *CreateReq, walletType *WalletKind) ([]*Step, error)
	GenerateCancelTransaction(ctx context.Context, collectionAddress string, maker string, marketplace MarketplaceKind, orderId string) ([]*Step, error)
	// only used in a case of external transactions ( when we create off-chain transactions ) for instance opensea market
	Execute(ctx context.Context, signature string, executeType ExecuteType, body interface{}) (string, error)
	ListCollectibles(ctx context.Context, side OrderSide, contractAddress string, filter *CollectiblesFilter, page *Page) ([]*CollectibleOrder, *Page, error)
	GetCountOfAllCollectibles(ctx context.Context, contractAddress string) (uint64, error)
	GetCountOfFilteredCollectibles(ctx context.Context, side OrderSide, contractAddress string, filter *CollectiblesFilter) (uint64, error)
	GetFloorOrder(ctx context.Context, contractAddress string, filter *CollectiblesFilter) (*CollectibleOrder, error)
	// Deprecated:
	ListCollectiblesWithLowestListing(ctx context.Context, contractAddress string, filter *CollectiblesFilter, page *Page) ([]*CollectibleOrder, *Page, error)
	// Deprecated:
	ListCollectiblesWithHighestOffer(ctx context.Context, contractAddress string, filter *CollectiblesFilter, page *Page) ([]*CollectibleOrder, *Page, error)
	SyncOrder(ctx context.Context, order *Order) error
	SyncOrders(ctx context.Context, orders []*Order) error
	GetOrders(ctx context.Context, input []*GetOrdersInput, page *Page) ([]*Order, *Page, error)
	CheckoutOptionsMarketplace(ctx context.Context, wallet string, orders []*CheckoutOptionsMarketplaceOrder, additionalFee int) (*CheckoutOptions, error)
	CheckoutOptionsSalesContract(ctx context.Context, wallet string, contractAddress string, collectionAddress string, items []*CheckoutOptionsItem) (*CheckoutOptions, error)
}

//
// Client
//

const AdminPathPrefix = "/rpc/Admin/"
const MarketplacePathPrefix = "/rpc/Marketplace/"

type adminClient struct {
	client HTTPClient
	urls   [10]string
}

func NewAdminClient(addr string, client HTTPClient) AdminClient {
	prefix := urlBase(addr) + AdminPathPrefix
	urls := [10]string{
		prefix + "CreateCollection",
		prefix + "GetCollection",
		prefix + "ListCollections",
		prefix + "DeleteCollection",
		prefix + "SyncCollection",
		prefix + "CreateCurrency",
		prefix + "CreateCurrencies",
		prefix + "UpdateCurrency",
		prefix + "ListCurrencies",
		prefix + "DeleteCurrency",
	}
	return &adminClient{
		client: client,
		urls:   urls,
	}
}

func (c *adminClient) CreateCollection(ctx context.Context, projectId uint64, contractAddress string) (*Collection, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 string `json:"contractAddress"`
	}{projectId, contractAddress}
	out := struct {
		Ret0 *Collection `json:"collection"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) GetCollection(ctx context.Context, projectId uint64, contractAddress string) (*Collection, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 string `json:"contractAddress"`
	}{projectId, contractAddress}
	out := struct {
		Ret0 *Collection `json:"collection"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) ListCollections(ctx context.Context, projectId uint64, page *Page) ([]*Collection, *Page, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 *Page  `json:"page"`
	}{projectId, page}
	out := struct {
		Ret0 []*Collection `json:"collections"`
		Ret1 *Page         `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *adminClient) DeleteCollection(ctx context.Context, projectId uint64, contractAddress string) (*Collection, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 string `json:"contractAddress"`
	}{projectId, contractAddress}
	out := struct {
		Ret0 *Collection `json:"collection"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) SyncCollection(ctx context.Context, projectId uint64, contractAddress string) (*Collection, error) {
	in := struct {
		Arg0 uint64 `json:"projectId"`
		Arg1 string `json:"contractAddress"`
	}{projectId, contractAddress}
	out := struct {
		Ret0 *Collection `json:"collection"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) CreateCurrency(ctx context.Context, currency *Currency) (*Currency, error) {
	in := struct {
		Arg0 *Currency `json:"currency"`
	}{currency}
	out := struct {
		Ret0 *Currency `json:"currency"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[5], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) CreateCurrencies(ctx context.Context, currencies []*Currency) (map[string]*Currency, error) {
	in := struct {
		Arg0 []*Currency `json:"currencies"`
	}{currencies}
	out := struct {
		Ret0 map[string]*Currency `json:"currency"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[6], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) UpdateCurrency(ctx context.Context, currency *Currency) (*Currency, error) {
	in := struct {
		Arg0 *Currency `json:"currency"`
	}{currency}
	out := struct {
		Ret0 *Currency `json:"currency"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[7], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) ListCurrencies(ctx context.Context) ([]*Currency, error) {
	out := struct {
		Ret0 []*Currency `json:"currencies"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[8], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) DeleteCurrency(ctx context.Context, chainId uint64, contractAddress string) (*Currency, error) {
	in := struct {
		Arg0 uint64 `json:"chainId"`
		Arg1 string `json:"contractAddress"`
	}{chainId, contractAddress}
	out := struct {
		Ret0 *Currency `json:"currency"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[9], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

type marketplaceClient struct {
	client HTTPClient
	urls   [33]string
}

func NewMarketplaceClient(addr string, client HTTPClient) MarketplaceClient {
	prefix := urlBase(addr) + MarketplacePathPrefix
	urls := [33]string{
		prefix + "ListCurrencies",
		prefix + "GetCollectible",
		prefix + "GetLowestPriceOfferForCollectible",
		prefix + "GetHighestPriceOfferForCollectible",
		prefix + "GetLowestPriceListingForCollectible",
		prefix + "GetHighestPriceListingForCollectible",
		prefix + "ListListingsForCollectible",
		prefix + "ListOffersForCollectible",
		prefix + "GetCountOfListingsForCollectible",
		prefix + "GetCountOfOffersForCollectible",
		prefix + "GetCollectibleLowestOffer",
		prefix + "GetCollectibleHighestOffer",
		prefix + "GetCollectibleLowestListing",
		prefix + "GetCollectibleHighestListing",
		prefix + "ListCollectibleListings",
		prefix + "ListCollectibleOffers",
		prefix + "GenerateBuyTransaction",
		prefix + "GenerateSellTransaction",
		prefix + "GenerateListingTransaction",
		prefix + "GenerateOfferTransaction",
		prefix + "GenerateCancelTransaction",
		prefix + "Execute",
		prefix + "ListCollectibles",
		prefix + "GetCountOfAllCollectibles",
		prefix + "GetCountOfFilteredCollectibles",
		prefix + "GetFloorOrder",
		prefix + "ListCollectiblesWithLowestListing",
		prefix + "ListCollectiblesWithHighestOffer",
		prefix + "SyncOrder",
		prefix + "SyncOrders",
		prefix + "GetOrders",
		prefix + "CheckoutOptionsMarketplace",
		prefix + "CheckoutOptionsSalesContract",
	}
	return &marketplaceClient{
		client: client,
		urls:   urls,
	}
}

func (c *marketplaceClient) ListCurrencies(ctx context.Context) ([]*Currency, error) {
	out := struct {
		Ret0 []*Currency `json:"currencies"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], nil, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCollectible(ctx context.Context, contractAddress string, tokenId string) (*TokenMetadata, error) {
	in := struct {
		Arg0 string `json:"contractAddress"`
		Arg1 string `json:"tokenId"`
	}{contractAddress, tokenId}
	out := struct {
		Ret0 *TokenMetadata `json:"metadata"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetLowestPriceOfferForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error) {
	in := struct {
		Arg0 string       `json:"contractAddress"`
		Arg1 string       `json:"tokenId"`
		Arg2 *OrderFilter `json:"filter"`
	}{contractAddress, tokenId, filter}
	out := struct {
		Ret0 *Order `json:"order"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetHighestPriceOfferForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error) {
	in := struct {
		Arg0 string       `json:"contractAddress"`
		Arg1 string       `json:"tokenId"`
		Arg2 *OrderFilter `json:"filter"`
	}{contractAddress, tokenId, filter}
	out := struct {
		Ret0 *Order `json:"order"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetLowestPriceListingForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error) {
	in := struct {
		Arg0 string       `json:"contractAddress"`
		Arg1 string       `json:"tokenId"`
		Arg2 *OrderFilter `json:"filter"`
	}{contractAddress, tokenId, filter}
	out := struct {
		Ret0 *Order `json:"order"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetHighestPriceListingForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error) {
	in := struct {
		Arg0 string       `json:"contractAddress"`
		Arg1 string       `json:"tokenId"`
		Arg2 *OrderFilter `json:"filter"`
	}{contractAddress, tokenId, filter}
	out := struct {
		Ret0 *Order `json:"order"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[5], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) ListListingsForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error) {
	in := struct {
		Arg0 string       `json:"contractAddress"`
		Arg1 string       `json:"tokenId"`
		Arg2 *OrderFilter `json:"filter"`
		Arg3 *Page        `json:"page"`
	}{contractAddress, tokenId, filter, page}
	out := struct {
		Ret0 []*Order `json:"listings"`
		Ret1 *Page    `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[6], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) ListOffersForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error) {
	in := struct {
		Arg0 string       `json:"contractAddress"`
		Arg1 string       `json:"tokenId"`
		Arg2 *OrderFilter `json:"filter"`
		Arg3 *Page        `json:"page"`
	}{contractAddress, tokenId, filter, page}
	out := struct {
		Ret0 []*Order `json:"offers"`
		Ret1 *Page    `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[7], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) GetCountOfListingsForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (uint64, error) {
	in := struct {
		Arg0 string       `json:"contractAddress"`
		Arg1 string       `json:"tokenId"`
		Arg2 *OrderFilter `json:"filter"`
	}{contractAddress, tokenId, filter}
	out := struct {
		Ret0 uint64 `json:"count"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[8], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCountOfOffersForCollectible(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (uint64, error) {
	in := struct {
		Arg0 string       `json:"contractAddress"`
		Arg1 string       `json:"tokenId"`
		Arg2 *OrderFilter `json:"filter"`
	}{contractAddress, tokenId, filter}
	out := struct {
		Ret0 uint64 `json:"count"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[9], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCollectibleLowestOffer(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error) {
	in := struct {
		Arg0 string       `json:"contractAddress"`
		Arg1 string       `json:"tokenId"`
		Arg2 *OrderFilter `json:"filter"`
	}{contractAddress, tokenId, filter}
	out := struct {
		Ret0 *Order `json:"order"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[10], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCollectibleHighestOffer(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error) {
	in := struct {
		Arg0 string       `json:"contractAddress"`
		Arg1 string       `json:"tokenId"`
		Arg2 *OrderFilter `json:"filter"`
	}{contractAddress, tokenId, filter}
	out := struct {
		Ret0 *Order `json:"order"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[11], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCollectibleLowestListing(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error) {
	in := struct {
		Arg0 string       `json:"contractAddress"`
		Arg1 string       `json:"tokenId"`
		Arg2 *OrderFilter `json:"filter"`
	}{contractAddress, tokenId, filter}
	out := struct {
		Ret0 *Order `json:"order"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[12], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCollectibleHighestListing(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error) {
	in := struct {
		Arg0 string       `json:"contractAddress"`
		Arg1 string       `json:"tokenId"`
		Arg2 *OrderFilter `json:"filter"`
	}{contractAddress, tokenId, filter}
	out := struct {
		Ret0 *Order `json:"order"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[13], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) ListCollectibleListings(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error) {
	in := struct {
		Arg0 string       `json:"contractAddress"`
		Arg1 string       `json:"tokenId"`
		Arg2 *OrderFilter `json:"filter"`
		Arg3 *Page        `json:"page"`
	}{contractAddress, tokenId, filter, page}
	out := struct {
		Ret0 []*Order `json:"listings"`
		Ret1 *Page    `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[14], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) ListCollectibleOffers(ctx context.Context, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error) {
	in := struct {
		Arg0 string       `json:"contractAddress"`
		Arg1 string       `json:"tokenId"`
		Arg2 *OrderFilter `json:"filter"`
		Arg3 *Page        `json:"page"`
	}{contractAddress, tokenId, filter, page}
	out := struct {
		Ret0 []*Order `json:"offers"`
		Ret1 *Page    `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[15], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) GenerateBuyTransaction(ctx context.Context, collectionAddress string, buyer string, marketplace MarketplaceKind, ordersData []*OrderData, additionalFees []*AdditionalFee, walletType *WalletKind) ([]*Step, error) {
	in := struct {
		Arg0 string           `json:"collectionAddress"`
		Arg1 string           `json:"buyer"`
		Arg2 MarketplaceKind  `json:"marketplace"`
		Arg3 []*OrderData     `json:"ordersData"`
		Arg4 []*AdditionalFee `json:"additionalFees"`
		Arg5 *WalletKind      `json:"walletType"`
	}{collectionAddress, buyer, marketplace, ordersData, additionalFees, walletType}
	out := struct {
		Ret0 []*Step `json:"steps"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[16], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GenerateSellTransaction(ctx context.Context, collectionAddress string, seller string, marketplace MarketplaceKind, ordersData []*OrderData, additionalFees []*AdditionalFee, walletType *WalletKind) ([]*Step, error) {
	in := struct {
		Arg0 string           `json:"collectionAddress"`
		Arg1 string           `json:"seller"`
		Arg2 MarketplaceKind  `json:"marketplace"`
		Arg3 []*OrderData     `json:"ordersData"`
		Arg4 []*AdditionalFee `json:"additionalFees"`
		Arg5 *WalletKind      `json:"walletType"`
	}{collectionAddress, seller, marketplace, ordersData, additionalFees, walletType}
	out := struct {
		Ret0 []*Step `json:"steps"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[17], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GenerateListingTransaction(ctx context.Context, collectionAddress string, owner string, contractType ContractType, orderbook OrderbookKind, listing *CreateReq, walletType *WalletKind) ([]*Step, error) {
	in := struct {
		Arg0 string        `json:"collectionAddress"`
		Arg1 string        `json:"owner"`
		Arg2 ContractType  `json:"contractType"`
		Arg3 OrderbookKind `json:"orderbook"`
		Arg4 *CreateReq    `json:"listing"`
		Arg5 *WalletKind   `json:"walletType"`
	}{collectionAddress, owner, contractType, orderbook, listing, walletType}
	out := struct {
		Ret0 []*Step `json:"steps"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[18], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GenerateOfferTransaction(ctx context.Context, collectionAddress string, maker string, contractType ContractType, orderbook OrderbookKind, offer *CreateReq, walletType *WalletKind) ([]*Step, error) {
	in := struct {
		Arg0 string        `json:"collectionAddress"`
		Arg1 string        `json:"maker"`
		Arg2 ContractType  `json:"contractType"`
		Arg3 OrderbookKind `json:"orderbook"`
		Arg4 *CreateReq    `json:"offer"`
		Arg5 *WalletKind   `json:"walletType"`
	}{collectionAddress, maker, contractType, orderbook, offer, walletType}
	out := struct {
		Ret0 []*Step `json:"steps"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[19], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GenerateCancelTransaction(ctx context.Context, collectionAddress string, maker string, marketplace MarketplaceKind, orderId string) ([]*Step, error) {
	in := struct {
		Arg0 string          `json:"collectionAddress"`
		Arg1 string          `json:"maker"`
		Arg2 MarketplaceKind `json:"marketplace"`
		Arg3 string          `json:"orderId"`
	}{collectionAddress, maker, marketplace, orderId}
	out := struct {
		Ret0 []*Step `json:"steps"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[20], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) Execute(ctx context.Context, signature string, executeType ExecuteType, body interface{}) (string, error) {
	in := struct {
		Arg0 string      `json:"signature"`
		Arg1 ExecuteType `json:"executeType"`
		Arg2 interface{} `json:"body"`
	}{signature, executeType, body}
	out := struct {
		Ret0 string `json:"orderId"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[21], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) ListCollectibles(ctx context.Context, side OrderSide, contractAddress string, filter *CollectiblesFilter, page *Page) ([]*CollectibleOrder, *Page, error) {
	in := struct {
		Arg0 OrderSide           `json:"side"`
		Arg1 string              `json:"contractAddress"`
		Arg2 *CollectiblesFilter `json:"filter"`
		Arg3 *Page               `json:"page"`
	}{side, contractAddress, filter, page}
	out := struct {
		Ret0 []*CollectibleOrder `json:"collectibles"`
		Ret1 *Page               `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[22], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) GetCountOfAllCollectibles(ctx context.Context, contractAddress string) (uint64, error) {
	in := struct {
		Arg0 string `json:"contractAddress"`
	}{contractAddress}
	out := struct {
		Ret0 uint64 `json:"count"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[23], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCountOfFilteredCollectibles(ctx context.Context, side OrderSide, contractAddress string, filter *CollectiblesFilter) (uint64, error) {
	in := struct {
		Arg0 OrderSide           `json:"side"`
		Arg1 string              `json:"contractAddress"`
		Arg2 *CollectiblesFilter `json:"filter"`
	}{side, contractAddress, filter}
	out := struct {
		Ret0 uint64 `json:"count"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[24], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetFloorOrder(ctx context.Context, contractAddress string, filter *CollectiblesFilter) (*CollectibleOrder, error) {
	in := struct {
		Arg0 string              `json:"contractAddress"`
		Arg1 *CollectiblesFilter `json:"filter"`
	}{contractAddress, filter}
	out := struct {
		Ret0 *CollectibleOrder `json:"collectible"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[25], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) ListCollectiblesWithLowestListing(ctx context.Context, contractAddress string, filter *CollectiblesFilter, page *Page) ([]*CollectibleOrder, *Page, error) {
	in := struct {
		Arg0 string              `json:"contractAddress"`
		Arg1 *CollectiblesFilter `json:"filter"`
		Arg2 *Page               `json:"page"`
	}{contractAddress, filter, page}
	out := struct {
		Ret0 []*CollectibleOrder `json:"collectibles"`
		Ret1 *Page               `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[26], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) ListCollectiblesWithHighestOffer(ctx context.Context, contractAddress string, filter *CollectiblesFilter, page *Page) ([]*CollectibleOrder, *Page, error) {
	in := struct {
		Arg0 string              `json:"contractAddress"`
		Arg1 *CollectiblesFilter `json:"filter"`
		Arg2 *Page               `json:"page"`
	}{contractAddress, filter, page}
	out := struct {
		Ret0 []*CollectibleOrder `json:"collectibles"`
		Ret1 *Page               `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[27], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) SyncOrder(ctx context.Context, order *Order) error {
	in := struct {
		Arg0 *Order `json:"order"`
	}{order}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[28], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return err
}

func (c *marketplaceClient) SyncOrders(ctx context.Context, orders []*Order) error {
	in := struct {
		Arg0 []*Order `json:"orders"`
	}{orders}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[29], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return err
}

func (c *marketplaceClient) GetOrders(ctx context.Context, input []*GetOrdersInput, page *Page) ([]*Order, *Page, error) {
	in := struct {
		Arg0 []*GetOrdersInput `json:"input"`
		Arg1 *Page             `json:"page"`
	}{input, page}
	out := struct {
		Ret0 []*Order `json:"orders"`
		Ret1 *Page    `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[30], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) CheckoutOptionsMarketplace(ctx context.Context, wallet string, orders []*CheckoutOptionsMarketplaceOrder, additionalFee int) (*CheckoutOptions, error) {
	in := struct {
		Arg0 string                             `json:"wallet"`
		Arg1 []*CheckoutOptionsMarketplaceOrder `json:"orders"`
		Arg2 int                                `json:"additionalFee"`
	}{wallet, orders, additionalFee}
	out := struct {
		Ret0 *CheckoutOptions `json:"options"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[31], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) CheckoutOptionsSalesContract(ctx context.Context, wallet string, contractAddress string, collectionAddress string, items []*CheckoutOptionsItem) (*CheckoutOptions, error) {
	in := struct {
		Arg0 string                 `json:"wallet"`
		Arg1 string                 `json:"contractAddress"`
		Arg2 string                 `json:"collectionAddress"`
		Arg3 []*CheckoutOptionsItem `json:"items"`
	}{wallet, contractAddress, collectionAddress, items}
	out := struct {
		Ret0 *CheckoutOptions `json:"options"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[32], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// urlBase helps ensure that addr specifies a scheme. If it is unparsable
// as a URL, it returns addr unchanged.
func urlBase(addr string) string {
	// If the addr specifies a scheme, use it. If not, default to
	// http. If url.Parse fails on it, return it unchanged.
	url, err := url.Parse(addr)
	if err != nil {
		return addr
	}
	if url.Scheme == "" {
		url.Scheme = "http"
	}
	return url.String()
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) {
	req, err := http.NewRequestWithContext(ctx, "POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", contentType)
	req.Header.Set("Content-Type", contentType)
	req.Header.Set(WebrpcHeader, WebrpcHeaderValue)
	if headers, ok := HTTPRequestHeaders(ctx); ok {
		for k := range headers {
			for _, v := range headers[k] {
				req.Header.Add(k, v)
			}
		}
	}
	return req, nil
}

// doHTTPRequest is common code to make a request to the remote service.
func doHTTPRequest(ctx context.Context, client HTTPClient, url string, in, out interface{}) (*http.Response, error) {
	reqBody, err := json.Marshal(in)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("failed to marshal JSON body: %w", err)
	}
	if err = ctx.Err(); err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("aborted because context was done: %w", err)
	}

	req, err := newRequest(ctx, url, bytes.NewBuffer(reqBody), "application/json")
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("could not build request: %w", err)
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(err)
	}

	if resp.StatusCode != 200 {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to read server error response body: %w", err)
		}

		var rpcErr WebRPCError
		if err := json.Unmarshal(respBody, &rpcErr); err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to unmarshal server error: %w", err)
		}
		if rpcErr.Cause != "" {
			rpcErr.cause = errors.New(rpcErr.Cause)
		}
		return nil, rpcErr
	}

	if out != nil {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to read response body: %w", err)
		}

		err = json.Unmarshal(respBody, &out)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to unmarshal JSON response body: %w", err)
		}
	}

	return resp, nil
}

func WithHTTPRequestHeaders(ctx context.Context, h http.Header) (context.Context, error) {
	if _, ok := h["Accept"]; ok {
		return nil, errors.New("provided header cannot set Accept")
	}
	if _, ok := h["Content-Type"]; ok {
		return nil, errors.New("provided header cannot set Content-Type")
	}

	copied := make(http.Header, len(h))
	for k, vv := range h {
		if vv == nil {
			copied[k] = nil
			continue
		}
		copied[k] = make([]string, len(vv))
		copy(copied[k], vv)
	}

	return context.WithValue(ctx, HTTPClientRequestHeadersCtxKey, copied), nil
}

func HTTPRequestHeaders(ctx context.Context) (http.Header, bool) {
	h, ok := ctx.Value(HTTPClientRequestHeadersCtxKey).(http.Header)
	return h, ok
}

//
// Helpers
//

type method struct {
	Name        string
	Service     string
	Annotations map[string]string
}

type contextKey struct {
	name string
}

func (k *contextKey) String() string {
	return "webrpc context value " + k.name
}

var (
	HTTPClientRequestHeadersCtxKey = &contextKey{"HTTPClientRequestHeaders"}
	HTTPRequestCtxKey              = &contextKey{"HTTPRequest"}

	ServiceNameCtxKey = &contextKey{"ServiceName"}

	MethodNameCtxKey = &contextKey{"MethodName"}
)

func ServiceNameFromContext(ctx context.Context) string {
	service, _ := ctx.Value(ServiceNameCtxKey).(string)
	return service
}

func MethodNameFromContext(ctx context.Context) string {
	method, _ := ctx.Value(MethodNameCtxKey).(string)
	return method
}

func RequestFromContext(ctx context.Context) *http.Request {
	r, _ := ctx.Value(HTTPRequestCtxKey).(*http.Request)
	return r
}

func MethodCtx(ctx context.Context) (method, bool) {
	req := RequestFromContext(ctx)
	if req == nil {
		return method{}, false
	}

	m, ok := methods[req.URL.Path]
	if !ok {
		return method{}, false
	}

	return m, true
}

//
// Errors
//

type WebRPCError struct {
	Name       string `json:"error"`
	Code       int    `json:"code"`
	Message    string `json:"msg"`
	Cause      string `json:"cause,omitempty"`
	HTTPStatus int    `json:"status"`
	cause      error
}

var _ error = WebRPCError{}

func (e WebRPCError) Error() string {
	if e.cause != nil {
		return fmt.Sprintf("%s %d: %s: %v", e.Name, e.Code, e.Message, e.cause)
	}
	return fmt.Sprintf("%s %d: %s", e.Name, e.Code, e.Message)
}

func (e WebRPCError) Is(target error) bool {
	if target == nil {
		return false
	}
	if rpcErr, ok := target.(WebRPCError); ok {
		return rpcErr.Code == e.Code
	}
	return errors.Is(e.cause, target)
}

func (e WebRPCError) Unwrap() error {
	return e.cause
}

func (e WebRPCError) WithCause(cause error) WebRPCError {
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

func (e WebRPCError) WithCausef(format string, args ...interface{}) WebRPCError {
	cause := fmt.Errorf(format, args...)
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

// Deprecated: Use .WithCause() method on WebRPCError.
func ErrorWithCause(rpcErr WebRPCError, cause error) WebRPCError {
	return rpcErr.WithCause(cause)
}

// Webrpc errors
var (
	ErrWebrpcEndpoint           = WebRPCError{Code: 0, Name: "WebrpcEndpoint", Message: "endpoint error", HTTPStatus: 400}
	ErrWebrpcRequestFailed      = WebRPCError{Code: -1, Name: "WebrpcRequestFailed", Message: "request failed", HTTPStatus: 400}
	ErrWebrpcBadRoute           = WebRPCError{Code: -2, Name: "WebrpcBadRoute", Message: "bad route", HTTPStatus: 404}
	ErrWebrpcBadMethod          = WebRPCError{Code: -3, Name: "WebrpcBadMethod", Message: "bad method", HTTPStatus: 405}
	ErrWebrpcBadRequest         = WebRPCError{Code: -4, Name: "WebrpcBadRequest", Message: "bad request", HTTPStatus: 400}
	ErrWebrpcBadResponse        = WebRPCError{Code: -5, Name: "WebrpcBadResponse", Message: "bad response", HTTPStatus: 500}
	ErrWebrpcServerPanic        = WebRPCError{Code: -6, Name: "WebrpcServerPanic", Message: "server panic", HTTPStatus: 500}
	ErrWebrpcInternalError      = WebRPCError{Code: -7, Name: "WebrpcInternalError", Message: "internal error", HTTPStatus: 500}
	ErrWebrpcClientDisconnected = WebRPCError{Code: -8, Name: "WebrpcClientDisconnected", Message: "client disconnected", HTTPStatus: 400}
	ErrWebrpcStreamLost         = WebRPCError{Code: -9, Name: "WebrpcStreamLost", Message: "stream lost", HTTPStatus: 400}
	ErrWebrpcStreamFinished     = WebRPCError{Code: -10, Name: "WebrpcStreamFinished", Message: "stream finished", HTTPStatus: 200}
)

// Schema errors
var (
	ErrUnauthorized        = WebRPCError{Code: 1000, Name: "Unauthorized", Message: "Unauthorized access", HTTPStatus: 401}
	ErrPermissionDenied    = WebRPCError{Code: 1001, Name: "PermissionDenied", Message: "Permission denied", HTTPStatus: 403}
	ErrSessionExpired      = WebRPCError{Code: 1002, Name: "SessionExpired", Message: "Session expired", HTTPStatus: 403}
	ErrMethodNotFound      = WebRPCError{Code: 1003, Name: "MethodNotFound", Message: "Method not found", HTTPStatus: 404}
	ErrTimeout             = WebRPCError{Code: 2000, Name: "Timeout", Message: "Request timed out", HTTPStatus: 408}
	ErrInvalidArgument     = WebRPCError{Code: 2001, Name: "InvalidArgument", Message: "Invalid argument", HTTPStatus: 400}
	ErrNotFound            = WebRPCError{Code: 3000, Name: "NotFound", Message: "Resource not found", HTTPStatus: 400}
	ErrUserNotFound        = WebRPCError{Code: 3001, Name: "UserNotFound", Message: "User not found", HTTPStatus: 400}
	ErrProjectNotFound     = WebRPCError{Code: 3002, Name: "ProjectNotFound", Message: "Project not found", HTTPStatus: 400}
	ErrInvalidTier         = WebRPCError{Code: 3003, Name: "InvalidTier", Message: "Invalid subscription tier", HTTPStatus: 400}
	ErrProjectLimitReached = WebRPCError{Code: 3005, Name: "ProjectLimitReached", Message: "Project limit reached", HTTPStatus: 402}
	ErrNotImplemented      = WebRPCError{Code: 9999, Name: "NotImplemented", Message: "Not Implemented", HTTPStatus: 500}
)
