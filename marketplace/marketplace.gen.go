// marketplace-api v0-25.10.27+02ad2e0 908833ff8851f89b289b19b1486a54a1fd7dadd3
// --
// Code generated by webrpc-gen@v0.31.1 with golang generator. DO NOT EDIT.
//
// webrpc-gen -schema=./schema/schema.ridl -target=golang -pkg=marketplace -client -out=./clients/marketplace.gen.go
package marketplace

import (
	"bytes"
	"context"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"math/big"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/0xsequence/go-sequence/lib/prototyp"
)

// WebRPC description and code-gen version
func WebRPCVersion() string {
	return "v1"
}

// Schema version of your RIDL schema
func WebRPCSchemaVersion() string {
	return "v0-25.10.27+02ad2e0"
}

// Schema hash generated from your RIDL schema
func WebRPCSchemaHash() string {
	return "908833ff8851f89b289b19b1486a54a1fd7dadd3"
}

//
// Client interface
//

type AdminClient interface {
	CreateCollection(ctx context.Context, chainId string, projectId uint64, contractAddress string) (*Collection, error)
	GetCollection(ctx context.Context, chainId string, projectId uint64, contractAddress string) (*Collection, error)
	UpdateCollection(ctx context.Context, chainId string, collection *Collection) (*Collection, error)
	ListCollections(ctx context.Context, chainId string, projectId uint64, page *Page) ([]*Collection, *Page, error)
	DeleteCollection(ctx context.Context, chainId string, projectId uint64, contractAddress string) (*Collection, error)
	// determine what should happen here
	SyncCollection(ctx context.Context, chainId string, contractAddress string) error
	CreatePrimarySaleContract(ctx context.Context, chainId string, projectId uint64, primarySaleContractAddress string, itemsContractAddress string) (*PrimarySaleContract, error)
	DeletePrimarySaleContract(ctx context.Context, chainId string, projectId uint64, primarySaleContractAddress string) error
	CreateCurrency(ctx context.Context, chainId string, currency *Currency) (*Currency, error)
	CreateCurrencies(ctx context.Context, chainId string, currencies []*Currency) (map[string]*Currency, error)
	UpdateCurrency(ctx context.Context, chainId string, currency *Currency) (*Currency, error)
	ListCurrencies(ctx context.Context, chainId string) ([]*Currency, error)
	DeleteCurrency(ctx context.Context, chainId string, contractAddress string) (*Currency, error)
	// This for manual adding of non minted ERC1155 tokens, it's used for purposes of Shop.
	AddCollectibles(ctx context.Context, chainId string, itemsContractAddress string, tokenIds []string) error
}

type MarketplaceClient interface {
	ListCurrencies(ctx context.Context, chainId string) ([]*Currency, error)
	GetCollectionDetail(ctx context.Context, chainId string, contractAddress string) (*Collection, error)
	GetCollectionActiveListingsCurrencies(ctx context.Context, chainId string, contractAddress string) ([]*Currency, error)
	GetCollectionActiveOffersCurrencies(ctx context.Context, chainId string, contractAddress string) ([]*Currency, error)
	GetCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string) (*TokenMetadata, error)
	GetLowestPriceOfferForCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	GetHighestPriceOfferForCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	GetLowestPriceListingForCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	GetHighestPriceListingForCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	ListListingsForCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error)
	ListOffersForCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error)
	ListOrdersWithCollectibles(ctx context.Context, chainId string, side OrderSide, contractAddress string, filter *OrdersFilter, page *Page) ([]*CollectibleOrder, *Page, error)
	GetCountOfAllOrders(ctx context.Context, chainId string, side OrderSide, contractAddress string) (uint64, error)
	GetCountOfFilteredOrders(ctx context.Context, chainId string, side OrderSide, contractAddress string, filter *OrdersFilter) (uint64, error)
	ListListings(ctx context.Context, chainId string, contractAddress string, filter *OrderFilter, page *Page) ([]*Order, *Page, error)
	ListOffers(ctx context.Context, chainId string, contractAddress string, filter *OrderFilter, page *Page) ([]*Order, *Page, error)
	GetCountOfListingsForCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (uint64, error)
	GetCountOfOffersForCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (uint64, error)
	// Deprecated: Please use GetLowestPriceOfferForCollectible instead.
	GetCollectibleLowestOffer(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	// Deprecated: Please use GetHighestPriceOfferForCollectible instead.
	GetCollectibleHighestOffer(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	// Deprecated: Please use GetLowestPriceListingForCollectible instead.
	GetCollectibleLowestListing(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	// Deprecated: Please use GetHighestPriceListingForCollectible instead.
	GetCollectibleHighestListing(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error)
	// Deprecated: Please use ListListingsForCollectible instead.
	ListCollectibleListings(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error)
	// Deprecated: Please use ListOffersForCollectible instead.
	ListCollectibleOffers(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error)
	// checkout process
	GenerateBuyTransaction(ctx context.Context, chainId string, collectionAddress string, buyer string, marketplace MarketplaceKind, ordersData []*OrderData, additionalFees []*AdditionalFee, walletType *WalletKind) ([]*Step, error)
	GenerateSellTransaction(ctx context.Context, chainId string, collectionAddress string, seller string, marketplace MarketplaceKind, ordersData []*OrderData, additionalFees []*AdditionalFee, walletType *WalletKind) ([]*Step, error)
	GenerateListingTransaction(ctx context.Context, chainId string, collectionAddress string, owner string, contractType ContractType, orderbook OrderbookKind, listing *CreateReq, additionalFees []*AdditionalFee, walletType *WalletKind) ([]*Step, error)
	GenerateOfferTransaction(ctx context.Context, chainId string, collectionAddress string, maker string, contractType ContractType, orderbook OrderbookKind, offer *CreateReq, additionalFees []*AdditionalFee, walletType *WalletKind, offerType OfferType) ([]*Step, error)
	GenerateCancelTransaction(ctx context.Context, chainId string, collectionAddress string, maker string, marketplace MarketplaceKind, orderId string) ([]*Step, error)
	// only used in a case of external transactions ( when we create off-chain transactions ) for instance opensea market, use only ExecuteInput params and leave other root inputs empty, they are depracated and kept only for backward compatibility
	Execute(ctx context.Context, params *ExecuteInput, chainId *string, signature *string, method *string, endpoint *string, executeType *ExecuteType, body *interface{}) (string, error)
	// list of collectibles with best order for each collectible, by default this only returns collectibles with an order
	ListCollectibles(ctx context.Context, chainId string, side OrderSide, contractAddress string, filter *CollectiblesFilter, page *Page) ([]*CollectibleOrder, *Page, error)
	GetCountOfAllCollectibles(ctx context.Context, chainId string, contractAddress string) (uint64, error)
	GetCountOfFilteredCollectibles(ctx context.Context, chainId string, side OrderSide, contractAddress string, filter *CollectiblesFilter) (uint64, error)
	GetFloorOrder(ctx context.Context, chainId string, contractAddress string, filter *CollectiblesFilter) (*CollectibleOrder, error)
	ListCollectionActivities(ctx context.Context, chainId string, contractAddress string, page *Page) ([]*Activity, *Page, error)
	ListCollectibleActivities(ctx context.Context, chainId string, contractAddress string, tokenId string, page *Page) ([]*Activity, *Page, error)
	ListCollectiblesWithLowestListing(ctx context.Context, chainId string, contractAddress string, filter *CollectiblesFilter, page *Page) ([]*CollectibleOrder, *Page, error)
	ListCollectiblesWithHighestOffer(ctx context.Context, chainId string, contractAddress string, filter *CollectiblesFilter, page *Page) ([]*CollectibleOrder, *Page, error)
	SyncOrder(ctx context.Context, chainId string, order *Order) error
	SyncOrders(ctx context.Context, chainId string, orders []*Order) error
	GetOrders(ctx context.Context, chainId string, input []*GetOrdersInput, page *Page) ([]*Order, *Page, error)
	CheckoutOptionsMarketplace(ctx context.Context, chainId string, wallet string, orders []*CheckoutOptionsMarketplaceOrder, additionalFee int) (*CheckoutOptions, error)
	CheckoutOptionsSalesContract(ctx context.Context, chainId string, wallet string, contractAddress string, collectionAddress string, items []*CheckoutOptionsItem) (*CheckoutOptions, error)
	SupportedMarketplaces(ctx context.Context, chainId string) ([]MarketplaceKind, error)
	GetPrimarySaleItem(ctx context.Context, chainId string, primarySaleContractAddress string, tokenId string) (*CollectiblePrimarySaleItem, error)
	ListPrimarySaleItems(ctx context.Context, chainId string, primarySaleContractAddress string, filter *PrimarySaleItemsFilter, page *Page) ([]*CollectiblePrimarySaleItem, *Page, error)
	GetCountOfPrimarySaleItems(ctx context.Context, chainId string, primarySaleContractAddress string, filter *PrimarySaleItemsFilter) (uint64, error)
}

//
// Schema types
//

type SortOrder uint32

const (
	SortOrder_ASC  SortOrder = 0
	SortOrder_DESC SortOrder = 1
)

var SortOrder_name = map[uint32]string{
	0: "ASC",
	1: "DESC",
}

var SortOrder_value = map[string]uint32{
	"ASC":  0,
	"DESC": 1,
}

func (x SortOrder) String() string {
	return SortOrder_name[uint32(x)]
}

func (x SortOrder) MarshalText() ([]byte, error) {
	return []byte(SortOrder_name[uint32(x)]), nil
}

func (x *SortOrder) UnmarshalText(b []byte) error {
	*x = SortOrder(SortOrder_value[string(b)])
	return nil
}

func (x *SortOrder) Is(values ...SortOrder) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type PropertyType uint32

const (
	PropertyType_INT     PropertyType = 0
	PropertyType_STRING  PropertyType = 1
	PropertyType_ARRAY   PropertyType = 2
	PropertyType_GENERIC PropertyType = 3
)

var PropertyType_name = map[uint32]string{
	0: "INT",
	1: "STRING",
	2: "ARRAY",
	3: "GENERIC",
}

var PropertyType_value = map[string]uint32{
	"INT":     0,
	"STRING":  1,
	"ARRAY":   2,
	"GENERIC": 3,
}

func (x PropertyType) String() string {
	return PropertyType_name[uint32(x)]
}

func (x PropertyType) MarshalText() ([]byte, error) {
	return []byte(PropertyType_name[uint32(x)]), nil
}

func (x *PropertyType) UnmarshalText(b []byte) error {
	*x = PropertyType(PropertyType_value[string(b)])
	return nil
}

func (x *PropertyType) Is(values ...PropertyType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type MarketplaceKind uint8

const (
	MarketplaceKind_unknown                 MarketplaceKind = 0
	MarketplaceKind_sequence_marketplace_v1 MarketplaceKind = 1
	MarketplaceKind_sequence_marketplace_v2 MarketplaceKind = 2
	MarketplaceKind_blur                    MarketplaceKind = 3
	MarketplaceKind_zerox                   MarketplaceKind = 4
	MarketplaceKind_opensea                 MarketplaceKind = 5
	MarketplaceKind_looks_rare              MarketplaceKind = 6
	MarketplaceKind_x2y2                    MarketplaceKind = 7
	MarketplaceKind_alienswap               MarketplaceKind = 8
	MarketplaceKind_payment_processor       MarketplaceKind = 9
	MarketplaceKind_mintify                 MarketplaceKind = 10
	MarketplaceKind_magic_eden              MarketplaceKind = 11
)

var MarketplaceKind_name = map[uint8]string{
	0:  "unknown",
	1:  "sequence_marketplace_v1",
	2:  "sequence_marketplace_v2",
	3:  "blur",
	4:  "zerox",
	5:  "opensea",
	6:  "looks_rare",
	7:  "x2y2",
	8:  "alienswap",
	9:  "payment_processor",
	10: "mintify",
	11: "magic_eden",
}

var MarketplaceKind_value = map[string]uint8{
	"unknown":                 0,
	"sequence_marketplace_v1": 1,
	"sequence_marketplace_v2": 2,
	"blur":                    3,
	"zerox":                   4,
	"opensea":                 5,
	"looks_rare":              6,
	"x2y2":                    7,
	"alienswap":               8,
	"payment_processor":       9,
	"mintify":                 10,
	"magic_eden":              11,
}

func (x MarketplaceKind) String() string {
	return MarketplaceKind_name[uint8(x)]
}

func (x MarketplaceKind) MarshalText() ([]byte, error) {
	return []byte(MarketplaceKind_name[uint8(x)]), nil
}

func (x *MarketplaceKind) UnmarshalText(b []byte) error {
	*x = MarketplaceKind(MarketplaceKind_value[string(b)])
	return nil
}

func (x *MarketplaceKind) Is(values ...MarketplaceKind) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type OrderbookKind uint32

const (
	OrderbookKind_unknown                 OrderbookKind = 0
	OrderbookKind_sequence_marketplace_v1 OrderbookKind = 1
	OrderbookKind_sequence_marketplace_v2 OrderbookKind = 2
	OrderbookKind_blur                    OrderbookKind = 3
	OrderbookKind_opensea                 OrderbookKind = 4
	OrderbookKind_looks_rare              OrderbookKind = 5
	OrderbookKind_reservoir               OrderbookKind = 6
	OrderbookKind_x2y2                    OrderbookKind = 7
	OrderbookKind_magic_eden              OrderbookKind = 8
)

var OrderbookKind_name = map[uint32]string{
	0: "unknown",
	1: "sequence_marketplace_v1",
	2: "sequence_marketplace_v2",
	3: "blur",
	4: "opensea",
	5: "looks_rare",
	6: "reservoir",
	7: "x2y2",
	8: "magic_eden",
}

var OrderbookKind_value = map[string]uint32{
	"unknown":                 0,
	"sequence_marketplace_v1": 1,
	"sequence_marketplace_v2": 2,
	"blur":                    3,
	"opensea":                 4,
	"looks_rare":              5,
	"reservoir":               6,
	"x2y2":                    7,
	"magic_eden":              8,
}

func (x OrderbookKind) String() string {
	return OrderbookKind_name[uint32(x)]
}

func (x OrderbookKind) MarshalText() ([]byte, error) {
	return []byte(OrderbookKind_name[uint32(x)]), nil
}

func (x *OrderbookKind) UnmarshalText(b []byte) error {
	*x = OrderbookKind(OrderbookKind_value[string(b)])
	return nil
}

func (x *OrderbookKind) Is(values ...OrderbookKind) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type SourceKind uint32

const (
	SourceKind_unknown                 SourceKind = 0
	SourceKind_external                SourceKind = 1
	SourceKind_sequence_marketplace_v1 SourceKind = 2
	SourceKind_sequence_marketplace_v2 SourceKind = 3
	SourceKind_opensea                 SourceKind = 4
	SourceKind_magic_eden              SourceKind = 5
)

var SourceKind_name = map[uint32]string{
	0: "unknown",
	1: "external",
	2: "sequence_marketplace_v1",
	3: "sequence_marketplace_v2",
	4: "opensea",
	5: "magic_eden",
}

var SourceKind_value = map[string]uint32{
	"unknown":                 0,
	"external":                1,
	"sequence_marketplace_v1": 2,
	"sequence_marketplace_v2": 3,
	"opensea":                 4,
	"magic_eden":              5,
}

func (x SourceKind) String() string {
	return SourceKind_name[uint32(x)]
}

func (x SourceKind) MarshalText() ([]byte, error) {
	return []byte(SourceKind_name[uint32(x)]), nil
}

func (x *SourceKind) UnmarshalText(b []byte) error {
	*x = SourceKind(SourceKind_value[string(b)])
	return nil
}

func (x *SourceKind) Is(values ...SourceKind) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type OrderSide uint8

const (
	OrderSide_unknown OrderSide = 0
	// Ask
	OrderSide_listing OrderSide = 1
	// Bid
	OrderSide_offer OrderSide = 2
)

var OrderSide_name = map[uint8]string{
	0: "unknown",
	1: "listing",
	2: "offer",
}

var OrderSide_value = map[string]uint8{
	"unknown": 0,
	"listing": 1,
	"offer":   2,
}

func (x OrderSide) String() string {
	return OrderSide_name[uint8(x)]
}

func (x OrderSide) MarshalText() ([]byte, error) {
	return []byte(OrderSide_name[uint8(x)]), nil
}

func (x *OrderSide) UnmarshalText(b []byte) error {
	*x = OrderSide(OrderSide_value[string(b)])
	return nil
}

func (x *OrderSide) Is(values ...OrderSide) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type OfferType uint8

const (
	OfferType_unknown    OfferType = 0
	OfferType_item       OfferType = 1
	OfferType_collection OfferType = 2
)

var OfferType_name = map[uint8]string{
	0: "unknown",
	1: "item",
	2: "collection",
}

var OfferType_value = map[string]uint8{
	"unknown":    0,
	"item":       1,
	"collection": 2,
}

func (x OfferType) String() string {
	return OfferType_name[uint8(x)]
}

func (x OfferType) MarshalText() ([]byte, error) {
	return []byte(OfferType_name[uint8(x)]), nil
}

func (x *OfferType) UnmarshalText(b []byte) error {
	*x = OfferType(OfferType_value[string(b)])
	return nil
}

func (x *OfferType) Is(values ...OfferType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type OrderStatus uint8

const (
	OrderStatus_unknown OrderStatus = 0
	// Fillable
	OrderStatus_active OrderStatus = 1
	// Temporarily unfillable, due to balance / approval
	OrderStatus_inactive OrderStatus = 2
	// Permanently unfillable, due to expiry
	OrderStatus_expired OrderStatus = 3
	// Permanently unfillable, due to cancellation (by user or protocol)
	OrderStatus_cancelled OrderStatus = 4
	// Permanently unfillable, because it's been completely filled
	OrderStatus_filled OrderStatus = 5
	// Decimals are missing on collectible needs to be synced and order updated
	OrderStatus_decimals_missing OrderStatus = 6
)

var OrderStatus_name = map[uint8]string{
	0: "unknown",
	1: "active",
	2: "inactive",
	3: "expired",
	4: "cancelled",
	5: "filled",
	6: "decimals_missing",
}

var OrderStatus_value = map[string]uint8{
	"unknown":          0,
	"active":           1,
	"inactive":         2,
	"expired":          3,
	"cancelled":        4,
	"filled":           5,
	"decimals_missing": 6,
}

func (x OrderStatus) String() string {
	return OrderStatus_name[uint8(x)]
}

func (x OrderStatus) MarshalText() ([]byte, error) {
	return []byte(OrderStatus_name[uint8(x)]), nil
}

func (x *OrderStatus) UnmarshalText(b []byte) error {
	*x = OrderStatus(OrderStatus_value[string(b)])
	return nil
}

func (x *OrderStatus) Is(values ...OrderStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type ContractType uint16

const (
	ContractType_UNKNOWN ContractType = 0
	ContractType_ERC20   ContractType = 1
	ContractType_ERC721  ContractType = 2
	ContractType_ERC1155 ContractType = 3
)

var ContractType_name = map[uint16]string{
	0: "UNKNOWN",
	1: "ERC20",
	2: "ERC721",
	3: "ERC1155",
}

var ContractType_value = map[string]uint16{
	"UNKNOWN": 0,
	"ERC20":   1,
	"ERC721":  2,
	"ERC1155": 3,
}

func (x ContractType) String() string {
	return ContractType_name[uint16(x)]
}

func (x ContractType) MarshalText() ([]byte, error) {
	return []byte(ContractType_name[uint16(x)]), nil
}

func (x *ContractType) UnmarshalText(b []byte) error {
	*x = ContractType(ContractType_value[string(b)])
	return nil
}

func (x *ContractType) Is(values ...ContractType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type CollectionPriority uint8

const (
	CollectionPriority_unknown CollectionPriority = 0
	CollectionPriority_low     CollectionPriority = 1
	CollectionPriority_normal  CollectionPriority = 2
	CollectionPriority_high    CollectionPriority = 3
)

var CollectionPriority_name = map[uint8]string{
	0: "unknown",
	1: "low",
	2: "normal",
	3: "high",
}

var CollectionPriority_value = map[string]uint8{
	"unknown": 0,
	"low":     1,
	"normal":  2,
	"high":    3,
}

func (x CollectionPriority) String() string {
	return CollectionPriority_name[uint8(x)]
}

func (x CollectionPriority) MarshalText() ([]byte, error) {
	return []byte(CollectionPriority_name[uint8(x)]), nil
}

func (x *CollectionPriority) UnmarshalText(b []byte) error {
	*x = CollectionPriority(CollectionPriority_value[string(b)])
	return nil
}

func (x *CollectionPriority) Is(values ...CollectionPriority) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type CollectionStatus uint8

const (
	CollectionStatus_unknown           CollectionStatus = 0
	CollectionStatus_created           CollectionStatus = 1
	CollectionStatus_syncing_orders    CollectionStatus = 8
	CollectionStatus_active            CollectionStatus = 9
	CollectionStatus_failed            CollectionStatus = 10
	CollectionStatus_inactive          CollectionStatus = 11
	CollectionStatus_incompatible_type CollectionStatus = 12
)

var CollectionStatus_name = map[uint8]string{
	0:  "unknown",
	1:  "created",
	8:  "syncing_orders",
	9:  "active",
	10: "failed",
	11: "inactive",
	12: "incompatible_type",
}

var CollectionStatus_value = map[string]uint8{
	"unknown":           0,
	"created":           1,
	"syncing_orders":    8,
	"active":            9,
	"failed":            10,
	"inactive":          11,
	"incompatible_type": 12,
}

func (x CollectionStatus) String() string {
	return CollectionStatus_name[uint8(x)]
}

func (x CollectionStatus) MarshalText() ([]byte, error) {
	return []byte(CollectionStatus_name[uint8(x)]), nil
}

func (x *CollectionStatus) UnmarshalText(b []byte) error {
	*x = CollectionStatus(CollectionStatus_value[string(b)])
	return nil
}

func (x *CollectionStatus) Is(values ...CollectionStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type ProjectStatus uint8

const (
	ProjectStatus_unknown  ProjectStatus = 0
	ProjectStatus_active   ProjectStatus = 1
	ProjectStatus_inactive ProjectStatus = 2
)

var ProjectStatus_name = map[uint8]string{
	0: "unknown",
	1: "active",
	2: "inactive",
}

var ProjectStatus_value = map[string]uint8{
	"unknown":  0,
	"active":   1,
	"inactive": 2,
}

func (x ProjectStatus) String() string {
	return ProjectStatus_name[uint8(x)]
}

func (x ProjectStatus) MarshalText() ([]byte, error) {
	return []byte(ProjectStatus_name[uint8(x)]), nil
}

func (x *ProjectStatus) UnmarshalText(b []byte) error {
	*x = ProjectStatus(ProjectStatus_value[string(b)])
	return nil
}

func (x *ProjectStatus) Is(values ...ProjectStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type ItemsContractStatus uint8

const (
	ItemsContractStatus_unknown                   ItemsContractStatus = 0
	ItemsContractStatus_created                   ItemsContractStatus = 1
	ItemsContractStatus_syncing_contract_metadata ItemsContractStatus = 2
	ItemsContractStatus_synced_contract_metadata  ItemsContractStatus = 3
	ItemsContractStatus_syncing_tokens            ItemsContractStatus = 4
	ItemsContractStatus_synced_tokens             ItemsContractStatus = 5
	ItemsContractStatus_active                    ItemsContractStatus = 10
	ItemsContractStatus_inactive                  ItemsContractStatus = 20
	ItemsContractStatus_incompatible_type         ItemsContractStatus = 21
)

var ItemsContractStatus_name = map[uint8]string{
	0:  "unknown",
	1:  "created",
	2:  "syncing_contract_metadata",
	3:  "synced_contract_metadata",
	4:  "syncing_tokens",
	5:  "synced_tokens",
	10: "active",
	20: "inactive",
	21: "incompatible_type",
}

var ItemsContractStatus_value = map[string]uint8{
	"unknown":                   0,
	"created":                   1,
	"syncing_contract_metadata": 2,
	"synced_contract_metadata":  3,
	"syncing_tokens":            4,
	"synced_tokens":             5,
	"active":                    10,
	"inactive":                  20,
	"incompatible_type":         21,
}

func (x ItemsContractStatus) String() string {
	return ItemsContractStatus_name[uint8(x)]
}

func (x ItemsContractStatus) MarshalText() ([]byte, error) {
	return []byte(ItemsContractStatus_name[uint8(x)]), nil
}

func (x *ItemsContractStatus) UnmarshalText(b []byte) error {
	*x = ItemsContractStatus(ItemsContractStatus_value[string(b)])
	return nil
}

func (x *ItemsContractStatus) Is(values ...ItemsContractStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type CollectibleStatus uint8

const (
	CollectibleStatus_unknown  CollectibleStatus = 0
	CollectibleStatus_active   CollectibleStatus = 1
	CollectibleStatus_inactive CollectibleStatus = 2
)

var CollectibleStatus_name = map[uint8]string{
	0: "unknown",
	1: "active",
	2: "inactive",
}

var CollectibleStatus_value = map[string]uint8{
	"unknown":  0,
	"active":   1,
	"inactive": 2,
}

func (x CollectibleStatus) String() string {
	return CollectibleStatus_name[uint8(x)]
}

func (x CollectibleStatus) MarshalText() ([]byte, error) {
	return []byte(CollectibleStatus_name[uint8(x)]), nil
}

func (x *CollectibleStatus) UnmarshalText(b []byte) error {
	*x = CollectibleStatus(CollectibleStatus_value[string(b)])
	return nil
}

func (x *CollectibleStatus) Is(values ...CollectibleStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type CollectibleSource uint8

const (
	CollectibleSource_unknown CollectibleSource = 0
	CollectibleSource_indexer CollectibleSource = 1
	CollectibleSource_manual  CollectibleSource = 2
)

var CollectibleSource_name = map[uint8]string{
	0: "unknown",
	1: "indexer",
	2: "manual",
}

var CollectibleSource_value = map[string]uint8{
	"unknown": 0,
	"indexer": 1,
	"manual":  2,
}

func (x CollectibleSource) String() string {
	return CollectibleSource_name[uint8(x)]
}

func (x CollectibleSource) MarshalText() ([]byte, error) {
	return []byte(CollectibleSource_name[uint8(x)]), nil
}

func (x *CollectibleSource) UnmarshalText(b []byte) error {
	*x = CollectibleSource(CollectibleSource_value[string(b)])
	return nil
}

func (x *CollectibleSource) Is(values ...CollectibleSource) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type CurrencyStatus uint8

const (
	CurrencyStatus_unknown          CurrencyStatus = 0
	CurrencyStatus_created          CurrencyStatus = 1
	CurrencyStatus_syncing_metadata CurrencyStatus = 2
	CurrencyStatus_active           CurrencyStatus = 3
	CurrencyStatus_failed           CurrencyStatus = 4
)

var CurrencyStatus_name = map[uint8]string{
	0: "unknown",
	1: "created",
	2: "syncing_metadata",
	3: "active",
	4: "failed",
}

var CurrencyStatus_value = map[string]uint8{
	"unknown":          0,
	"created":          1,
	"syncing_metadata": 2,
	"active":           3,
	"failed":           4,
}

func (x CurrencyStatus) String() string {
	return CurrencyStatus_name[uint8(x)]
}

func (x CurrencyStatus) MarshalText() ([]byte, error) {
	return []byte(CurrencyStatus_name[uint8(x)]), nil
}

func (x *CurrencyStatus) UnmarshalText(b []byte) error {
	*x = CurrencyStatus(CurrencyStatus_value[string(b)])
	return nil
}

func (x *CurrencyStatus) Is(values ...CurrencyStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type WalletKind uint8

const (
	WalletKind_unknown  WalletKind = 0
	WalletKind_sequence WalletKind = 1
)

var WalletKind_name = map[uint8]string{
	0: "unknown",
	1: "sequence",
}

var WalletKind_value = map[string]uint8{
	"unknown":  0,
	"sequence": 1,
}

func (x WalletKind) String() string {
	return WalletKind_name[uint8(x)]
}

func (x WalletKind) MarshalText() ([]byte, error) {
	return []byte(WalletKind_name[uint8(x)]), nil
}

func (x *WalletKind) UnmarshalText(b []byte) error {
	*x = WalletKind(WalletKind_value[string(b)])
	return nil
}

func (x *WalletKind) Is(values ...WalletKind) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type StepType uint8

const (
	StepType_unknown       StepType = 0
	StepType_tokenApproval StepType = 1
	StepType_buy           StepType = 2
	StepType_sell          StepType = 3
	StepType_createListing StepType = 4
	StepType_createOffer   StepType = 5
	StepType_signEIP712    StepType = 6
	StepType_signEIP191    StepType = 7
	StepType_cancel        StepType = 8
)

var StepType_name = map[uint8]string{
	0: "unknown",
	1: "tokenApproval",
	2: "buy",
	3: "sell",
	4: "createListing",
	5: "createOffer",
	6: "signEIP712",
	7: "signEIP191",
	8: "cancel",
}

var StepType_value = map[string]uint8{
	"unknown":       0,
	"tokenApproval": 1,
	"buy":           2,
	"sell":          3,
	"createListing": 4,
	"createOffer":   5,
	"signEIP712":    6,
	"signEIP191":    7,
	"cancel":        8,
}

func (x StepType) String() string {
	return StepType_name[uint8(x)]
}

func (x StepType) MarshalText() ([]byte, error) {
	return []byte(StepType_name[uint8(x)]), nil
}

func (x *StepType) UnmarshalText(b []byte) error {
	*x = StepType(StepType_value[string(b)])
	return nil
}

func (x *StepType) Is(values ...StepType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TransactionCrypto uint32

const (
	TransactionCrypto_none      TransactionCrypto = 0
	TransactionCrypto_partially TransactionCrypto = 1
	TransactionCrypto_all       TransactionCrypto = 2
)

var TransactionCrypto_name = map[uint32]string{
	0: "none",
	1: "partially",
	2: "all",
}

var TransactionCrypto_value = map[string]uint32{
	"none":      0,
	"partially": 1,
	"all":       2,
}

func (x TransactionCrypto) String() string {
	return TransactionCrypto_name[uint32(x)]
}

func (x TransactionCrypto) MarshalText() ([]byte, error) {
	return []byte(TransactionCrypto_name[uint32(x)]), nil
}

func (x *TransactionCrypto) UnmarshalText(b []byte) error {
	*x = TransactionCrypto(TransactionCrypto_value[string(b)])
	return nil
}

func (x *TransactionCrypto) Is(values ...TransactionCrypto) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TransactionNFTCheckoutProvider uint32

const (
	TransactionNFTCheckoutProvider_unknown TransactionNFTCheckoutProvider = 0
	TransactionNFTCheckoutProvider_transak TransactionNFTCheckoutProvider = 1
	TransactionNFTCheckoutProvider_sardine TransactionNFTCheckoutProvider = 2
)

var TransactionNFTCheckoutProvider_name = map[uint32]string{
	0: "unknown",
	1: "transak",
	2: "sardine",
}

var TransactionNFTCheckoutProvider_value = map[string]uint32{
	"unknown": 0,
	"transak": 1,
	"sardine": 2,
}

func (x TransactionNFTCheckoutProvider) String() string {
	return TransactionNFTCheckoutProvider_name[uint32(x)]
}

func (x TransactionNFTCheckoutProvider) MarshalText() ([]byte, error) {
	return []byte(TransactionNFTCheckoutProvider_name[uint32(x)]), nil
}

func (x *TransactionNFTCheckoutProvider) UnmarshalText(b []byte) error {
	*x = TransactionNFTCheckoutProvider(TransactionNFTCheckoutProvider_value[string(b)])
	return nil
}

func (x *TransactionNFTCheckoutProvider) Is(values ...TransactionNFTCheckoutProvider) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TransactionOnRampProvider uint32

const (
	TransactionOnRampProvider_unknown TransactionOnRampProvider = 0
	TransactionOnRampProvider_transak TransactionOnRampProvider = 1
	TransactionOnRampProvider_sardine TransactionOnRampProvider = 2
)

var TransactionOnRampProvider_name = map[uint32]string{
	0: "unknown",
	1: "transak",
	2: "sardine",
}

var TransactionOnRampProvider_value = map[string]uint32{
	"unknown": 0,
	"transak": 1,
	"sardine": 2,
}

func (x TransactionOnRampProvider) String() string {
	return TransactionOnRampProvider_name[uint32(x)]
}

func (x TransactionOnRampProvider) MarshalText() ([]byte, error) {
	return []byte(TransactionOnRampProvider_name[uint32(x)]), nil
}

func (x *TransactionOnRampProvider) UnmarshalText(b []byte) error {
	*x = TransactionOnRampProvider(TransactionOnRampProvider_value[string(b)])
	return nil
}

func (x *TransactionOnRampProvider) Is(values ...TransactionOnRampProvider) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type TransactionSwapProvider uint32

const (
	TransactionSwapProvider_unknown TransactionSwapProvider = 0
	TransactionSwapProvider_lifi    TransactionSwapProvider = 1
)

var TransactionSwapProvider_name = map[uint32]string{
	0: "unknown",
	1: "lifi",
}

var TransactionSwapProvider_value = map[string]uint32{
	"unknown": 0,
	"lifi":    1,
}

func (x TransactionSwapProvider) String() string {
	return TransactionSwapProvider_name[uint32(x)]
}

func (x TransactionSwapProvider) MarshalText() ([]byte, error) {
	return []byte(TransactionSwapProvider_name[uint32(x)]), nil
}

func (x *TransactionSwapProvider) UnmarshalText(b []byte) error {
	*x = TransactionSwapProvider(TransactionSwapProvider_value[string(b)])
	return nil
}

func (x *TransactionSwapProvider) Is(values ...TransactionSwapProvider) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type ExecuteType uint32

const (
	ExecuteType_unknown          ExecuteType = 0
	ExecuteType_order            ExecuteType = 1
	ExecuteType_createListing    ExecuteType = 2
	ExecuteType_createItemOffer  ExecuteType = 3
	ExecuteType_createTraitOffer ExecuteType = 4
)

var ExecuteType_name = map[uint32]string{
	0: "unknown",
	1: "order",
	2: "createListing",
	3: "createItemOffer",
	4: "createTraitOffer",
}

var ExecuteType_value = map[string]uint32{
	"unknown":          0,
	"order":            1,
	"createListing":    2,
	"createItemOffer":  3,
	"createTraitOffer": 4,
}

func (x ExecuteType) String() string {
	return ExecuteType_name[uint32(x)]
}

func (x ExecuteType) MarshalText() ([]byte, error) {
	return []byte(ExecuteType_name[uint32(x)]), nil
}

func (x *ExecuteType) UnmarshalText(b []byte) error {
	*x = ExecuteType(ExecuteType_value[string(b)])
	return nil
}

func (x *ExecuteType) Is(values ...ExecuteType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type ActivityAction uint8

const (
	ActivityAction_unknown       ActivityAction = 0
	ActivityAction_listing       ActivityAction = 1
	ActivityAction_offer         ActivityAction = 2
	ActivityAction_mint          ActivityAction = 3
	ActivityAction_sale          ActivityAction = 4
	ActivityAction_listingCancel ActivityAction = 5
	ActivityAction_offerCancel   ActivityAction = 6
	ActivityAction_transfer      ActivityAction = 7
)

var ActivityAction_name = map[uint8]string{
	0: "unknown",
	1: "listing",
	2: "offer",
	3: "mint",
	4: "sale",
	5: "listingCancel",
	6: "offerCancel",
	7: "transfer",
}

var ActivityAction_value = map[string]uint8{
	"unknown":       0,
	"listing":       1,
	"offer":         2,
	"mint":          3,
	"sale":          4,
	"listingCancel": 5,
	"offerCancel":   6,
	"transfer":      7,
}

func (x ActivityAction) String() string {
	return ActivityAction_name[uint8(x)]
}

func (x ActivityAction) MarshalText() ([]byte, error) {
	return []byte(ActivityAction_name[uint8(x)]), nil
}

func (x *ActivityAction) UnmarshalText(b []byte) error {
	*x = ActivityAction(ActivityAction_value[string(b)])
	return nil
}

func (x *ActivityAction) Is(values ...ActivityAction) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type PrimarySaleContractStatus uint8

const (
	PrimarySaleContractStatus_unknown           PrimarySaleContractStatus = 0
	PrimarySaleContractStatus_created           PrimarySaleContractStatus = 1
	PrimarySaleContractStatus_syncing_items     PrimarySaleContractStatus = 2
	PrimarySaleContractStatus_active            PrimarySaleContractStatus = 10
	PrimarySaleContractStatus_inactive          PrimarySaleContractStatus = 20
	PrimarySaleContractStatus_incompatible_type PrimarySaleContractStatus = 21
	PrimarySaleContractStatus_failed            PrimarySaleContractStatus = 22
)

var PrimarySaleContractStatus_name = map[uint8]string{
	0:  "unknown",
	1:  "created",
	2:  "syncing_items",
	10: "active",
	20: "inactive",
	21: "incompatible_type",
	22: "failed",
}

var PrimarySaleContractStatus_value = map[string]uint8{
	"unknown":           0,
	"created":           1,
	"syncing_items":     2,
	"active":            10,
	"inactive":          20,
	"incompatible_type": 21,
	"failed":            22,
}

func (x PrimarySaleContractStatus) String() string {
	return PrimarySaleContractStatus_name[uint8(x)]
}

func (x PrimarySaleContractStatus) MarshalText() ([]byte, error) {
	return []byte(PrimarySaleContractStatus_name[uint8(x)]), nil
}

func (x *PrimarySaleContractStatus) UnmarshalText(b []byte) error {
	*x = PrimarySaleContractStatus(PrimarySaleContractStatus_value[string(b)])
	return nil
}

func (x *PrimarySaleContractStatus) Is(values ...PrimarySaleContractStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type PrimarySaleVersion uint8

const (
	PrimarySaleVersion_v0 PrimarySaleVersion = 0
	PrimarySaleVersion_v1 PrimarySaleVersion = 1
)

var PrimarySaleVersion_name = map[uint8]string{
	0: "v0",
	1: "v1",
}

var PrimarySaleVersion_value = map[string]uint8{
	"v0": 0,
	"v1": 1,
}

func (x PrimarySaleVersion) String() string {
	return PrimarySaleVersion_name[uint8(x)]
}

func (x PrimarySaleVersion) MarshalText() ([]byte, error) {
	return []byte(PrimarySaleVersion_name[uint8(x)]), nil
}

func (x *PrimarySaleVersion) UnmarshalText(b []byte) error {
	*x = PrimarySaleVersion(PrimarySaleVersion_value[string(b)])
	return nil
}

func (x *PrimarySaleVersion) Is(values ...PrimarySaleVersion) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type PrimarySaleItemDetailType uint8

const (
	PrimarySaleItemDetailType_unknown    PrimarySaleItemDetailType = 0
	PrimarySaleItemDetailType_global     PrimarySaleItemDetailType = 1
	PrimarySaleItemDetailType_individual PrimarySaleItemDetailType = 2
)

var PrimarySaleItemDetailType_name = map[uint8]string{
	0: "unknown",
	1: "global",
	2: "individual",
}

var PrimarySaleItemDetailType_value = map[string]uint8{
	"unknown":    0,
	"global":     1,
	"individual": 2,
}

func (x PrimarySaleItemDetailType) String() string {
	return PrimarySaleItemDetailType_name[uint8(x)]
}

func (x PrimarySaleItemDetailType) MarshalText() ([]byte, error) {
	return []byte(PrimarySaleItemDetailType_name[uint8(x)]), nil
}

func (x *PrimarySaleItemDetailType) UnmarshalText(b []byte) error {
	*x = PrimarySaleItemDetailType(PrimarySaleItemDetailType_value[string(b)])
	return nil
}

func (x *PrimarySaleItemDetailType) Is(values ...PrimarySaleItemDetailType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type MetadataStatus uint32

const (
	MetadataStatus_NOT_AVAILABLE MetadataStatus = 0
	MetadataStatus_REFRESHING    MetadataStatus = 1
	MetadataStatus_AVAILABLE     MetadataStatus = 2
)

var MetadataStatus_name = map[uint32]string{
	0: "NOT_AVAILABLE",
	1: "REFRESHING",
	2: "AVAILABLE",
}

var MetadataStatus_value = map[string]uint32{
	"NOT_AVAILABLE": 0,
	"REFRESHING":    1,
	"AVAILABLE":     2,
}

func (x MetadataStatus) String() string {
	return MetadataStatus_name[uint32(x)]
}

func (x MetadataStatus) MarshalText() ([]byte, error) {
	return []byte(MetadataStatus_name[uint32(x)]), nil
}

func (x *MetadataStatus) UnmarshalText(b []byte) error {
	*x = MetadataStatus(MetadataStatus_value[string(b)])
	return nil
}

func (x *MetadataStatus) Is(values ...MetadataStatus) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

// Page represents a results page. This can be used both to request a page and
// to store the state of a page.
type Page struct {
	// Numbered pages: Page number, this is multiplied by the value of the <pageSize> parameter.
	Page uint32 `json:"page,omitempty"`
	// Number of items per page
	PageSize uint32 `json:"pageSize,omitempty"`
	// Indicates if there are more results available
	More *bool `json:"more,omitempty"`
	// Sorting filter
	Sort []*SortBy `json:"sort,omitempty"`
}

type SortBy struct {
	Column string    `json:"column"`
	Order  SortOrder `json:"order"`
}

// copied from metadata filter
// PropertyFilter
// name -> name of the property, eg: hero
// type -> type of the values of the property, eg: Int, string
// min?, max? used if type is int, gives range of values for filtering
// values? -> if string then array of values, eg: ['Ada', 'Ari', 'Axel', 'Banjo' ...]
// NOTE: When Filter has an array of PropertyFilter, the logic used is an 'and' condition
// whereas if the user selects multiple values inside the PropertyFilter, they logic used is the 'or' condition
// this is to achieve the desired effect opensea had on their filters
type Filter struct {
	Text       *string           `json:"text"`
	Properties []*PropertyFilter `json:"properties"`
}

type PropertyFilter struct {
	Name   string        `json:"name"`
	Type   PropertyType  `json:"type"`
	Min    *int64        `json:"min"`
	Max    *int64        `json:"max"`
	Values []interface{} `json:"values"`
}

type CollectiblesFilter struct {
	// include collectibles without any orders at the end of the list
	IncludeEmpty bool `json:"includeEmpty"`
	// search collectibles by text
	// if the filter matches too many tokens (over 65,000), only a subset of results will be returned
	SearchText *string `json:"searchText"`
	// filter by metadata properties
	Properties []*PropertyFilter `json:"properties"`
	// filter only orders in specific marketplace
	Marketplaces []MarketplaceKind `json:"marketplaces"`
	// filter collectibles owned by given account addresses
	// if the filter matches too many tokens (over 65,000), only a subset of results will be returned
	InAccounts []string `json:"inAccounts"`
	// filter out collectibles owned by given account addresses
	// if the filter matches too many tokens (over 65,000), only a subset of results will be returned
	NotInAccounts []string `json:"notInAccounts"`
	// filter orders created by given account addresses
	OrdersCreatedBy []string `json:"ordersCreatedBy"`
	// filter out orders created by given account addresses
	OrdersNotCreatedBy []string `json:"ordersNotCreatedBy"`
	// filter orders in given currency address
	// (use '0x0000000000000000000000000000000000000000' for native currency)
	InCurrencyAddresses []string `json:"inCurrencyAddresses"`
	// filter out orders in given currency address
	// (use '0x0000000000000000000000000000000000000000' for native currency)
	NotInCurrencyAddresses []string `json:"notInCurrencyAddresses"`
	// filter orders by price, filter applies OR for elements in this array
	Prices []*PriceFilter `json:"prices"`
}

type OrdersFilter struct {
	// search collectibles by text
	// if the filter matches too many tokens (over 65,000), only a subset of results will be returned
	SearchText *string `json:"searchText"`
	// filter by metadata properties
	Properties []*PropertyFilter `json:"properties"`
	// filter only orders in specific marketplace
	Marketplaces []MarketplaceKind `json:"marketplaces"`
	// filter collectibles owned by given account addresses
	// if the filter matches too many tokens (over 65,000), only a subset of results will be returned
	InAccounts []string `json:"inAccounts"`
	// filter out collectibles owned by given account addresses
	// if the filter matches too many tokens (over 65,000), only a subset of results will be returned
	NotInAccounts []string `json:"notInAccounts"`
	// filter orders created by given account addresses
	OrdersCreatedBy []string `json:"ordersCreatedBy"`
	// filter out orders created by given account addresses
	OrdersNotCreatedBy []string `json:"ordersNotCreatedBy"`
	// filter orders in given currency address
	// (use '0x0000000000000000000000000000000000000000' for native currency)
	InCurrencyAddresses []string `json:"inCurrencyAddresses"`
	// filter out orders in given currency address
	// (use '0x0000000000000000000000000000000000000000' for native currency)
	NotInCurrencyAddresses []string `json:"notInCurrencyAddresses"`
	// filter orders by price, filter applies OR for elements in this array
	Prices []*PriceFilter `json:"prices"`
}

type PriceFilter struct {
	// currency contract address
	ContractAddress string `json:"contractAddress"`
	// min price included
	Min *prototyp.BigInt `json:"min"`
	// max price included
	Max *prototyp.BigInt `json:"max"`
}

type Order struct {
	ID            uint64          `json:"-" db:"id,omitempty"`
	CollectionID  uint64          `json:"-" db:"market_id"`
	CollectibleID *uint64         `json:"-" db:"collectible_id"`
	OrderID       string          `json:"orderId" db:"order_id"`
	Marketplace   MarketplaceKind `json:"marketplace" db:"marketplace"`
	Source        SourceKind      `json:"-" db:"source"`
	Side          OrderSide       `json:"side" db:"side"`
	Status        OrderStatus     `json:"status" db:"status"`
	ChainID       uint64          `json:"chainId" db:"chain_id"`
	OriginName    string          `json:"originName,omitempty" db:"origin_name"`
	Slug          string          `json:"-" db:"slug"`
	// contract
	CollectionContractAddress  prototyp.Hash    `json:"collectionContractAddress" db:"contract_address"`
	TokenID                    *prototyp.BigInt `json:"tokenId" db:"token_id"`
	CreatedBy                  prototyp.Hash    `json:"createdBy" db:"created_by"`
	PriceAmount                prototyp.BigInt  `json:"priceAmount" db:"price_amount"`
	PriceAmountFormatted       string           `json:"priceAmountFormatted"`
	PriceAmountNet             prototyp.BigInt  `json:"priceAmountNet" db:"price_amount_net"`
	PriceAmountNetFormatted    string           `json:"priceAmountNetFormatted"`
	PriceCurrencyAddress       prototyp.Hash    `json:"priceCurrencyAddress" db:"price_currency_address"`
	PriceDecimals              uint64           `json:"priceDecimals" db:"price_decimals"`
	PriceUSD                   float64          `json:"priceUSD" db:"price_usd"`
	PriceUSDFormatted          string           `json:"priceUSDFormatted"`
	QuantityInitial            prototyp.BigInt  `json:"quantityInitial" db:"qty_initial"`
	QuantityInitialFormatted   string           `json:"quantityInitialFormatted"`
	QuantityRemaining          prototyp.BigInt  `json:"quantityRemaining" db:"qty_remaining"`
	QuantityRemainingFormatted string           `json:"quantityRemainingFormatted"`
	QuantityAvailable          prototyp.BigInt  `json:"quantityAvailable" db:"qty_available"`
	QuantityAvailableFormatted string           `json:"quantityAvailableFormatted"`
	QuantityDecimals           uint64           `json:"quantityDecimals" db:"qty_decimals"`
	FeeBPS                     int64            `json:"feeBps" db:"fee_bps"`
	FeeBreakdown               []*FeeBreakdown  `json:"feeBreakdown" db:"fee_breakdown"`
	ValidFrom                  time.Time        `json:"validFrom" db:"valid_from"`
	// expiration
	ValidUntil     time.Time  `json:"validUntil" db:"valid_until"`
	BlockNumber    uint64     `json:"blockNumber" db:"block_number"`
	OrderCreatedAt *time.Time `json:"orderCreatedAt" db:"order_created_at"`
	OrderUpdatedAt *time.Time `json:"orderUpdatedAt" db:"order_updated_at"`
	CreatedAt      time.Time  `json:"createdAt" db:"created_at"`
	UpdatedAt      time.Time  `json:"updatedAt" db:"updated_at"`
	DeletedAt      *time.Time `json:"deletedAt,omitempty" db:"deleted_at"`
}

type FeeBreakdown struct {
	Kind             string `json:"kind"`
	RecipientAddress string `json:"recipientAddress"`
	Bps              int64  `json:"bps"`
}

type CollectibleOrder struct {
	Metadata *TokenMetadata `json:"metadata"`
	Order    *Order         `json:"order"`
	Listing  *Order         `json:"listing"`
	Offer    *Order         `json:"offer"`
}

type OrderFilter struct {
	CreatedBy   []string          `json:"createdBy"`
	Marketplace []MarketplaceKind `json:"marketplace"`
	Currencies  []string          `json:"currencies"`
}

type Collection struct {
	ID                    uint64             `json:"-" db:"id,omitempty"`
	Status                CollectionStatus   `json:"status" db:"status"`
	ItemsContractID       uint64             `json:"-" db:"items_contract_id"`
	ChainID               uint64             `json:"chainId" db:"chain_id"`
	ContractAddress       prototyp.Hash      `json:"contractAddress" db:"contract_address"`
	ContractType          ContractType       `json:"contractType" db:"contract_type"`
	Priority              CollectionPriority `json:"priority" db:"priority"`
	TokenQuantityDecimals uint64             `json:"tokenQuantityDecimals" db:"token_qty_decimals"`
	Config                *CollectionConfig  `json:"config" db:"config"`
	CreatedAt             time.Time          `json:"createdAt" db:"created_at"`
	UpdatedAt             time.Time          `json:"updatedAt" db:"updated_at"`
	DeletedAt             *time.Time         `json:"deletedAt,omitempty" db:"deleted_at"`
}

type CollectionConfig struct {
	LastSynced                 map[string]*CollectionLastSynced `json:"lastSynced"`
	CollectiblesSynced         time.Time                        `json:"collectiblesSynced"`
	ActivitiesSynced           time.Time                        `json:"activitiesSynced"`
	ActivitiesSyncedContinuity string                           `json:"activitiesSyncedContinuity"`
}

type CollectionLastSynced struct {
	AllOrders time.Time         `json:"allOrders"`
	NewOrders time.Time         `json:"newOrders"`
	Names     []string          `json:"names"`
	Cursors   map[string]string `json:"cursors"`
}

type Project struct {
	ID                    uint64        `json:"-" db:"id,omitempty"`
	ProjectID             uint64        `json:"projectId" db:"project_id"`
	CollectionID          *uint64       `json:"-" db:"market_id,omitempty"`
	PrimarySaleContractID *uint64       `json:"-" db:"primary_sale_contract_id,omitempty"`
	ChainID               uint64        `json:"chainId" db:"chain_id"`
	ContractAddress       prototyp.Hash `json:"contractAddress" db:"contract_address"`
	Status                ProjectStatus `json:"status" db:"status"`
	CreatedAt             time.Time     `json:"createdAt" db:"created_at"`
	UpdatedAt             time.Time     `json:"updatedAt" db:"updated_at"`
	DeletedAt             *time.Time    `json:"deletedAt,omitempty" db:"deleted_at"`
}

type ItemsContract struct {
	ID              uint64              `json:"-" db:"id,omitempty"`
	Status          ItemsContractStatus `json:"status" db:"status"`
	ChainID         uint64              `json:"chainId" db:"chain_id"`
	ContractAddress prototyp.Hash       `json:"contractAddress" db:"contract_address"`
	ContractType    ContractType        `json:"contractType" db:"contract_type"`
	LastSynced      time.Time           `json:"lastSynced" db:"last_synced"`
	CreatedAt       time.Time           `json:"createdAt" db:"created_at"`
	UpdatedAt       time.Time           `json:"updatedAt" db:"updated_at"`
	DeletedAt       *time.Time          `json:"deletedAt,omitempty" db:"deleted_at"`
}

type Collectible struct {
	ID              uint64            `json:"-" db:"id,omitempty"`
	ItemsContractID uint64            `json:"-" db:"items_contract_id"`
	Status          CollectibleStatus `json:"status" db:"status"`
	TokenID         prototyp.BigInt   `json:"tokenId" db:"token_id"`
	Decimals        uint64            `json:"decimals" db:"decimals"`
	Source          CollectibleSource `json:"source" db:"source"`
	CreatedAt       time.Time         `json:"createdAt" db:"created_at"`
	UpdatedAt       time.Time         `json:"updatedAt" db:"updated_at"`
	DeletedAt       *time.Time        `json:"deletedAt,omitempty" db:"deleted_at"`
}

type Currency struct {
	ID                   uint64         `json:"-" db:"id,omitempty"`
	ChainID              uint64         `json:"chainId" db:"chain_id"`
	ContractAddress      prototyp.Hash  `json:"contractAddress,omitempty" db:"contract_address"`
	Status               CurrencyStatus `json:"status" db:"status"`
	Name                 string         `json:"name" db:"name"`
	Symbol               string         `json:"symbol" db:"symbol"`
	Decimals             uint64         `json:"decimals" db:"decimals"`
	ImageURL             string         `json:"imageUrl" db:"image_url"`
	ExchangeRate         float64        `json:"exchangeRate" db:"exchange_rate"`
	DefaultChainCurrency bool           `json:"defaultChainCurrency" db:"default_chain_currency"`
	NativeCurrency       bool           `json:"nativeCurrency" db:"native_currency"`
	OpenseaListing       bool           `json:"openseaListing" db:"opensea_listing"`
	OpenseaOffer         bool           `json:"openseaOffer" db:"opensea_offer"`
	CreatedAt            time.Time      `json:"createdAt" db:"created_at"`
	UpdatedAt            time.Time      `json:"updatedAt" db:"updated_at"`
	DeletedAt            *time.Time     `json:"deletedAt,omitempty" db:"deleted_at"`
	RefreshMetadataJob   uint64         `json:"-" db:"refresh_metadata_job"`
}

type OrderData struct {
	OrderID  string           `json:"orderId"`
	Quantity string           `json:"quantity"`
	TokenID  *prototyp.BigInt `json:"tokenId"`
}

type AdditionalFee struct {
	Amount   string `json:"amount"`
	Receiver string `json:"receiver"`
}

type Step struct {
	ID          StepType     `json:"id"`
	Data        string       `json:"data"`
	To          string       `json:"to"`
	Value       string       `json:"value"`
	Price       string       `json:"price"`
	Signature   *Signature   `json:"signature"`
	Post        *PostRequest `json:"post"`
	ExecuteType *ExecuteType `json:"executeType"`
}

type PostRequest struct {
	Endpoint string      `json:"endpoint"`
	Method   string      `json:"method"`
	Body     interface{} `json:"body"`
}

type CreateReq struct {
	TokenID  string `json:"tokenId"`
	Quantity string `json:"quantity"`
	// unix time format
	Expiry          string `json:"expiry"`
	CurrencyAddress string `json:"currencyAddress"`
	PricePerToken   string `json:"pricePerToken"`
}

type GetOrdersInput struct {
	ContractAddress prototyp.Hash   `json:"contractAddress"`
	OrderID         string          `json:"orderId"`
	Marketplace     MarketplaceKind `json:"marketplace"`
}

type Signature struct {
	Domain      *Domain     `json:"domain"`
	Types       interface{} `json:"types"`
	PrimaryType string      `json:"primaryType"`
	Value       interface{} `json:"value"`
}

type Domain struct {
	Name              string `json:"name"`
	Version           string `json:"version"`
	ChainID           uint64 `json:"chainId"`
	VerifyingContract string `json:"verifyingContract"`
}

type CheckoutOptionsMarketplaceOrder struct {
	ContractAddress prototyp.Hash   `json:"contractAddress"`
	OrderID         string          `json:"orderId"`
	Marketplace     MarketplaceKind `json:"marketplace"`
}

type CheckoutOptionsItem struct {
	TokenID  string          `json:"tokenId"`
	Quantity prototyp.BigInt `json:"quantity"`
}

type CheckoutOptions struct {
	Crypto      TransactionCrypto                `json:"crypto"`
	Swap        []TransactionSwapProvider        `json:"swap"`
	NFTCheckout []TransactionNFTCheckoutProvider `json:"nftCheckout"`
	OnRamp      []TransactionOnRampProvider      `json:"onRamp"`
}

type ExecuteInput struct {
	ChainID     string      `json:"chainId"`
	Signature   string      `json:"signature"`
	Method      string      `json:"method"`
	Endpoint    string      `json:"endpoint"`
	ExecuteType ExecuteType `json:"executeType"`
	Body        interface{} `json:"body"`
	// this parameter can override slug for request
	Slug *string `json:"slug"`
}

type Activity struct {
	ID                   uint64          `json:"-" db:"id,omitempty"`
	CollectionID         uint64          `json:"-" db:"market_id,omitempty"`
	CollectibleID        uint64          `json:"-" db:"collectible_id,omitempty"`
	ChainID              uint64          `json:"chainId" db:"chain_id"`
	ContractAddress      prototyp.Hash   `json:"contractAddress" db:"contract_address"`
	TokenID              prototyp.BigInt `json:"tokenId" db:"token_id"`
	Action               ActivityAction  `json:"action" db:"action"`
	TxHash               prototyp.Hash   `json:"txHash" db:"tx_hash"`
	Source               SourceKind      `json:"-" db:"source"`
	From                 prototyp.Hash   `json:"from" db:"from_address"`
	To                   prototyp.Hash   `json:"to" db:"to_address"`
	Quantity             prototyp.BigInt `json:"quantity" db:"qty"`
	QuantityDecimals     uint64          `json:"quantityDecimals" db:"qty_decimals"`
	PriceAmount          prototyp.BigInt `json:"priceAmount" db:"price_amount"`
	PriceAmountFormatted *string         `json:"priceAmountFormatted"`
	PriceCurrencyAddress prototyp.Hash   `json:"priceCurrencyAddress" db:"price_currency_address"`
	PriceDecimals        *uint64         `json:"priceDecimals" db:"price_decimals"`
	ActivityCreatedAt    time.Time       `json:"activityCreatedAt" db:"activity_created_at"`
	LogIndex             uint64          `json:"-" db:"log_index"`
	UniqueHash           prototyp.Hash   `json:"uniqueHash" db:"unique_hash"`
	CreatedAt            time.Time       `json:"createdAt" db:"created_at"`
	UpdatedAt            time.Time       `json:"updatedAt" db:"updated_at"`
	DeletedAt            *time.Time      `json:"deletedAt,omitempty" db:"deleted_at"`
}

type PrimarySaleContract struct {
	ID                uint64                    `json:"-" db:"id,omitempty"`
	ChainID           uint64                    `json:"chainId" db:"chain_id"`
	ContractAddress   prototyp.Hash             `json:"contractAddress" db:"contract_address"`
	CollectionAddress prototyp.Hash             `json:"collectionAddress" db:"collection_address"`
	ContractType      ContractType              `json:"contractType" db:"contract_type"`
	Version           PrimarySaleVersion        `json:"version" db:"version"`
	CurrencyAddress   prototyp.Hash             `json:"currencyAddress" db:"currency_address"`
	PriceDecimals     uint64                    `json:"priceDecimals" db:"price_decimals"`
	ItemsContractID   uint64                    `json:"-" db:"items_contract_id"`
	Status            PrimarySaleContractStatus `json:"status" db:"status"`
	LastSynced        time.Time                 `json:"lastSynced" db:"last_synced"`
	CreatedAt         time.Time                 `json:"createdAt" db:"created_at"`
	UpdatedAt         time.Time                 `json:"updatedAt" db:"updated_at"`
	DeletedAt         *time.Time                `json:"deletedAt,omitempty" db:"deleted_at"`
}

type PrimarySaleItem struct {
	ID                   uint64                    `json:"-" db:"id,omitempty"`
	ContractID           uint64                    `json:"-" db:"contract_id,omitempty"`
	ItemAddress          prototyp.Hash             `json:"itemAddress"`
	ContractType         ContractType              `json:"contractType"`
	CollectibleID        uint64                    `json:"-" db:"collectible_id"`
	TokenID              prototyp.BigInt           `json:"tokenId"`
	ItemType             PrimarySaleItemDetailType `json:"itemType" db:"detail_type,omitempty"`
	StartDate            time.Time                 `json:"startDate" db:"start_date"`
	EndDate              time.Time                 `json:"endDate" db:"end_date"`
	CurrencyAddress      prototyp.Hash             `json:"currencyAddress"`
	PriceDecimals        uint64                    `json:"priceDecimals"`
	PriceAmount          prototyp.BigInt           `json:"priceAmount" db:"price_amount"`
	PriceAmountFormatted string                    `json:"priceAmountFormatted"`
	PriceUSD             float64                   `json:"priceUsd"`
	PriceUSDFormatted    string                    `json:"priceUsdFormatted"`
	Supply               prototyp.BigInt           `json:"supply" db:"supply"`
	SupplyCap            prototyp.BigInt           `json:"supplyCap" db:"supply_cap"`
	UnlimitedSupply      bool                      `json:"unlimitedSupply" db:"unlimited_supply"`
	CreatedAt            time.Time                 `json:"createdAt" db:"created_at"`
	UpdatedAt            time.Time                 `json:"updatedAt" db:"updated_at"`
	DeletedAt            *time.Time                `json:"deletedAt,omitempty" db:"deleted_at"`
}

type CollectiblePrimarySaleItem struct {
	Metadata        *TokenMetadata   `json:"metadata"`
	PrimarySaleItem *PrimarySaleItem `json:"primarySaleItem"`
}

type PrimarySaleItemsFilter struct {
	// include primary sale items with supply cap 0
	IncludeEmpty bool `json:"includeEmpty"`
	// search collectibles by text
	// if the filter matches too many tokens (over 65,000), only a subset of results will be returned
	SearchText *string `json:"searchText"`
	// filter by metadata properties
	Properties []*PropertyFilter `json:"properties"`
	// filter by item detail type
	DetailTypes     []PrimarySaleItemDetailType `json:"detailTypes"`
	StartDateAfter  *time.Time                  `json:"startDateAfter"`
	StartDateBefore *time.Time                  `json:"startDateBefore"`
	EndDateAfter    *time.Time                  `json:"endDateAfter"`
	EndDateBefore   *time.Time                  `json:"endDateBefore"`
}

// TokenMetadata based on 721/1155 standards, as well including some
// fields which are used by OpenSea.
//
// TokenMetadata is RPC type for responding to clients that represents
// the token-level metadata.
type TokenMetadata struct {
	TokenID     string `json:"tokenId"`
	Name        string `json:"name"`
	Description string `json:"description"`
	// url
	Image string `json:"image"`
	// non-standard fields we've added for Sequence. Others should adopt
	// these too and we should prompt, similar to how `image` field works.
	// url
	Video string `json:"video,omitempty"`
	// url
	Audio      string                 `json:"audio,omitempty"`
	Properties map[string]interface{} `json:"properties"`
	// OpenSea fields
	// see https://docs.opensea.io/docs/metadata-standards
	//
	// NOTE: its a bit unfortunate OpenSea didn't use camelCase, and
	// also introduces 'attributes' when 'properties' is actually the correct property name.
	// TODO: we could smooth this out / normalize it, but we can leave it for now.
	Attributes      []map[string]interface{} `json:"attributes"`
	ImageData       string                   `json:"image_data,omitempty"`
	ExternalUrl     string                   `json:"external_url,omitempty"`
	BackgroundColor string                   `json:"background_color,omitempty"`
	AnimationUrl    string                   `json:"animation_url,omitempty"`
	//
	// Misc
	//
	// decimals is deprecated, but still used by some
	Decimals  *uint64   `json:"decimals,omitempty"`
	UpdatedAt time.Time `json:"updatedAt"`
	// Assets associated to this token metadata
	Assets []*Asset       `json:"assets,omitempty"`
	Status MetadataStatus `json:"status"`
}

// Asset is a database type used by 'collections' to record static assets for
// a particular 'token' for the token metadata.
type Asset struct {
	// asset id
	ID uint64 `json:"id"`
	// collection id associated to this asset
	CollectionID uint64 `json:"collectionId"`
	// token id associated to this collection
	TokenID prototyp.BigInt `json:"tokenId"`
	// url where we can view the asset contents
	// ie. https://metadata.sequence.app/projects/1/collections/1/tokens/1/image
	URL string `json:"url"`
	// metadata field related to TokenMetadata, some field names:
	// ['image', 'video', 'audio', 'animation_url', ...]
	MetadataField string `json:"metadataField,omitempty"`
	// asset details
	Filename  string    `json:"filename,omitempty"`
	Filesize  uint32    `json:"filesize,omitempty"`
	MimeType  string    `json:"mimeType,omitempty"`
	Width     *uint16   `json:"width,omitempty"`
	Height    *uint16   `json:"height,omitempty"`
	UpdatedAt time.Time `json:"updatedAt"`
}

//
// Client
//

const AdminPathPrefix = "/rpc/Admin/"
const MarketplacePathPrefix = "/rpc/Marketplace/"

type adminClient struct {
	client HTTPClient
	urls   [14]string
}

func NewAdminClient(addr string, client HTTPClient) AdminClient {
	prefix := urlBase(addr) + AdminPathPrefix
	urls := [14]string{
		prefix + "CreateCollection",
		prefix + "GetCollection",
		prefix + "UpdateCollection",
		prefix + "ListCollections",
		prefix + "DeleteCollection",
		prefix + "SyncCollection",
		prefix + "CreatePrimarySaleContract",
		prefix + "DeletePrimarySaleContract",
		prefix + "CreateCurrency",
		prefix + "CreateCurrencies",
		prefix + "UpdateCurrency",
		prefix + "ListCurrencies",
		prefix + "DeleteCurrency",
		prefix + "AddCollectibles",
	}
	return &adminClient{
		client: client,
		urls:   urls,
	}
}

func (c *adminClient) CreateCollection(ctx context.Context, chainId string, projectId uint64, contractAddress string) (*Collection, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 uint64 `json:"projectId"`
		Arg2 string `json:"contractAddress"`
	}{chainId, projectId, contractAddress}
	out := struct {
		Ret0 *Collection `json:"collection"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) GetCollection(ctx context.Context, chainId string, projectId uint64, contractAddress string) (*Collection, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 uint64 `json:"projectId"`
		Arg2 string `json:"contractAddress"`
	}{chainId, projectId, contractAddress}
	out := struct {
		Ret0 *Collection `json:"collection"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) UpdateCollection(ctx context.Context, chainId string, collection *Collection) (*Collection, error) {
	in := struct {
		Arg0 string      `json:"chainId"`
		Arg1 *Collection `json:"collection"`
	}{chainId, collection}
	out := struct {
		Ret0 *Collection `json:"collection"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) ListCollections(ctx context.Context, chainId string, projectId uint64, page *Page) ([]*Collection, *Page, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 uint64 `json:"projectId"`
		Arg2 *Page  `json:"page"`
	}{chainId, projectId, page}
	out := struct {
		Ret0 []*Collection `json:"collections"`
		Ret1 *Page         `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *adminClient) DeleteCollection(ctx context.Context, chainId string, projectId uint64, contractAddress string) (*Collection, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 uint64 `json:"projectId"`
		Arg2 string `json:"contractAddress"`
	}{chainId, projectId, contractAddress}
	out := struct {
		Ret0 *Collection `json:"collection"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) SyncCollection(ctx context.Context, chainId string, contractAddress string) error {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"contractAddress"`
	}{chainId, contractAddress}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[5], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return err
}

func (c *adminClient) CreatePrimarySaleContract(ctx context.Context, chainId string, projectId uint64, primarySaleContractAddress string, itemsContractAddress string) (*PrimarySaleContract, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 uint64 `json:"projectId"`
		Arg2 string `json:"primarySaleContractAddress"`
		Arg3 string `json:"itemsContractAddress"`
	}{chainId, projectId, primarySaleContractAddress, itemsContractAddress}
	out := struct {
		Ret0 *PrimarySaleContract `json:"primarySaleContract"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[6], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) DeletePrimarySaleContract(ctx context.Context, chainId string, projectId uint64, primarySaleContractAddress string) error {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 uint64 `json:"projectId"`
		Arg2 string `json:"primarySaleContractAddress"`
	}{chainId, projectId, primarySaleContractAddress}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[7], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return err
}

func (c *adminClient) CreateCurrency(ctx context.Context, chainId string, currency *Currency) (*Currency, error) {
	in := struct {
		Arg0 string    `json:"chainId"`
		Arg1 *Currency `json:"currency"`
	}{chainId, currency}
	out := struct {
		Ret0 *Currency `json:"currency"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[8], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) CreateCurrencies(ctx context.Context, chainId string, currencies []*Currency) (map[string]*Currency, error) {
	in := struct {
		Arg0 string      `json:"chainId"`
		Arg1 []*Currency `json:"currencies"`
	}{chainId, currencies}
	out := struct {
		Ret0 map[string]*Currency `json:"currency"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[9], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) UpdateCurrency(ctx context.Context, chainId string, currency *Currency) (*Currency, error) {
	in := struct {
		Arg0 string    `json:"chainId"`
		Arg1 *Currency `json:"currency"`
	}{chainId, currency}
	out := struct {
		Ret0 *Currency `json:"currency"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[10], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) ListCurrencies(ctx context.Context, chainId string) ([]*Currency, error) {
	in := struct {
		Arg0 string `json:"chainId"`
	}{chainId}
	out := struct {
		Ret0 []*Currency `json:"currencies"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[11], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) DeleteCurrency(ctx context.Context, chainId string, contractAddress string) (*Currency, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"contractAddress"`
	}{chainId, contractAddress}
	out := struct {
		Ret0 *Currency `json:"currency"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[12], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *adminClient) AddCollectibles(ctx context.Context, chainId string, itemsContractAddress string, tokenIds []string) error {
	in := struct {
		Arg0 string   `json:"chainId"`
		Arg1 string   `json:"itemsContractAddress"`
		Arg2 []string `json:"tokenIds"`
	}{chainId, itemsContractAddress, tokenIds}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[13], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return err
}

type marketplaceClient struct {
	client HTTPClient
	urls   [47]string
}

func NewMarketplaceClient(addr string, client HTTPClient) MarketplaceClient {
	prefix := urlBase(addr) + MarketplacePathPrefix
	urls := [47]string{
		prefix + "ListCurrencies",
		prefix + "GetCollectionDetail",
		prefix + "GetCollectionActiveListingsCurrencies",
		prefix + "GetCollectionActiveOffersCurrencies",
		prefix + "GetCollectible",
		prefix + "GetLowestPriceOfferForCollectible",
		prefix + "GetHighestPriceOfferForCollectible",
		prefix + "GetLowestPriceListingForCollectible",
		prefix + "GetHighestPriceListingForCollectible",
		prefix + "ListListingsForCollectible",
		prefix + "ListOffersForCollectible",
		prefix + "ListOrdersWithCollectibles",
		prefix + "GetCountOfAllOrders",
		prefix + "GetCountOfFilteredOrders",
		prefix + "ListListings",
		prefix + "ListOffers",
		prefix + "GetCountOfListingsForCollectible",
		prefix + "GetCountOfOffersForCollectible",
		prefix + "GetCollectibleLowestOffer",
		prefix + "GetCollectibleHighestOffer",
		prefix + "GetCollectibleLowestListing",
		prefix + "GetCollectibleHighestListing",
		prefix + "ListCollectibleListings",
		prefix + "ListCollectibleOffers",
		prefix + "GenerateBuyTransaction",
		prefix + "GenerateSellTransaction",
		prefix + "GenerateListingTransaction",
		prefix + "GenerateOfferTransaction",
		prefix + "GenerateCancelTransaction",
		prefix + "Execute",
		prefix + "ListCollectibles",
		prefix + "GetCountOfAllCollectibles",
		prefix + "GetCountOfFilteredCollectibles",
		prefix + "GetFloorOrder",
		prefix + "ListCollectionActivities",
		prefix + "ListCollectibleActivities",
		prefix + "ListCollectiblesWithLowestListing",
		prefix + "ListCollectiblesWithHighestOffer",
		prefix + "SyncOrder",
		prefix + "SyncOrders",
		prefix + "GetOrders",
		prefix + "CheckoutOptionsMarketplace",
		prefix + "CheckoutOptionsSalesContract",
		prefix + "SupportedMarketplaces",
		prefix + "GetPrimarySaleItem",
		prefix + "ListPrimarySaleItems",
		prefix + "GetCountOfPrimarySaleItems",
	}
	return &marketplaceClient{
		client: client,
		urls:   urls,
	}
}

func (c *marketplaceClient) ListCurrencies(ctx context.Context, chainId string) ([]*Currency, error) {
	in := struct {
		Arg0 string `json:"chainId"`
	}{chainId}
	out := struct {
		Ret0 []*Currency `json:"currencies"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[0], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCollectionDetail(ctx context.Context, chainId string, contractAddress string) (*Collection, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"contractAddress"`
	}{chainId, contractAddress}
	out := struct {
		Ret0 *Collection `json:"collection"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[1], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCollectionActiveListingsCurrencies(ctx context.Context, chainId string, contractAddress string) ([]*Currency, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"contractAddress"`
	}{chainId, contractAddress}
	out := struct {
		Ret0 []*Currency `json:"currencies"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[2], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCollectionActiveOffersCurrencies(ctx context.Context, chainId string, contractAddress string) ([]*Currency, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"contractAddress"`
	}{chainId, contractAddress}
	out := struct {
		Ret0 []*Currency `json:"currencies"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[3], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string) (*TokenMetadata, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"contractAddress"`
		Arg2 string `json:"tokenId"`
	}{chainId, contractAddress, tokenId}
	out := struct {
		Ret0 *TokenMetadata `json:"metadata"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[4], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetLowestPriceOfferForCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error) {
	in := struct {
		Arg0 string       `json:"chainId"`
		Arg1 string       `json:"contractAddress"`
		Arg2 string       `json:"tokenId"`
		Arg3 *OrderFilter `json:"filter"`
	}{chainId, contractAddress, tokenId, filter}
	out := struct {
		Ret0 *Order `json:"order"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[5], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetHighestPriceOfferForCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error) {
	in := struct {
		Arg0 string       `json:"chainId"`
		Arg1 string       `json:"contractAddress"`
		Arg2 string       `json:"tokenId"`
		Arg3 *OrderFilter `json:"filter"`
	}{chainId, contractAddress, tokenId, filter}
	out := struct {
		Ret0 *Order `json:"order"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[6], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetLowestPriceListingForCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error) {
	in := struct {
		Arg0 string       `json:"chainId"`
		Arg1 string       `json:"contractAddress"`
		Arg2 string       `json:"tokenId"`
		Arg3 *OrderFilter `json:"filter"`
	}{chainId, contractAddress, tokenId, filter}
	out := struct {
		Ret0 *Order `json:"order"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[7], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetHighestPriceListingForCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error) {
	in := struct {
		Arg0 string       `json:"chainId"`
		Arg1 string       `json:"contractAddress"`
		Arg2 string       `json:"tokenId"`
		Arg3 *OrderFilter `json:"filter"`
	}{chainId, contractAddress, tokenId, filter}
	out := struct {
		Ret0 *Order `json:"order"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[8], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) ListListingsForCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error) {
	in := struct {
		Arg0 string       `json:"chainId"`
		Arg1 string       `json:"contractAddress"`
		Arg2 string       `json:"tokenId"`
		Arg3 *OrderFilter `json:"filter"`
		Arg4 *Page        `json:"page"`
	}{chainId, contractAddress, tokenId, filter, page}
	out := struct {
		Ret0 []*Order `json:"listings"`
		Ret1 *Page    `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[9], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) ListOffersForCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error) {
	in := struct {
		Arg0 string       `json:"chainId"`
		Arg1 string       `json:"contractAddress"`
		Arg2 string       `json:"tokenId"`
		Arg3 *OrderFilter `json:"filter"`
		Arg4 *Page        `json:"page"`
	}{chainId, contractAddress, tokenId, filter, page}
	out := struct {
		Ret0 []*Order `json:"offers"`
		Ret1 *Page    `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[10], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) ListOrdersWithCollectibles(ctx context.Context, chainId string, side OrderSide, contractAddress string, filter *OrdersFilter, page *Page) ([]*CollectibleOrder, *Page, error) {
	in := struct {
		Arg0 string        `json:"chainId"`
		Arg1 OrderSide     `json:"side"`
		Arg2 string        `json:"contractAddress"`
		Arg3 *OrdersFilter `json:"filter"`
		Arg4 *Page         `json:"page"`
	}{chainId, side, contractAddress, filter, page}
	out := struct {
		Ret0 []*CollectibleOrder `json:"collectibles"`
		Ret1 *Page               `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[11], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) GetCountOfAllOrders(ctx context.Context, chainId string, side OrderSide, contractAddress string) (uint64, error) {
	in := struct {
		Arg0 string    `json:"chainId"`
		Arg1 OrderSide `json:"side"`
		Arg2 string    `json:"contractAddress"`
	}{chainId, side, contractAddress}
	out := struct {
		Ret0 uint64 `json:"count"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[12], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCountOfFilteredOrders(ctx context.Context, chainId string, side OrderSide, contractAddress string, filter *OrdersFilter) (uint64, error) {
	in := struct {
		Arg0 string        `json:"chainId"`
		Arg1 OrderSide     `json:"side"`
		Arg2 string        `json:"contractAddress"`
		Arg3 *OrdersFilter `json:"filter"`
	}{chainId, side, contractAddress, filter}
	out := struct {
		Ret0 uint64 `json:"count"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[13], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) ListListings(ctx context.Context, chainId string, contractAddress string, filter *OrderFilter, page *Page) ([]*Order, *Page, error) {
	in := struct {
		Arg0 string       `json:"chainId"`
		Arg1 string       `json:"contractAddress"`
		Arg2 *OrderFilter `json:"filter"`
		Arg3 *Page        `json:"page"`
	}{chainId, contractAddress, filter, page}
	out := struct {
		Ret0 []*Order `json:"listings"`
		Ret1 *Page    `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[14], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) ListOffers(ctx context.Context, chainId string, contractAddress string, filter *OrderFilter, page *Page) ([]*Order, *Page, error) {
	in := struct {
		Arg0 string       `json:"chainId"`
		Arg1 string       `json:"contractAddress"`
		Arg2 *OrderFilter `json:"filter"`
		Arg3 *Page        `json:"page"`
	}{chainId, contractAddress, filter, page}
	out := struct {
		Ret0 []*Order `json:"offers"`
		Ret1 *Page    `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[15], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) GetCountOfListingsForCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (uint64, error) {
	in := struct {
		Arg0 string       `json:"chainId"`
		Arg1 string       `json:"contractAddress"`
		Arg2 string       `json:"tokenId"`
		Arg3 *OrderFilter `json:"filter"`
	}{chainId, contractAddress, tokenId, filter}
	out := struct {
		Ret0 uint64 `json:"count"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[16], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCountOfOffersForCollectible(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (uint64, error) {
	in := struct {
		Arg0 string       `json:"chainId"`
		Arg1 string       `json:"contractAddress"`
		Arg2 string       `json:"tokenId"`
		Arg3 *OrderFilter `json:"filter"`
	}{chainId, contractAddress, tokenId, filter}
	out := struct {
		Ret0 uint64 `json:"count"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[17], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCollectibleLowestOffer(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error) {
	in := struct {
		Arg0 string       `json:"chainId"`
		Arg1 string       `json:"contractAddress"`
		Arg2 string       `json:"tokenId"`
		Arg3 *OrderFilter `json:"filter"`
	}{chainId, contractAddress, tokenId, filter}
	out := struct {
		Ret0 *Order `json:"order"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[18], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCollectibleHighestOffer(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error) {
	in := struct {
		Arg0 string       `json:"chainId"`
		Arg1 string       `json:"contractAddress"`
		Arg2 string       `json:"tokenId"`
		Arg3 *OrderFilter `json:"filter"`
	}{chainId, contractAddress, tokenId, filter}
	out := struct {
		Ret0 *Order `json:"order"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[19], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCollectibleLowestListing(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error) {
	in := struct {
		Arg0 string       `json:"chainId"`
		Arg1 string       `json:"contractAddress"`
		Arg2 string       `json:"tokenId"`
		Arg3 *OrderFilter `json:"filter"`
	}{chainId, contractAddress, tokenId, filter}
	out := struct {
		Ret0 *Order `json:"order"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[20], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCollectibleHighestListing(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter) (*Order, error) {
	in := struct {
		Arg0 string       `json:"chainId"`
		Arg1 string       `json:"contractAddress"`
		Arg2 string       `json:"tokenId"`
		Arg3 *OrderFilter `json:"filter"`
	}{chainId, contractAddress, tokenId, filter}
	out := struct {
		Ret0 *Order `json:"order"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[21], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) ListCollectibleListings(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error) {
	in := struct {
		Arg0 string       `json:"chainId"`
		Arg1 string       `json:"contractAddress"`
		Arg2 string       `json:"tokenId"`
		Arg3 *OrderFilter `json:"filter"`
		Arg4 *Page        `json:"page"`
	}{chainId, contractAddress, tokenId, filter, page}
	out := struct {
		Ret0 []*Order `json:"listings"`
		Ret1 *Page    `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[22], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) ListCollectibleOffers(ctx context.Context, chainId string, contractAddress string, tokenId string, filter *OrderFilter, page *Page) ([]*Order, *Page, error) {
	in := struct {
		Arg0 string       `json:"chainId"`
		Arg1 string       `json:"contractAddress"`
		Arg2 string       `json:"tokenId"`
		Arg3 *OrderFilter `json:"filter"`
		Arg4 *Page        `json:"page"`
	}{chainId, contractAddress, tokenId, filter, page}
	out := struct {
		Ret0 []*Order `json:"offers"`
		Ret1 *Page    `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[23], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) GenerateBuyTransaction(ctx context.Context, chainId string, collectionAddress string, buyer string, marketplace MarketplaceKind, ordersData []*OrderData, additionalFees []*AdditionalFee, walletType *WalletKind) ([]*Step, error) {
	in := struct {
		Arg0 string           `json:"chainId"`
		Arg1 string           `json:"collectionAddress"`
		Arg2 string           `json:"buyer"`
		Arg3 MarketplaceKind  `json:"marketplace"`
		Arg4 []*OrderData     `json:"ordersData"`
		Arg5 []*AdditionalFee `json:"additionalFees"`
		Arg6 *WalletKind      `json:"walletType"`
	}{chainId, collectionAddress, buyer, marketplace, ordersData, additionalFees, walletType}
	out := struct {
		Ret0 []*Step `json:"steps"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[24], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GenerateSellTransaction(ctx context.Context, chainId string, collectionAddress string, seller string, marketplace MarketplaceKind, ordersData []*OrderData, additionalFees []*AdditionalFee, walletType *WalletKind) ([]*Step, error) {
	in := struct {
		Arg0 string           `json:"chainId"`
		Arg1 string           `json:"collectionAddress"`
		Arg2 string           `json:"seller"`
		Arg3 MarketplaceKind  `json:"marketplace"`
		Arg4 []*OrderData     `json:"ordersData"`
		Arg5 []*AdditionalFee `json:"additionalFees"`
		Arg6 *WalletKind      `json:"walletType"`
	}{chainId, collectionAddress, seller, marketplace, ordersData, additionalFees, walletType}
	out := struct {
		Ret0 []*Step `json:"steps"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[25], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GenerateListingTransaction(ctx context.Context, chainId string, collectionAddress string, owner string, contractType ContractType, orderbook OrderbookKind, listing *CreateReq, additionalFees []*AdditionalFee, walletType *WalletKind) ([]*Step, error) {
	in := struct {
		Arg0 string           `json:"chainId"`
		Arg1 string           `json:"collectionAddress"`
		Arg2 string           `json:"owner"`
		Arg3 ContractType     `json:"contractType"`
		Arg4 OrderbookKind    `json:"orderbook"`
		Arg5 *CreateReq       `json:"listing"`
		Arg6 []*AdditionalFee `json:"additionalFees"`
		Arg7 *WalletKind      `json:"walletType"`
	}{chainId, collectionAddress, owner, contractType, orderbook, listing, additionalFees, walletType}
	out := struct {
		Ret0 []*Step `json:"steps"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[26], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GenerateOfferTransaction(ctx context.Context, chainId string, collectionAddress string, maker string, contractType ContractType, orderbook OrderbookKind, offer *CreateReq, additionalFees []*AdditionalFee, walletType *WalletKind, offerType OfferType) ([]*Step, error) {
	in := struct {
		Arg0 string           `json:"chainId"`
		Arg1 string           `json:"collectionAddress"`
		Arg2 string           `json:"maker"`
		Arg3 ContractType     `json:"contractType"`
		Arg4 OrderbookKind    `json:"orderbook"`
		Arg5 *CreateReq       `json:"offer"`
		Arg6 []*AdditionalFee `json:"additionalFees"`
		Arg7 *WalletKind      `json:"walletType"`
		Arg8 OfferType        `json:"offerType"`
	}{chainId, collectionAddress, maker, contractType, orderbook, offer, additionalFees, walletType, offerType}
	out := struct {
		Ret0 []*Step `json:"steps"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[27], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GenerateCancelTransaction(ctx context.Context, chainId string, collectionAddress string, maker string, marketplace MarketplaceKind, orderId string) ([]*Step, error) {
	in := struct {
		Arg0 string          `json:"chainId"`
		Arg1 string          `json:"collectionAddress"`
		Arg2 string          `json:"maker"`
		Arg3 MarketplaceKind `json:"marketplace"`
		Arg4 string          `json:"orderId"`
	}{chainId, collectionAddress, maker, marketplace, orderId}
	out := struct {
		Ret0 []*Step `json:"steps"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[28], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) Execute(ctx context.Context, params *ExecuteInput, chainId *string, signature *string, method *string, endpoint *string, executeType *ExecuteType, body *interface{}) (string, error) {
	in := struct {
		Arg0 *ExecuteInput `json:"params"`
		Arg1 *string       `json:"chainId"`
		Arg2 *string       `json:"signature"`
		Arg3 *string       `json:"method"`
		Arg4 *string       `json:"endpoint"`
		Arg5 *ExecuteType  `json:"executeType"`
		Arg6 *interface{}  `json:"body"`
	}{params, chainId, signature, method, endpoint, executeType, body}
	out := struct {
		Ret0 string `json:"orderId"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[29], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) ListCollectibles(ctx context.Context, chainId string, side OrderSide, contractAddress string, filter *CollectiblesFilter, page *Page) ([]*CollectibleOrder, *Page, error) {
	in := struct {
		Arg0 string              `json:"chainId"`
		Arg1 OrderSide           `json:"side"`
		Arg2 string              `json:"contractAddress"`
		Arg3 *CollectiblesFilter `json:"filter"`
		Arg4 *Page               `json:"page"`
	}{chainId, side, contractAddress, filter, page}
	out := struct {
		Ret0 []*CollectibleOrder `json:"collectibles"`
		Ret1 *Page               `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[30], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) GetCountOfAllCollectibles(ctx context.Context, chainId string, contractAddress string) (uint64, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"contractAddress"`
	}{chainId, contractAddress}
	out := struct {
		Ret0 uint64 `json:"count"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[31], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetCountOfFilteredCollectibles(ctx context.Context, chainId string, side OrderSide, contractAddress string, filter *CollectiblesFilter) (uint64, error) {
	in := struct {
		Arg0 string              `json:"chainId"`
		Arg1 OrderSide           `json:"side"`
		Arg2 string              `json:"contractAddress"`
		Arg3 *CollectiblesFilter `json:"filter"`
	}{chainId, side, contractAddress, filter}
	out := struct {
		Ret0 uint64 `json:"count"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[32], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetFloorOrder(ctx context.Context, chainId string, contractAddress string, filter *CollectiblesFilter) (*CollectibleOrder, error) {
	in := struct {
		Arg0 string              `json:"chainId"`
		Arg1 string              `json:"contractAddress"`
		Arg2 *CollectiblesFilter `json:"filter"`
	}{chainId, contractAddress, filter}
	out := struct {
		Ret0 *CollectibleOrder `json:"collectible"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[33], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) ListCollectionActivities(ctx context.Context, chainId string, contractAddress string, page *Page) ([]*Activity, *Page, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"contractAddress"`
		Arg2 *Page  `json:"page"`
	}{chainId, contractAddress, page}
	out := struct {
		Ret0 []*Activity `json:"activities"`
		Ret1 *Page       `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[34], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) ListCollectibleActivities(ctx context.Context, chainId string, contractAddress string, tokenId string, page *Page) ([]*Activity, *Page, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"contractAddress"`
		Arg2 string `json:"tokenId"`
		Arg3 *Page  `json:"page"`
	}{chainId, contractAddress, tokenId, page}
	out := struct {
		Ret0 []*Activity `json:"activities"`
		Ret1 *Page       `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[35], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) ListCollectiblesWithLowestListing(ctx context.Context, chainId string, contractAddress string, filter *CollectiblesFilter, page *Page) ([]*CollectibleOrder, *Page, error) {
	in := struct {
		Arg0 string              `json:"chainId"`
		Arg1 string              `json:"contractAddress"`
		Arg2 *CollectiblesFilter `json:"filter"`
		Arg3 *Page               `json:"page"`
	}{chainId, contractAddress, filter, page}
	out := struct {
		Ret0 []*CollectibleOrder `json:"collectibles"`
		Ret1 *Page               `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[36], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) ListCollectiblesWithHighestOffer(ctx context.Context, chainId string, contractAddress string, filter *CollectiblesFilter, page *Page) ([]*CollectibleOrder, *Page, error) {
	in := struct {
		Arg0 string              `json:"chainId"`
		Arg1 string              `json:"contractAddress"`
		Arg2 *CollectiblesFilter `json:"filter"`
		Arg3 *Page               `json:"page"`
	}{chainId, contractAddress, filter, page}
	out := struct {
		Ret0 []*CollectibleOrder `json:"collectibles"`
		Ret1 *Page               `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[37], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) SyncOrder(ctx context.Context, chainId string, order *Order) error {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 *Order `json:"order"`
	}{chainId, order}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[38], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return err
}

func (c *marketplaceClient) SyncOrders(ctx context.Context, chainId string, orders []*Order) error {
	in := struct {
		Arg0 string   `json:"chainId"`
		Arg1 []*Order `json:"orders"`
	}{chainId, orders}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[39], in, nil)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return err
}

func (c *marketplaceClient) GetOrders(ctx context.Context, chainId string, input []*GetOrdersInput, page *Page) ([]*Order, *Page, error) {
	in := struct {
		Arg0 string            `json:"chainId"`
		Arg1 []*GetOrdersInput `json:"input"`
		Arg2 *Page             `json:"page"`
	}{chainId, input, page}
	out := struct {
		Ret0 []*Order `json:"orders"`
		Ret1 *Page    `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[40], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) CheckoutOptionsMarketplace(ctx context.Context, chainId string, wallet string, orders []*CheckoutOptionsMarketplaceOrder, additionalFee int) (*CheckoutOptions, error) {
	in := struct {
		Arg0 string                             `json:"chainId"`
		Arg1 string                             `json:"wallet"`
		Arg2 []*CheckoutOptionsMarketplaceOrder `json:"orders"`
		Arg3 int                                `json:"additionalFee"`
	}{chainId, wallet, orders, additionalFee}
	out := struct {
		Ret0 *CheckoutOptions `json:"options"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[41], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) CheckoutOptionsSalesContract(ctx context.Context, chainId string, wallet string, contractAddress string, collectionAddress string, items []*CheckoutOptionsItem) (*CheckoutOptions, error) {
	in := struct {
		Arg0 string                 `json:"chainId"`
		Arg1 string                 `json:"wallet"`
		Arg2 string                 `json:"contractAddress"`
		Arg3 string                 `json:"collectionAddress"`
		Arg4 []*CheckoutOptionsItem `json:"items"`
	}{chainId, wallet, contractAddress, collectionAddress, items}
	out := struct {
		Ret0 *CheckoutOptions `json:"options"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[42], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) SupportedMarketplaces(ctx context.Context, chainId string) ([]MarketplaceKind, error) {
	in := struct {
		Arg0 string `json:"chainId"`
	}{chainId}
	out := struct {
		Ret0 []MarketplaceKind `json:"marketplaces"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[43], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) GetPrimarySaleItem(ctx context.Context, chainId string, primarySaleContractAddress string, tokenId string) (*CollectiblePrimarySaleItem, error) {
	in := struct {
		Arg0 string `json:"chainId"`
		Arg1 string `json:"primarySaleContractAddress"`
		Arg2 string `json:"tokenId"`
	}{chainId, primarySaleContractAddress, tokenId}
	out := struct {
		Ret0 *CollectiblePrimarySaleItem `json:"item"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[44], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

func (c *marketplaceClient) ListPrimarySaleItems(ctx context.Context, chainId string, primarySaleContractAddress string, filter *PrimarySaleItemsFilter, page *Page) ([]*CollectiblePrimarySaleItem, *Page, error) {
	in := struct {
		Arg0 string                  `json:"chainId"`
		Arg1 string                  `json:"primarySaleContractAddress"`
		Arg2 *PrimarySaleItemsFilter `json:"filter"`
		Arg3 *Page                   `json:"page"`
	}{chainId, primarySaleContractAddress, filter, page}
	out := struct {
		Ret0 []*CollectiblePrimarySaleItem `json:"primarySaleItems"`
		Ret1 *Page                         `json:"page"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[45], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, out.Ret1, err
}

func (c *marketplaceClient) GetCountOfPrimarySaleItems(ctx context.Context, chainId string, primarySaleContractAddress string, filter *PrimarySaleItemsFilter) (uint64, error) {
	in := struct {
		Arg0 string                  `json:"chainId"`
		Arg1 string                  `json:"primarySaleContractAddress"`
		Arg2 *PrimarySaleItemsFilter `json:"filter"`
	}{chainId, primarySaleContractAddress, filter}
	out := struct {
		Ret0 uint64 `json:"count"`
	}{}

	resp, err := doHTTPRequest(ctx, c.client, c.urls[46], in, &out)
	if resp != nil {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = ErrWebrpcRequestFailed.WithCausef("failed to close response body: %w", cerr)
		}
	}

	return out.Ret0, err
}

//
// Client helpers
//

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// urlBase helps ensure that addr specifies a scheme. If it is unparsable
// as a URL, it returns addr unchanged.
func urlBase(addr string) string {
	// If the addr specifies a scheme, use it. If not, default to
	// http. If url.Parse fails on it, return it unchanged.
	url, err := url.Parse(addr)
	if err != nil {
		return addr
	}
	if url.Scheme == "" {
		url.Scheme = "http"
	}
	return url.String()
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) {
	req, err := http.NewRequestWithContext(ctx, "POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", contentType)
	req.Header.Set("Content-Type", contentType)
	req.Header.Set(WebrpcHeader, WebrpcHeaderValue)
	if headers, ok := HTTPRequestHeaders(ctx); ok {
		for k := range headers {
			for _, v := range headers[k] {
				req.Header.Add(k, v)
			}
		}
	}
	return req, nil
}

// doHTTPRequest is common code to make a request to the remote service.
func doHTTPRequest(ctx context.Context, client HTTPClient, url string, in, out interface{}) (*http.Response, error) {
	reqBody, err := json.Marshal(in)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("failed to marshal JSON body: %w", err)
	}
	if err = ctx.Err(); err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("aborted because context was done: %w", err)
	}

	req, err := newRequest(ctx, url, bytes.NewBuffer(reqBody), "application/json")
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCausef("could not build request: %w", err)
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, ErrWebrpcRequestFailed.WithCause(err)
	}

	if resp.StatusCode != 200 {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to read server error response body: %w", err)
		}

		var rpcErr WebRPCError
		if err := json.Unmarshal(respBody, &rpcErr); err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to unmarshal server error: %w", err)
		}
		if rpcErr.Cause != "" {
			rpcErr.cause = errors.New(rpcErr.Cause)
		}
		return nil, rpcErr
	}

	if out != nil {
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to read response body: %w", err)
		}

		err = json.Unmarshal(respBody, &out)
		if err != nil {
			return nil, ErrWebrpcBadResponse.WithCausef("failed to unmarshal JSON response body: %w", err)
		}
	}

	return resp, nil
}

func WithHTTPRequestHeaders(ctx context.Context, h http.Header) (context.Context, error) {
	if _, ok := h["Accept"]; ok {
		return nil, errors.New("provided header cannot set Accept")
	}
	if _, ok := h["Content-Type"]; ok {
		return nil, errors.New("provided header cannot set Content-Type")
	}

	copied := make(http.Header, len(h))
	for k, vv := range h {
		if vv == nil {
			copied[k] = nil
			continue
		}
		copied[k] = make([]string, len(vv))
		copy(copied[k], vv)
	}

	return context.WithValue(ctx, HTTPClientRequestHeadersCtxKey, copied), nil
}

func HTTPRequestHeaders(ctx context.Context) (http.Header, bool) {
	h, ok := ctx.Value(HTTPClientRequestHeadersCtxKey).(http.Header)
	return h, ok
}

//
// Webrpc helpers
//

type contextKey struct {
	name string
}

func (k *contextKey) String() string {
	return "webrpc context value " + k.name
}

var (
	HTTPClientRequestHeadersCtxKey = &contextKey{"HTTPClientRequestHeaders"}
)

// PtrTo is a useful helper when constructing values for optional fields.
func PtrTo[T any](v T) *T { return &v }

//
// BigInt helpers
//

// BigInt is an alias of big.Int with custom JSON (decimal string) encoding.
type BigInt big.Int

func NewBigInt(v int64) BigInt { var bi big.Int; bi.SetInt64(v); return BigInt(bi) }

// AsInt exposes the underlying *big.Int.
func (b *BigInt) AsInt() *big.Int { return (*big.Int)(b) }

// String returns the decimal string representation of the BigInt.
func (b BigInt) String() string { return b.AsInt().String() }

// MarshalText implements encoding.TextMarshaler.
func (b BigInt) MarshalText() ([]byte, error) {
	return []byte(fmt.Sprintf("\"%s\"", b.String())), nil
}

// UnmarshalText implements encoding.TextUnmarshaler.
func (b *BigInt) UnmarshalText(text []byte) error {
	if len(text) == 0 {
		return nil
	}
	if len(text) == 4 && text[0] == 'n' && string(text) == "null" {
		return nil
	}
	for _, c := range text {
		if c == ' ' || c == '\t' || c == '\n' || c == '\r' {
			return fmt.Errorf("BigInt.UnmarshalText: unexpected whitespace in %q", text)
		}
	}
	var digits []byte
	if text[0] == '-' || (text[0] >= '0' && text[0] <= '9') {
		digits = text
	} else {
		if len(text) < 2 || text[0] != '"' || text[len(text)-1] != '"' {
			return fmt.Errorf("BigInt.UnmarshalText: unsupported format %q", text)
		}
		digits = text[1 : len(text)-1]
	}
	i, ok := big.NewInt(0).SetString(string(digits), 10)
	if !ok {
		return fmt.Errorf("BigInt.UnmarshalText: failed to parse %q", text)
	}
	*b = BigInt(*i)
	return nil
}

// MarshalJSON implements json.Marshaler
func (b BigInt) MarshalJSON() ([]byte, error) {
	return b.MarshalText()
}

// UnmarshalJSON implements json.Unmarshaler
func (b *BigInt) UnmarshalJSON(text []byte) error {
	if string(text) == "null" {
		return nil
	}
	return b.UnmarshalText(text)
}

// MarshalBinary implements encoding.BinaryMarshaler. The first byte is the sign byte
// to represent positive or negative numbers.
func (b BigInt) MarshalBinary() ([]byte, error) {
	bytes := b.AsInt().Bytes()
	out := make([]byte, len(bytes)+1)
	copy(out[1:], bytes)
	if b.AsInt().Sign() < 0 {
		// Prepend a sign byte (0xFF for negative)
		out[0] = 0xFF
	} else {
		// For zero or positive numbers, prepend 0x00
		out[0] = 0x00
	}
	return out, nil
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler. The first byte is the sign byte
// to represent positive or negative numbers.
func (b *BigInt) UnmarshalBinary(buff []byte) error {
	if len(buff) == 0 {
		*b = BigInt(*big.NewInt(0))
		return nil
	}
	// Extract the sign byte
	signByte := buff[0]
	i := new(big.Int)
	if len(buff) > 1 {
		i.SetBytes(buff[1:])
	}
	// Apply sign if negative
	if signByte == 0xFF {
		i.Neg(i)
	}
	*b = BigInt(*i)
	return nil
}

func (b BigInt) Value() (driver.Value, error) {
	return b.String(), nil
}

func (b *BigInt) Scan(src interface{}) error {
	if src == nil {
		return nil
	}

	var svalue string
	switch v := src.(type) {
	case string:
		svalue = v
	case []byte:
		svalue = string(v)
	default:
		return fmt.Errorf("BigInt.Scan: unexpected type %T", src)
	}

	// pgx driver returns NeX where N is digits and X is exponent
	parts := strings.SplitN(svalue, "e", 2)

	var ok bool
	i := &big.Int{}
	i, ok = i.SetString(parts[0], 10)
	if !ok {
		return fmt.Errorf("BigInt.Scan: failed to scan value %q", svalue)
	}

	if len(parts) >= 2 {
		exp := big.NewInt(0)
		exp, ok = exp.SetString(parts[1], 10)
		if !ok {
			return fmt.Errorf("BigInt.Scan failed to scan exp component %q", svalue)
		}
		i = i.Mul(i, big.NewInt(1).Exp(big.NewInt(10), exp, nil))
	}

	*b = BigInt(*i)
	return nil
}

//
// Errors
//

type WebRPCError struct {
	Name       string `json:"error"`
	Code       int    `json:"code"`
	Message    string `json:"msg"`
	Cause      string `json:"cause,omitempty"`
	HTTPStatus int    `json:"status"`
	cause      error
}

var _ error = WebRPCError{}

func (e WebRPCError) Error() string {
	if e.cause != nil {
		return fmt.Sprintf("%s %d: %s: %v", e.Name, e.Code, e.Message, e.cause)
	}
	return fmt.Sprintf("%s %d: %s", e.Name, e.Code, e.Message)
}

func (e WebRPCError) Is(target error) bool {
	if target == nil {
		return false
	}
	if rpcErr, ok := target.(WebRPCError); ok {
		return rpcErr.Code == e.Code
	}
	return errors.Is(e.cause, target)
}

func (e WebRPCError) Unwrap() error {
	return e.cause
}

func (e WebRPCError) WithCause(cause error) WebRPCError {
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

func (e WebRPCError) WithCausef(format string, args ...interface{}) WebRPCError {
	cause := fmt.Errorf(format, args...)
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

// Deprecated: Use .WithCause() method on WebRPCError.
func ErrorWithCause(rpcErr WebRPCError, cause error) WebRPCError {
	return rpcErr.WithCause(cause)
}

// Webrpc errors
var (
	ErrWebrpcEndpoint       = WebRPCError{Code: 0, Name: "WebrpcEndpoint", Message: "endpoint error", HTTPStatus: 400}
	ErrWebrpcRequestFailed  = WebRPCError{Code: -1, Name: "WebrpcRequestFailed", Message: "request failed", HTTPStatus: 400}
	ErrWebrpcBadRoute       = WebRPCError{Code: -2, Name: "WebrpcBadRoute", Message: "bad route", HTTPStatus: 404}
	ErrWebrpcBadMethod      = WebRPCError{Code: -3, Name: "WebrpcBadMethod", Message: "bad method", HTTPStatus: 405}
	ErrWebrpcBadRequest     = WebRPCError{Code: -4, Name: "WebrpcBadRequest", Message: "bad request", HTTPStatus: 400}
	ErrWebrpcBadResponse    = WebRPCError{Code: -5, Name: "WebrpcBadResponse", Message: "bad response", HTTPStatus: 500}
	ErrWebrpcServerPanic    = WebRPCError{Code: -6, Name: "WebrpcServerPanic", Message: "server panic", HTTPStatus: 500}
	ErrWebrpcInternalError  = WebRPCError{Code: -7, Name: "WebrpcInternalError", Message: "internal error", HTTPStatus: 500}
	ErrWebrpcClientAborted  = WebRPCError{Code: -8, Name: "WebrpcClientAborted", Message: "request aborted by client", HTTPStatus: 400}
	ErrWebrpcStreamLost     = WebRPCError{Code: -9, Name: "WebrpcStreamLost", Message: "stream lost", HTTPStatus: 400}
	ErrWebrpcStreamFinished = WebRPCError{Code: -10, Name: "WebrpcStreamFinished", Message: "stream finished", HTTPStatus: 200}
)

// Schema errors
var (
	ErrUnauthorized            = WebRPCError{Code: 1000, Name: "Unauthorized", Message: "Unauthorized access", HTTPStatus: 401}
	ErrPermissionDenied        = WebRPCError{Code: 1001, Name: "PermissionDenied", Message: "Permission denied", HTTPStatus: 403}
	ErrSessionExpired          = WebRPCError{Code: 1002, Name: "SessionExpired", Message: "Session expired", HTTPStatus: 403}
	ErrMethodNotFound          = WebRPCError{Code: 1003, Name: "MethodNotFound", Message: "Method not found", HTTPStatus: 404}
	ErrRequestConflict         = WebRPCError{Code: 1004, Name: "RequestConflict", Message: "Conflict with target resource", HTTPStatus: 409}
	ErrAborted                 = WebRPCError{Code: 1005, Name: "Aborted", Message: "Request aborted", HTTPStatus: 400}
	ErrGeoblocked              = WebRPCError{Code: 1006, Name: "Geoblocked", Message: "Geoblocked region", HTTPStatus: 451}
	ErrRateLimited             = WebRPCError{Code: 1007, Name: "RateLimited", Message: "Rate-limited. Please slow down.", HTTPStatus: 429}
	ErrProjectNotFound         = WebRPCError{Code: 1008, Name: "ProjectNotFound", Message: "Project not found", HTTPStatus: 401}
	ErrSecretKeyCorsDisallowed = WebRPCError{Code: 1009, Name: "SecretKeyCorsDisallowed", Message: "CORS disallowed. Admin API Secret Key can't be used from a web app.", HTTPStatus: 403}
	ErrAccessKeyNotFound       = WebRPCError{Code: 1101, Name: "AccessKeyNotFound", Message: "Access key not found", HTTPStatus: 401}
	ErrAccessKeyMismatch       = WebRPCError{Code: 1102, Name: "AccessKeyMismatch", Message: "Access key mismatch", HTTPStatus: 403}
	ErrInvalidOrigin           = WebRPCError{Code: 1103, Name: "InvalidOrigin", Message: "Invalid origin for Access Key", HTTPStatus: 403}
	ErrInvalidService          = WebRPCError{Code: 1104, Name: "InvalidService", Message: "Service not enabled for Access key", HTTPStatus: 403}
	ErrUnauthorizedUser        = WebRPCError{Code: 1105, Name: "UnauthorizedUser", Message: "Unauthorized user", HTTPStatus: 403}
	ErrInvalidChain            = WebRPCError{Code: 1106, Name: "InvalidChain", Message: "Network not enabled for Access key", HTTPStatus: 403}
	ErrQuotaExceeded           = WebRPCError{Code: 1200, Name: "QuotaExceeded", Message: "Quota request exceeded", HTTPStatus: 429}
	ErrQuotaRateLimit          = WebRPCError{Code: 1201, Name: "QuotaRateLimit", Message: "Quota rate limit exceeded", HTTPStatus: 429}
	ErrNoDefaultKey            = WebRPCError{Code: 1300, Name: "NoDefaultKey", Message: "No default access key found", HTTPStatus: 403}
	ErrMaxAccessKeys           = WebRPCError{Code: 1301, Name: "MaxAccessKeys", Message: "Access keys limit reached", HTTPStatus: 403}
	ErrAtLeastOneKey           = WebRPCError{Code: 1302, Name: "AtLeastOneKey", Message: "You need at least one Access Key", HTTPStatus: 403}
	ErrTimeout                 = WebRPCError{Code: 1900, Name: "Timeout", Message: "Request timed out", HTTPStatus: 408}
	ErrNotFound                = WebRPCError{Code: 2000, Name: "NotFound", Message: "Resource not found", HTTPStatus: 400}
	ErrInvalidArgument         = WebRPCError{Code: 2001, Name: "InvalidArgument", Message: "Invalid argument", HTTPStatus: 400}
	ErrNotImplemented          = WebRPCError{Code: 9999, Name: "NotImplemented", Message: "Not Implemented", HTTPStatus: 500}
)

const WebrpcHeader = "Webrpc"

const WebrpcHeaderValue = "webrpc@v0.31.1;gen-golang@v0.23.3;marketplace-api@v0-25.10.27+02ad2e0"

type WebrpcGenVersions struct {
	WebrpcGenVersion string
	CodeGenName      string
	CodeGenVersion   string
	SchemaName       string
	SchemaVersion    string
}

func VersionFromHeader(h http.Header) (*WebrpcGenVersions, error) {
	if h.Get(WebrpcHeader) == "" {
		return nil, fmt.Errorf("header is empty or missing")
	}

	versions, err := parseWebrpcGenVersions(h.Get(WebrpcHeader))
	if err != nil {
		return nil, fmt.Errorf("webrpc header is invalid: %w", err)
	}

	return versions, nil
}

func parseWebrpcGenVersions(header string) (*WebrpcGenVersions, error) {
	versions := strings.Split(header, ";")
	if len(versions) < 3 {
		return nil, fmt.Errorf("expected at least 3 parts while parsing webrpc header: %v", header)
	}

	_, webrpcGenVersion, ok := strings.Cut(versions[0], "@")
	if !ok {
		return nil, fmt.Errorf("webrpc gen version could not be parsed from: %s", versions[0])
	}

	tmplTarget, tmplVersion, ok := strings.Cut(versions[1], "@")
	if !ok {
		return nil, fmt.Errorf("tmplTarget and tmplVersion could not be parsed from: %s", versions[1])
	}

	schemaName, schemaVersion, ok := strings.Cut(versions[2], "@")
	if !ok {
		return nil, fmt.Errorf("schema name and schema version could not be parsed from: %s", versions[2])
	}

	return &WebrpcGenVersions{
		WebrpcGenVersion: webrpcGenVersion,
		CodeGenName:      tmplTarget,
		CodeGenVersion:   tmplVersion,
		SchemaName:       schemaName,
		SchemaVersion:    schemaVersion,
	}, nil
}
